###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        13/Apr/2020  09:23:55
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\User\ui\QRENCODE\bitstream.c
#    Command line =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\User\ui\QRENCODE\bitstream.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        -lA
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/Multi_language\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/QRENCODE\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\..\Middlewares\GUI\
#        -Oh --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\bitstream.lst
#    Object file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\bitstream.o
#
###############################################################################

D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\User\ui\QRENCODE\bitstream.c
      1          /*
      2           * qrencode - QR Code encoder
      3           *
      4           * Binary sequence class.
      5           * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>
      6           *
      7           * This library is free software; you can redistribute it and/or
      8           * modify it under the terms of the GNU Lesser General Public
      9           * License as published by the Free Software Foundation; either
     10           * version 2.1 of the License, or any later version.
     11           *
     12           * This library is distributed in the hope that it will be useful,
     13           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     14           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     15           * Lesser General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU Lesser General Public
     18           * License along with this library; if not, write to the Free Software
     19           * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
     20           */
     21          
     22          #if HAVE_CONFIG_H
     23          # include "config.h"
     24          #endif
     25          #include <stdio.h>
     26          #include <stdlib.h>
     27          #include <string.h>
     28          
     29          #include "bitstream.h"
     30          

   \                                 In section .text, align 2, keep-with-next
     31          BitStream *BitStream_new(void)
     32          {
   \                     BitStream_new: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     33          	BitStream *bstream;
     34          
     35          	bstream = (BitStream *)malloc(sizeof(BitStream));
   \   00000002   0x2008             MOVS     R0,#+8
   \   00000004   0x.... 0x....      BL       malloc
     36          	if(bstream == NULL) return NULL;
   \   00000008   0xB110             CBZ.N    R0,??BitStream_new_0
     37          
     38          	bstream->length = 0;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
     39          	bstream->data = NULL;
   \   0000000E   0x6041             STR      R1,[R0, #+4]
     40          
     41          	return bstream;
   \                     ??BitStream_new_0: (+1)
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
     42          }
     43          
     44          static int BitStream_allocate(BitStream *bstream, int length)
     45          {
     46          	unsigned char *data;
     47          
     48          	if(bstream == NULL) {
     49          		return -1;
     50          	}
     51          
     52          	data = (unsigned char *)malloc(length);
     53          	if(data == NULL) {
     54          		return -1;
     55          	}
     56          
     57          	if(bstream->data) {
     58          		free(bstream->data);
     59          	}
     60          	bstream->length = length;
     61          	bstream->data = data;
     62          
     63          	return 0;
     64          }
     65          
     66          static BitStream *BitStream_newFromNum(int bits, unsigned int num)
     67          {
     68          	unsigned int mask;
     69          	int i;
     70          	unsigned char *p;
     71          	BitStream *bstream;
     72          
     73          	bstream = BitStream_new();
     74          	if(bstream == NULL) return NULL;
     75          
     76          	if(BitStream_allocate(bstream, bits)) {
     77          		BitStream_free(bstream);
     78          		return NULL;
     79          	}
     80          
     81          	p = bstream->data;
     82          	mask = 1 << (bits - 1);
     83          	for(i=0; i<bits; i++) {
     84          		if(num & mask) {
     85          			*p = 1;
     86          		} else {
     87          			*p = 0;
     88          		}
     89          		p++;
     90          		mask = mask >> 1;
     91          	}
     92          
     93          	return bstream;
     94          }
     95          
     96          static BitStream *BitStream_newFromBytes(int size, unsigned char *data)
     97          {
     98          	unsigned char mask;
     99          	int i, j;
    100          	unsigned char *p;
    101          	BitStream *bstream;
    102          
    103          	bstream = BitStream_new();
    104          	if(bstream == NULL) return NULL;
    105          
    106          	if(BitStream_allocate(bstream, size * 8)) {
    107          		BitStream_free(bstream);
    108          		return NULL;
    109          	}
    110          
    111          	p = bstream->data;
    112          	for(i=0; i<size; i++) {
    113          		mask = 0x80;
    114          		for(j=0; j<8; j++) {
    115          			if(data[i] & mask) {
    116          				*p = 1;
    117          			} else {
    118          				*p = 0;
    119          			}
    120          			p++;
    121          			mask = mask >> 1;
    122          		}
    123          	}
    124          
    125          	return bstream;
    126          }
    127          

   \                                 In section .text, align 2, keep-with-next
    128          int BitStream_append(BitStream *bstream, BitStream *arg)
    129          {
   \                     BitStream_append: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    130          	unsigned char *data;
    131          
    132          	if(arg == NULL) {
   \   00000006   0xD01A             BEQ.N    ??BitStream_append_0
    133          		return -1;
    134          	}
    135          	if(arg->length == 0) {
   \   00000008   0x682E             LDR      R6,[R5, #+0]
   \   0000000A   0xB36E             CBZ.N    R6,??BitStream_append_1
    136          		return 0;
    137          	}
    138          	if(bstream->length == 0) {
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xB988             CBNZ.N   R0,??BitStream_append_2
    139          		if(BitStream_allocate(bstream, arg->length)) {
   \   00000010   0xB1AC             CBZ.N    R4,??BitStream_append_0
   \   00000012   0x4630             MOV      R0,R6
   \   00000014   0x.... 0x....      BL       malloc
   \   00000018   0x0007             MOVS     R7,R0
   \   0000001A   0xD010             BEQ.N    ??BitStream_append_0
   \   0000001C   0x6860             LDR      R0,[R4, #+4]
   \   0000001E   0xB108             CBZ.N    R0,??BitStream_append_3
   \   00000020   0x.... 0x....      BL       free
   \                     ??BitStream_append_3: (+1)
   \   00000024   0x6026             STR      R6,[R4, #+0]
   \   00000026   0x6067             STR      R7,[R4, #+4]
    140          			return -1;
    141          		}
    142          		memcpy(bstream->data, arg->data, arg->length);
   \   00000028   0x682A             LDR      R2,[R5, #+0]
   \   0000002A   0x6869             LDR      R1,[R5, #+4]
   \   0000002C   0x4638             MOV      R0,R7
   \   0000002E   0x.... 0x....      BL       __aeabi_memcpy
    143          		return 0;
   \   00000032   0xE019             B.N      ??BitStream_append_1
    144          	}
    145          
    146          	data = (unsigned char *)malloc(bstream->length + arg->length);
   \                     ??BitStream_append_2: (+1)
   \   00000034   0x1830             ADDS     R0,R6,R0
   \   00000036   0x.... 0x....      BL       malloc
   \   0000003A   0x0006             MOVS     R6,R0
    147          	if(data == NULL) {
   \   0000003C   0xD102             BNE.N    ??BitStream_append_4
    148          		return -1;
   \                     ??BitStream_append_0: (+1)
   \   0000003E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}
    149          	}
    150          	memcpy(data, bstream->data, bstream->length);
   \                     ??BitStream_append_4: (+1)
   \   00000044   0x6822             LDR      R2,[R4, #+0]
   \   00000046   0x6861             LDR      R1,[R4, #+4]
   \   00000048   0x.... 0x....      BL       __aeabi_memcpy
    151          	memcpy(data + bstream->length, arg->data, arg->length);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x682A             LDR      R2,[R5, #+0]
   \   00000050   0x6869             LDR      R1,[R5, #+4]
   \   00000052   0x1980             ADDS     R0,R0,R6
   \   00000054   0x.... 0x....      BL       __aeabi_memcpy
    152          
    153          	free(bstream->data);
   \   00000058   0x6860             LDR      R0,[R4, #+4]
   \   0000005A   0x.... 0x....      BL       free
    154          	bstream->length += arg->length;
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6829             LDR      R1,[R5, #+0]
   \   00000062   0x1808             ADDS     R0,R1,R0
   \   00000064   0x6020             STR      R0,[R4, #+0]
    155          	bstream->data = data;
   \   00000066   0x6066             STR      R6,[R4, #+4]
    156          
    157          	return 0;
   \                     ??BitStream_append_1: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    158          }
    159          

   \                                 In section .text, align 2, keep-with-next
    160          int BitStream_appendNum(BitStream *bstream, int bits, unsigned int num)
    161          {
   \                     BitStream_appendNum: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x4690             MOV      R8,R2
    162          	BitStream *b;
    163          	int ret;
    164          
    165          	if(bits == 0) return 0;
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0x2000             MOVEQ    R0,#+0
   \   0000000E   0xD006             BEQ.N    ??BitStream_appendNum_0
    166          
    167          	b = BitStream_newFromNum(bits, num);
   \   00000010   0x2008             MOVS     R0,#+8
   \   00000012   0x.... 0x....      BL       malloc
   \   00000016   0x0004             MOVS     R4,R0
   \   00000018   0xD103             BNE.N    ??BitStream_appendNum_1
    168          	if(b == NULL) return -1;
   \                     ??BitStream_appendNum_2: (+1)
   \   0000001A   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??BitStream_appendNum_0: (+1)
   \   0000001E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??BitStream_appendNum_1: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6020             STR      R0,[R4, #+0]
   \   00000026   0x6060             STR      R0,[R4, #+4]
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       malloc
   \   0000002E   0x0007             MOVS     R7,R0
   \   00000030   0x6860             LDR      R0,[R4, #+4]
   \   00000032   0xD023             BEQ.N    ??BitStream_appendNum_3
   \   00000034   0xB108             CBZ.N    R0,??BitStream_appendNum_4
   \   00000036   0x.... 0x....      BL       free
   \                     ??BitStream_appendNum_4: (+1)
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x1E72             SUBS     R2,R6,#+1
   \   0000003E   0x6026             STR      R6,[R4, #+0]
   \   00000040   0x4091             LSLS     R1,R1,R2
   \   00000042   0x6067             STR      R7,[R4, #+4]
   \   00000044   0x4638             MOV      R0,R7
   \   00000046   0x2E01             CMP      R6,#+1
   \   00000048   0xDB0A             BLT.N    ??BitStream_appendNum_5
   \                     ??BitStream_appendNum_6: (+1)
   \   0000004A   0xEA01 0x0208      AND      R2,R1,R8
   \   0000004E   0x1E52             SUBS     R2,R2,#+1
   \   00000050   0x4192             SBCS     R2,R2,R2
   \   00000052   0x43D2             MVNS     R2,R2
   \   00000054   0x0FD2             LSRS     R2,R2,#+31
   \   00000056   0x0849             LSRS     R1,R1,#+1
   \   00000058   0xF800 0x2B01      STRB     R2,[R0], #+1
   \   0000005C   0x1E76             SUBS     R6,R6,#+1
   \   0000005E   0xD1F4             BNE.N    ??BitStream_appendNum_6
    169          
    170          	ret = BitStream_append(bstream, b);
   \                     ??BitStream_appendNum_5: (+1)
   \   00000060   0x4621             MOV      R1,R4
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       BitStream_append
   \   00000068   0x4605             MOV      R5,R0
    171          	BitStream_free(b);
   \   0000006A   0x6860             LDR      R0,[R4, #+4]
   \   0000006C   0x.... 0x....      BL       free
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       free
    172          
    173          	return ret;
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??BitStream_appendNum_3: (+1)
   \   0000007C   0x.... 0x....      BL       free
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       free
   \   00000086   0xE7C8             B.N      ??BitStream_appendNum_2
    174          }
    175          

   \                                 In section .text, align 2, keep-with-next
    176          int BitStream_appendBytes(BitStream *bstream, int size, unsigned char *data)
    177          {
   \                     BitStream_appendBytes: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x4617             MOV      R7,R2
    178          	BitStream *b;
    179          	int ret;
    180          
    181          	if(size == 0) return 0;
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0x2000             MOVEQ    R0,#+0
   \   0000000E   0xD005             BEQ.N    ??BitStream_appendBytes_0
    182          
    183          	b = BitStream_newFromBytes(size, data);
   \   00000010   0x2008             MOVS     R0,#+8
   \   00000012   0x.... 0x....      BL       malloc
   \   00000016   0xB918             CBNZ.N   R0,??BitStream_appendBytes_1
    184          	if(b == NULL) return -1;
   \                     ??BitStream_appendBytes_2: (+1)
   \   00000018   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??BitStream_appendBytes_0: (+1)
   \   0000001C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??BitStream_appendBytes_1: (+1)
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6001             STR      R1,[R0, #+0]
   \   00000024   0x6041             STR      R1,[R0, #+4]
   \   00000026   0x4605             MOV      R5,R0
   \   00000028   0x00F4             LSLS     R4,R6,#+3
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       malloc
   \   00000030   0xEA5F 0x0900      MOVS     R9,R0
   \   00000034   0x6868             LDR      R0,[R5, #+4]
   \   00000036   0xD027             BEQ.N    ??BitStream_appendBytes_3
   \   00000038   0xB108             CBZ.N    R0,??BitStream_appendBytes_4
   \   0000003A   0x.... 0x....      BL       free
   \                     ??BitStream_appendBytes_4: (+1)
   \   0000003E   0x602C             STR      R4,[R5, #+0]
   \   00000040   0xF8C5 0x9004      STR      R9,[R5, #+4]
   \   00000044   0x4648             MOV      R0,R9
   \   00000046   0x2E01             CMP      R6,#+1
   \   00000048   0xDB10             BLT.N    ??BitStream_appendBytes_5
   \                     ??BitStream_appendBytes_6: (+1)
   \   0000004A   0x2180             MOVS     R1,#+128
   \   0000004C   0x2208             MOVS     R2,#+8
   \                     ??BitStream_appendBytes_7: (+1)
   \   0000004E   0x783B             LDRB     R3,[R7, #+0]
   \   00000050   0xEA01 0x0403      AND      R4,R1,R3
   \   00000054   0x1E63             SUBS     R3,R4,#+1
   \   00000056   0x419B             SBCS     R3,R3,R3
   \   00000058   0x43DB             MVNS     R3,R3
   \   0000005A   0x0FDB             LSRS     R3,R3,#+31
   \   0000005C   0x1049             ASRS     R1,R1,#+1
   \   0000005E   0xF800 0x3B01      STRB     R3,[R0], #+1
   \   00000062   0x1E52             SUBS     R2,R2,#+1
   \   00000064   0xD1F3             BNE.N    ??BitStream_appendBytes_7
   \   00000066   0x1C7F             ADDS     R7,R7,#+1
   \   00000068   0x1E76             SUBS     R6,R6,#+1
   \   0000006A   0xD1EE             BNE.N    ??BitStream_appendBytes_6
    185          
    186          	ret = BitStream_append(bstream, b);
   \                     ??BitStream_appendBytes_5: (+1)
   \   0000006C   0x4629             MOV      R1,R5
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0x.... 0x....      BL       BitStream_append
   \   00000074   0x4604             MOV      R4,R0
    187          	BitStream_free(b);
   \   00000076   0x6868             LDR      R0,[R5, #+4]
   \   00000078   0x.... 0x....      BL       free
   \   0000007C   0x4628             MOV      R0,R5
   \   0000007E   0x.... 0x....      BL       free
    188          
    189          	return ret;
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   \                     ??BitStream_appendBytes_3: (+1)
   \   00000088   0x.... 0x....      BL       free
   \   0000008C   0x4628             MOV      R0,R5
   \   0000008E   0x.... 0x....      BL       free
   \   00000092   0xE7C1             B.N      ??BitStream_appendBytes_2
    190          }
    191          

   \                                 In section .text, align 2, keep-with-next
    192          unsigned char *BitStream_toByte(BitStream *bstream)
    193          {
   \                     BitStream_toByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
    194          	int i, j, size, bytes;
    195          	unsigned char *data, v;
    196          	unsigned char *p;
    197          
    198          	size = BitStream_size(bstream);
   \   00000004   0x682C             LDR      R4,[R5, #+0]
    199          	if(size == 0) {
   \   00000006   0xB13C             CBZ.N    R4,??BitStream_toByte_0
    200          		return NULL;
    201          	}
    202          	data = (unsigned char *)malloc((size + 7) / 8);
   \   00000008   0x1DE0             ADDS     R0,R4,#+7
   \   0000000A   0x1081             ASRS     R1,R0,#+2
   \   0000000C   0xEB00 0x7051      ADD      R0,R0,R1, LSR #+29
   \   00000010   0x10C0             ASRS     R0,R0,#+3
   \   00000012   0x.... 0x....      BL       malloc
    203          	if(data == NULL) {
   \   00000016   0xB908             CBNZ.N   R0,??BitStream_toByte_1
    204          		return NULL;
   \                     ??BitStream_toByte_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBDF2             POP      {R1,R4-R7,PC}
    205          	}
    206          
    207          	bytes = size  / 8;
   \                     ??BitStream_toByte_1: (+1)
   \   0000001C   0x10A1             ASRS     R1,R4,#+2
   \   0000001E   0xEB04 0x7151      ADD      R1,R4,R1, LSR #+29
   \   00000022   0x10C9             ASRS     R1,R1,#+3
    208          
    209          	p = bstream->data;
   \   00000024   0x686A             LDR      R2,[R5, #+4]
    210          	for(i=0; i<bytes; i++) {
   \   00000026   0x2901             CMP      R1,#+1
   \   00000028   0xDB23             BLT.N    ??BitStream_toByte_2
   \   0000002A   0x4603             MOV      R3,R0
   \   0000002C   0x460D             MOV      R5,R1
    211          		v = 0;
    212          		for(j=0; j<8; j++) {
    213          			v = v << 1;
    214          			v |= *p;
   \                     ??BitStream_toByte_3: (+1)
   \   0000002E   0xF812 0x6B01      LDRB     R6,[R2], #+1
    215          			p++;
   \   00000032   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   00000036   0xEA47 0x0646      ORR      R6,R7,R6, LSL #+1
   \   0000003A   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   0000003E   0xEA47 0x0646      ORR      R6,R7,R6, LSL #+1
   \   00000042   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   00000046   0xEA47 0x0646      ORR      R6,R7,R6, LSL #+1
   \   0000004A   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   0000004E   0xEA47 0x0646      ORR      R6,R7,R6, LSL #+1
   \   00000052   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   00000056   0xEA47 0x0646      ORR      R6,R7,R6, LSL #+1
   \   0000005A   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   0000005E   0xEA47 0x0646      ORR      R6,R7,R6, LSL #+1
   \   00000062   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   00000066   0xEA47 0x0646      ORR      R6,R7,R6, LSL #+1
    216          		}
    217          		data[i] = v;
   \   0000006A   0xF803 0x6B01      STRB     R6,[R3], #+1
    218          	}
   \   0000006E   0x1E6D             SUBS     R5,R5,#+1
   \   00000070   0xD1DD             BNE.N    ??BitStream_toByte_3
    219          	if(size & 7) {
   \                     ??BitStream_toByte_2: (+1)
   \   00000072   0xF014 0x0F07      TST      R4,#0x7
   \   00000076   0xD009             BEQ.N    ??BitStream_toByte_4
    220          		v = 0;
   \   00000078   0x2600             MOVS     R6,#+0
    221          		for(j=0; j<(size & 7); j++) {
   \   0000007A   0xF004 0x0307      AND      R3,R4,#0x7
    222          			v = v << 1;
    223          			v |= *p;
   \                     ??BitStream_toByte_5: (+1)
   \   0000007E   0xF812 0x4B01      LDRB     R4,[R2], #+1
   \   00000082   0xEA44 0x0646      ORR      R6,R4,R6, LSL #+1
    224          			p++;
    225          		}
   \   00000086   0x1E5B             SUBS     R3,R3,#+1
   \   00000088   0xD1F9             BNE.N    ??BitStream_toByte_5
    226          		data[bytes] = v;
   \   0000008A   0x540E             STRB     R6,[R1, R0]
    227          	}
    228          
    229          	return data;
   \                     ??BitStream_toByte_4: (+1)
   \   0000008C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    230          }
    231          

   \                                 In section .text, align 2, keep-with-next
    232          void BitStream_free(BitStream *bstream)
    233          {
   \                     BitStream_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    234          	if(bstream != NULL) {
   \   00000004   0xD007             BEQ.N    ??BitStream_free_0
    235          		free(bstream->data);
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x.... 0x....      BL       free
    236          		free(bstream);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x.... 0x....      B.W      free
    237          	}
    238          }
   \                     ??BitStream_free_0: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   BitStream_append
        24   -> __aeabi_memcpy
        24   -> free
        24   -> malloc
      32   BitStream_appendBytes
        32   -> BitStream_append
        32   -> free
        32   -> malloc
      24   BitStream_appendNum
        24   -> BitStream_append
        24   -> free
        24   -> malloc
       8   BitStream_free
         0   -> free
         8   -> free
       8   BitStream_new
         8   -> malloc
      24   BitStream_toByte
        24   -> malloc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     108  BitStream_append
     148  BitStream_appendBytes
     136  BitStream_appendNum
      24  BitStream_free
      18  BitStream_new
     142  BitStream_toByte

 
 576 bytes in section .text
 
 576 bytes of CODE memory

Errors: none
Warnings: none
