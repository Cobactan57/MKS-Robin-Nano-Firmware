###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        13/Apr/2020  10:57:03
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\temperature.cpp
#    Command line =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\temperature.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        -lA
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/Multi_language\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/QRENCODE\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\..\Middlewares\GUI\
#        -Oh --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\temperature.lst
#    Object file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\temperature.o
#
###############################################################################

D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\temperature.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * temperature.cpp - temperature control
     25           */
     26          
     27          #include "Marlin.h"

  #define UNUSED(x) ((void)(x))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Inc\mks_cfg.h",626  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

    }
    ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
     28          #include "temperature.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute short const temptable_1[64][2]
   \                     temptable_1:
   \   00000000   0x0170 0x0122      DC16 368, 290, 400, 285, 432, 280, 448, 275, 496, 270, 528, 265, 560
   \              0x0190 0x011D
   \              0x01B0 0x0118
   \              0x01C0 0x0113
   \              0x01F0 0x010E
   \              0x0210 0x0109
   \              0x0230       
   \   0000001A   0x0104 0x0260      DC16 260, 608, 255, 656, 250, 704, 245, 768, 240, 832, 235, 896, 230
   \              0x00FF 0x0290
   \              0x00FA 0x02C0
   \              0x00F5 0x0300
   \              0x00F0 0x0340
   \              0x00EB 0x0380
   \              0x00E6       
   \   00000034   0x03D0 0x00E1      DC16 976, 225, 1056, 220, 1136, 215, 1248, 210, 1344, 205, 1472, 200
   \              0x0420 0x00DC
   \              0x0470 0x00D7
   \              0x04E0 0x00D2
   \              0x0540 0x00CD
   \              0x05C0 0x00C8
   \   0000004C   0x0640 0x00C3      DC16 1600, 195, 1744, 190, 1920, 185, 2096, 180, 2288, 175, 2496, 170
   \              0x06D0 0x00BE
   \              0x0780 0x00B9
   \              0x0830 0x00B4
   \              0x08F0 0x00AF
   \              0x09C0 0x00AA
   \   00000064   0x0AB0 0x00A5      DC16 2736, 165, 2992, 160, 3280, 155, 3584, 150, 3920, 145, 4288, 140
   \              0x0BB0 0x00A0
   \              0x0CD0 0x009B
   \              0x0E00 0x0096
   \              0x0F50 0x0091
   \              0x10C0 0x008C
   \   0000007C   0x1250 0x0087      DC16 4688, 135, 5120, 130, 5568, 125, 6064, 120, 6576, 115, 7120, 110
   \              0x1400 0x0082
   \              0x15C0 0x007D
   \              0x17B0 0x0078
   \              0x19B0 0x0073
   \              0x1BD0 0x006E
   \   00000094   0x1E00 0x0069      DC16 7680, 105, 8256, 100, 8848, 95, 9456, 90, 10048, 85, 10640, 80
   \              0x2040 0x0064
   \              0x2290 0x005F
   \              0x24F0 0x005A
   \              0x2740 0x0055
   \              0x2990 0x0050
   \   000000AC   0x2BE0 0x004B      DC16 11232, 75, 11792, 70, 12320, 65, 12816, 60, 13280, 55, 13712, 50
   \              0x2E10 0x0046
   \              0x3020 0x0041
   \              0x3210 0x003C
   \              0x33E0 0x0037
   \              0x3590 0x0032
   \   000000C4   0x3710 0x002D      DC16 14096, 45, 14448, 40, 14752, 35, 15024, 30, 15264, 25, 15456, 20
   \              0x3870 0x0028
   \              0x39A0 0x0023
   \              0x3AB0 0x001E
   \              0x3BA0 0x0019
   \              0x3C60 0x0014
   \   000000DC   0x3D10 0x000F      DC16 15632, 15, 15760, 10, 15888, 5, 15984, 0, 16064, -5, 16128, -10
   \              0x3D90 0x000A
   \              0x3E10 0x0005
   \              0x3E70 0x0000
   \              0x3EC0 0xFFFB
   \              0x3F00 0xFFF6
   \   000000F4   0x3F40 0xFFF1      DC16 16192, -15, 16256, -20, 16320, -25
   \              0x3F80 0xFFEC
   \              0x3FC0 0xFFE7

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\temperature.h",406  Warning[Pa093]: 
          implicit conversion from floating point to integer

          target_temperature_bed =
                                 ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\temperature.h",414  Warning[Pa093]: 
          implicit conversion from floating point to integer
     29          #include "thermistortables.h"
     30          #include "ultralcd.h"
     31          #include "planner.h"

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.h",627  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.h",628  Warning[Pe815]: 
          type qualifier on return type is meaningless
     32          #include "language.h"
     33          #include "adc.h"
     34          #include "tim.h"
     35          #include "spi.h"
     36          #if ENABLED(HEATER_0_USES_MAX6675)
     37            //#include "MarlinSPI.h"
     38          #endif
     39          
     40          #if ENABLED(BABYSTEPPING)
     41            #include "stepper.h"
     42          #endif
     43          
     44          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     45            #include "endstops.h"
     46          #endif
     47          
     48          #if ENABLED(USE_WATCHDOG)
     49            #include "watchdog.h"
     50          #endif
     51          
     52          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     53            static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     54            static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
     55          #else

   \                                 In section .data, align 4
     56            static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
     57            static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
   \                     heater_ttbllen_map:
   \   00000000   0x40 0x40          DC8 64, 64
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 temptable_1, temptable_1
   \              0x........   
     58          #endif
     59          
     60          extern volatile uint8_t temper_error_type;
     61          

   \                                 In section .bss, align 4
     62          Temperature thermalManager;
   \                     thermalManager:
   \   00000000                      DS8 4
     63          extern volatile uint8_t loop_start;
     64          // public:
     65          
     66          float Temperature::current_temperature[HOTENDS] = { 0.0 },
     67                Temperature::current_temperature_bed = 0.0;
     68          int Temperature::current_temperature_raw[HOTENDS] = { 0 },
     69                  Temperature::target_temperature[HOTENDS] = { 0 },
     70                  Temperature::current_temperature_bed_raw = 0;
     71          
     72          #if HAS_HEATER_BED
     73            int16_t Temperature::target_temperature_bed = 0;
     74          #endif
     75          
     76          // Initialized by settings.load()
     77          #if 1//ENABLED(PIDTEMP)
     78            #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
     79              float Temperature::Kp[HOTENDS], Temperature::Ki[HOTENDS], Temperature::Kd[HOTENDS];
     80              #if ENABLED(PID_EXTRUSION_SCALING)
     81                float Temperature::Kc[HOTENDS];
     82              #endif
     83            #else
     84              float Temperature::Kp, Temperature::Ki, Temperature::Kd;
     85              #if ENABLED(PID_EXTRUSION_SCALING)
     86                float Temperature::Kc;
     87              #endif
     88            #endif
     89          #endif
     90          
     91          // Initialized by settings.load()
     92          #if 1//ENABLED(PIDTEMPBED)

   \                                 In section .bss, align 4
     93            float Temperature::bedKp, Temperature::bedKi, Temperature::bedKd;
   \                     _ZN11Temperature5bedKiE:
   \   00000000                      DS8 4
   \                     _ZN11Temperature5bedKdE:
   \   00000004                      DS8 4
     94          #endif
     95          
     96          #if ENABLED(BABYSTEPPING)
     97            volatile int Temperature::babystepsTodo[XYZ] = { 0 };
     98          #endif
     99          
    100          #if WATCH_HOTENDS
    101            uint16_t Temperature::watch_target_temp[HOTENDS] = { 0 };
    102            millis_t Temperature::watch_heater_next_ms[HOTENDS] = { 0 };
    103          #endif
    104          
    105          #if WATCH_THE_BED
    106            uint16_t Temperature::watch_target_bed_temp = 0;
    107            millis_t Temperature::watch_bed_next_ms = 0;
    108          #endif
    109          
    110          #if ENABLED(PREVENT_COLD_EXTRUSION)
    111            bool Temperature::allow_cold_extrude = false;
    112            int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
                                                           ^
Warning[Pa093]: implicit conversion from floating point to integer
    113          #endif
    114          
    115          // private:
    116          
    117          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    118            uint16_t Temperature::redundant_temperature_raw = 0;
    119            float Temperature::redundant_temperature = 0.0;
    120          #endif
    121          
    122          volatile bool Temperature::temp_meas_ready = false;
    123          
    124          #if 1//ENABLED(PIDTEMP)
    125            float Temperature::temp_iState[HOTENDS] = { 0 },
    126                  Temperature::temp_dState[HOTENDS] = { 0 },
    127                  Temperature::pTerm[HOTENDS],
    128                  Temperature::iTerm[HOTENDS],
    129                  Temperature::dTerm[HOTENDS];
    130          
    131            #if ENABLED(PID_EXTRUSION_SCALING)
    132              float Temperature::cTerm[HOTENDS];
    133              long Temperature::last_e_position;
    134              long Temperature::lpq[LPQ_MAX_LEN];
    135              int Temperature::lpq_ptr = 0;
    136            #endif
    137          
    138            float Temperature::pid_error[HOTENDS];
    139            bool Temperature::pid_reset[HOTENDS];
    140          #endif
    141          #if 0
    142          #if ENABLED(PIDTEMPBED)
    143            float Temperature::temp_iState_bed = { 0 },
    144                  Temperature::temp_dState_bed = { 0 },
    145                  Temperature::pTerm_bed,
    146                  Temperature::iTerm_bed,
    147                  Temperature::dTerm_bed,
    148                  Temperature::pid_error_bed;
    149          #else
    150            millis_t Temperature::next_bed_check_ms;
    151          #endif
    152          #endif
    153          float Temperature::temp_iState_bed = { 0 },
   \                     _ZN11Temperature15temp_iState_bedE:
   \   00000008                      DS8 4
    154          	  Temperature::temp_dState_bed = { 0 },
   \                     _ZN11Temperature15temp_dState_bedE:
   \   0000000C                      DS8 4
    155          	  Temperature::pTerm_bed,
   \                     _ZN11Temperature9pTerm_bedE:
   \   00000010                      DS8 4
    156          	  Temperature::iTerm_bed,
   \                     _ZN11Temperature9iTerm_bedE:
   \   00000014                      DS8 4
    157          	  Temperature::dTerm_bed,
   \                     _ZN11Temperature9dTerm_bedE:
   \   00000018                      DS8 4
    158          	  Temperature::pid_error_bed;
   \                     _ZN11Temperature13pid_error_bedE:
   \   0000001C                      DS8 4

   \                                 In section .bss, align 1
   \                     _ZN11Temperature18allow_cold_extrudeE:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
   \                     _ZN11Temperature16extrude_min_tempE:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \                     _ZN11Temperature9pid_resetE:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \                     _ZN11Temperature11temp_iStateE:
   \   00000004                      DS8 8
   \                     _ZN11Temperature11temp_dStateE:
   \   0000000C                      DS8 8
   \                     _ZN11Temperature5pTermE:
   \   00000014                      DS8 8
   \                     _ZN11Temperature5iTermE:
   \   0000001C                      DS8 8
   \                     _ZN11Temperature5dTermE:
   \   00000024                      DS8 8
   \                     _ZN11Temperature9pid_errorE:
   \   0000002C                      DS8 8
    159          millis_t Temperature::next_bed_check_ms;
    160          
    161          
    162          uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 },
    163                   Temperature::raw_temp_bed_value = 0;
    164          
    165          // Init min and max temp with extreme values to prevent false errors during startup
    166          int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
    167                  Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
    168                  Temperature::minttemp[HOTENDS] = { 0 },
    169                  Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
    170          
    171          #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
    172            uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
    173          #endif
    174          
    175          #ifdef MILLISECONDS_PREHEAT_TIME
    176            millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
    177          #endif
    178          
    179          #ifdef BED_MINTEMP
    180            int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
    181          #endif
    182          
    183          #ifdef BED_MAXTEMP
    184            int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
    185          #endif
    186          
    187          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    188            int8_t Temperature::meas_shift_index;  // Index of a delayed sample in buffer
    189          #endif
    190          
    191          #if HAS_AUTO_FAN
    192            millis_t Temperature::next_auto_fan_check_ms = 0;
    193          #endif
    194          
    195          uint8_t Temperature::soft_pwm_amount[HOTENDS],
    196                  Temperature::soft_pwm_amount_bed;
    197          
    198          #if ENABLED(FAN_SOFT_PWM)
    199            uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
    200                    Temperature::soft_pwm_count_fan[FAN_COUNT];
    201          #endif
    202          
    203          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    204            uint16_t Temperature::current_raw_filwidth = 0; // Measured filament diameter - one extruder only
    205          #endif
    206          
    207          #if ENABLED(PROBING_HEATERS_OFF)
    208            bool Temperature::paused;
    209          #endif
    210          
    211          #if HEATER_IDLE_HANDLER
    212            millis_t Temperature::heater_idle_timeout_ms[HOTENDS] = { 0 };
    213            bool Temperature::heater_idle_timeout_exceeded[HOTENDS] = { false };
    214            #if 1//HAS_TEMP_BED
    215              millis_t Temperature::bed_idle_timeout_ms = 0;
    216              bool Temperature::bed_idle_timeout_exceeded = false;
    217            #endif
    218          #endif
    219          
    220          #if ENABLED(ADC_KEYPAD)
    221            uint32_t Temperature::current_ADCKey_raw = 0;
    222            uint8_t Temperature::ADCKey_count = 0;
    223          #endif
    224          
    225          #if 1//HAS_PID_HEATING
    226          
    227            /**
    228             * PID Autotuning (M303)
    229             *
    230             * Alternately heat and cool the nozzle, observing its behavior to
    231             * determine the best PID values to achieve a stable temperature.
    232             */

   \                                 In section .text, align 2, keep-with-next
    233            void Temperature::PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
   \                     _ZN11Temperature12PID_autotuneEfaab: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
    234              float input = 0.0;
   \   00000004   0xF04F 0x0900      MOV      R9,#+0
   \   00000008   0xB095             SUB      SP,SP,#+84
    235              int cycles = 0;
   \   0000000A   0x46CB             MOV      R11,R9
    236              bool heating = true;
   \   0000000C   0xF04F 0x0A01      MOV      R10,#+1
    237          
    238              millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x9007             STR      R0,[SP, #+28]
   \   00000016   0x900B             STR      R0,[SP, #+44]
    239              long t_high = 0, t_low = 0;
   \   00000018   0xF8CD 0x9024      STR      R9,[SP, #+36]
    240          
    241              long bias, d;
    242              float Ku, Tu,
    243                    workKp = 0, workKi = 0, workKd = 0,
   \   0000001C   0x46C8             MOV      R8,R9
   \   0000001E   0x9807             LDR      R0,[SP, #+28]
    244                    max = 0, min = 10000;
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable55_2
   \   00000024   0x900A             STR      R0,[SP, #+40]
   \   00000026   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   0000002A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000002E   0xF8CD 0x9018      STR      R9,[SP, #+24]
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable55_3  ;; 0x461c4000
   \   00000036   0x9005             STR      R0,[SP, #+20]
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable55_4
   \   0000003C   0x7844             LDRB     R4,[R0, #+1]
   \   0000003E   0x9003             STR      R0,[SP, #+12]
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable55
   \   00000046   0xF890 0x5036      LDRB     R5,[R0, #+54]
   \   0000004A   0xD051             BEQ.N    ??PID_autotune_0
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD041             BEQ.N    ??PID_autotune_1
    245          
    246              #if WATCH_THE_BED || WATCH_HOTENDS
    247                float watch_temp_target ;//= temp -
    248                  #if ENABLED(THERMAL_PROTECTION_BED) /*&& ENABLED(PIDTEMPBED) */&& ENABLED(THERMAL_PROTECTION_HOTENDS) /*&& ENABLED(PIDTEMP)*/
    249                      if((PIDTEMPBED)&&(PIDTEMP))
    250                          watch_temp_target = temp - (hotend < 0 ? (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1) : (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1));
   \   00000050   0xF99D 0x0058      LDRSB    R0,[SP, #+88]
   \   00000054   0x9002             STR      R0,[SP, #+8]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xBF4C             ITE      MI 
   \   0000005A   0x7AB0             LDRBMI   R0,[R6, #+10]
   \   0000005C   0x78B0             LDRBPL   R0,[R6, #+2]
   \   0000005E   0x1CC0             ADDS     R0,R0,#+3
   \   00000060   0x.... 0x....      BL       __aeabi_i2f
   \   00000064   0x4601             MOV      R1,R0
   \   00000066   0x9815             LDR      R0,[SP, #+84]
   \   00000068   0x.... 0x....      BL       __aeabi_fsub
   \   0000006C   0x9008             STR      R0,[SP, #+32]
    251                      else
    252                      {
    253                       #if ENABLED(THERMAL_PROTECTION_BED) /*&& ENABLED(PIDTEMPBED)*/
    254                          if(PIDTEMPBED)
    255                              watch_temp_target = temp - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
    256                          else
    257                              watch_temp_target = temp - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
    258                       #else
    259                          watch_temp_target = temp - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
    260                       #endif
    261                      }
    262                  #endif
    263                
    264               // int8_t watch_temp_period;// =
    265                   uint32_t watch_temp_period;
    266                  #if ENABLED(THERMAL_PROTECTION_BED)/* && ENABLED(PIDTEMPBED)*/ && ENABLED(THERMAL_PROTECTION_HOTENDS) /*&& ENABLED(PIDTEMP)*/
    267                      if((PIDTEMPBED)&&(PIDTEMP))
    268                      {
    269                          watch_temp_period = hotend < 0 ? WATCH_BED_TEMP_PERIOD : WATCH_TEMP_PERIOD;
   \   0000006E   0x9802             LDR      R0,[SP, #+8]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD54B             BPL.N    ??PID_autotune_2
   \   00000074   0xF9B6 0x0008      LDRSH    R0,[R6, #+8]
   \   00000078   0xF996 0x700A      LDRSB    R7,[R6, #+10]
   \   0000007C   0x9004             STR      R0,[SP, #+16]
   \                     ??PID_autotune_3: (+1)
   \   0000007E   0x9807             LDR      R0,[SP, #+28]
   \   00000080   0x9904             LDR      R1,[SP, #+16]
    270                      }
    271                      else
    272                      {
    273                          #if ENABLED(THERMAL_PROTECTION_BED)/* && ENABLED(PIDTEMPBED)*/
    274                              if(PIDTEMPBED)
    275                                watch_temp_period = WATCH_BED_TEMP_PERIOD;
    276                              else
    277                                watch_temp_period = WATCH_TEMP_PERIOD;  
    278                          #else
    279                              watch_temp_period = WATCH_TEMP_PERIOD;
    280                          #endif
    281                      }
    282                  #endif
    283                int8_t watch_temp_increase; //=
    284                  #if ENABLED(THERMAL_PROTECTION_BED) /*&& ENABLED(PIDTEMPBED) */&& ENABLED(THERMAL_PROTECTION_HOTENDS) /*&& ENABLED(PIDTEMP)*/
    285                      if((PIDTEMPBED)&&(PIDTEMP))
    286                      {
    287                          watch_temp_increase = hotend < 0 ? WATCH_BED_TEMP_INCREASE : WATCH_TEMP_INCREASE;
    288                      }
    289                      else
    290                      {
    291                          #if ENABLED(THERMAL_PROTECTION_BED)
    292                              if(PIDTEMPBED)
    293                                  watch_temp_increase = WATCH_BED_TEMP_INCREASE;
    294                               else
    295                                  watch_temp_increase = WATCH_TEMP_INCREASE;
    296                          #else
    297                              watch_temp_increase = WATCH_TEMP_INCREASE;
    298                          #endif
    299                      }
    300                #endif
    301                millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
    302                float next_watch_temp = 0.0;
   \   00000082   0xF8CD 0x8038      STR      R8,[SP, #+56]
   \   00000086   0xF44F 0x727A      MOV      R2,#+1000
   \   0000008A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000008E   0x900F             STR      R0,[SP, #+60]
    303                bool heated = false;
   \   00000090   0xF8CD 0x8034      STR      R8,[SP, #+52]
    304              #endif
    305          
    306              #if HAS_AUTO_FAN
    307                next_auto_fan_check_ms = next_temp_ms + 2500UL;
    308              #endif
    309          #if 0
    310              #if ENABLED(PIDTEMP)
    311                #define _TOP_HOTEND HOTENDS - 1
    312              #else
    313                #define _TOP_HOTEND -1
    314              #endif
    315              #if ENABLED(PIDTEMPBED)
    316                #define _BOT_HOTEND -1
    317              #else
    318                #define _BOT_HOTEND 0
    319              #endif
    320          
    321          
    322          
    323              if (!WITHIN(hotend, _BOT_HOTEND, _TOP_HOTEND)) {
    324                SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);
    325                return;
    326              }
    327          #endif	
    328          	if(PIDTEMP == 0 && PIDTEMPBED == 0) if(hotend >= 0 || hotend < 0) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \   00000094   0x2D00             CMP      R5,#+0
   \   00000096   0xD141             BNE.N    ??PID_autotune_4
   \   00000098   0xB174             CBZ.N    R4,??PID_autotune_5
   \   0000009A   0x2C01             CMP      R4,#+1
   \   0000009C   0xD13E             BNE.N    ??PID_autotune_4
    329          	if(PIDTEMP == 0 && PIDTEMPBED == 1) if(hotend >= 0 || hotend < -1) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \   0000009E   0xF99D 0x0058      LDRSB    R0,[SP, #+88]
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \   000000A4   0xD108             BNE.N    ??PID_autotune_5
    330          	if(PIDTEMP == 1 && PIDTEMPBED == 0) if(hotend >= HOTENDS|| hotend < 0) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
    331          	if(PIDTEMP == 1 && PIDTEMPBED == 1) if(hotend >= HOTENDS|| hotend < -1) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \                     ??PID_autotune_6: (+1)
   \   000000A6   0x2D01             CMP      R5,#+1
   \   000000A8   0xD141             BNE.N    ??PID_autotune_7
   \                     ??PID_autotune_8: (+1)
   \   000000AA   0x2C01             CMP      R4,#+1
   \   000000AC   0xD13F             BNE.N    ??PID_autotune_7
   \   000000AE   0xF99D 0x0058      LDRSB    R0,[SP, #+88]
   \   000000B2   0x1C40             ADDS     R0,R0,#+1
   \   000000B4   0x2803             CMP      R0,#+3
   \   000000B6   0xD33A             BCC.N    ??PID_autotune_7
   \                     ??PID_autotune_5: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R4,??DataTable55_5
   \   000000BC   0x.... 0x....      ADR.W    R1,`?<Constant "PID Autotune failed! ...">`
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0xB019             ADD      SP,SP,#+100
   \   000000CA   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000000CE   0x210A             MOVS     R1,#+10
   \   000000D0   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??PID_autotune_1: (+1)
   \   000000D4   0x7AB7             LDRB     R7,[R6, #+10]
   \   000000D6   0x1CF8             ADDS     R0,R7,#+3
   \   000000D8   0x.... 0x....      BL       __aeabi_i2f
   \   000000DC   0x4601             MOV      R1,R0
   \   000000DE   0x9815             LDR      R0,[SP, #+84]
   \   000000E0   0x.... 0x....      BL       __aeabi_fsub
   \   000000E4   0x9008             STR      R0,[SP, #+32]
   \   000000E6   0xF9B6 0x0008      LDRSH    R0,[R6, #+8]
   \                     ??PID_autotune_9: (+1)
   \   000000EA   0x9004             STR      R0,[SP, #+16]
   \   000000EC   0xB27F             SXTB     R7,R7
   \   000000EE   0xE7C6             B.N      ??PID_autotune_3
   \                     ??PID_autotune_0: (+1)
   \   000000F0   0x78B7             LDRB     R7,[R6, #+2]
   \   000000F2   0x1CF8             ADDS     R0,R7,#+3
   \   000000F4   0x.... 0x....      BL       __aeabi_i2f
   \   000000F8   0x4601             MOV      R1,R0
   \   000000FA   0x9815             LDR      R0,[SP, #+84]
   \   000000FC   0x.... 0x....      BL       __aeabi_fsub
   \   00000100   0x9008             STR      R0,[SP, #+32]
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable55
   \   00000106   0xF9B0 0x00E4      LDRSH    R0,[R0, #+228]
   \   0000010A   0xE7EE             B.N      ??PID_autotune_9
   \                     ??PID_autotune_2: (+1)
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable55
   \   00000110   0xF9B0 0x00E4      LDRSH    R0,[R0, #+228]
   \   00000114   0xF996 0x7002      LDRSB    R7,[R6, #+2]
   \   00000118   0x9004             STR      R0,[SP, #+16]
   \   0000011A   0xE7B0             B.N      ??PID_autotune_3
   \                     ??PID_autotune_4: (+1)
   \   0000011C   0x2D01             CMP      R5,#+1
   \   0000011E   0xD1C2             BNE.N    ??PID_autotune_6
   \   00000120   0x2C00             CMP      R4,#+0
   \   00000122   0xD1C2             BNE.N    ??PID_autotune_8
   \   00000124   0xF99D 0x0058      LDRSB    R0,[SP, #+88]
   \   00000128   0x2802             CMP      R0,#+2
   \   0000012A   0xD3BE             BCC.N    ??PID_autotune_8
   \   0000012C   0xE7C4             B.N      ??PID_autotune_5
    332          
    333              SERIAL_ECHOLN(MSG_PID_AUTOTUNE_START);
   \                     ??PID_autotune_7: (+1)
   \   0000012E   0x.... 0x....      LDR.W    R4,??DataTable55_5
   \   00000132   0x.... 0x....      ADR.W    R1,`?<Constant "PID Autotune start">`
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000013C   0x210A             MOVS     R1,#+10
   \   0000013E   0x4620             MOV      R0,R4
   \   00000140   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    334          
    335              disable_all_heaters(); // switch off all heaters.
   \   00000144   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
    336          #if 0
    337              #if HAS_PID_FOR_BOTH
    338                if (hotend < 0)
    339                  soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
    340                else
    341                  soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
    342              #elif ENABLED(PIDTEMP)
    343                soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
    344              #else
    345                soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
    346              #endif
    347          #endif
    348          	if (HAS_PID_FOR_BOTH) {
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable55
   \   0000014C   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   00000150   0xB178             CBZ.N    R0,??PID_autotune_10
   \   00000152   0xF99D 0x0058      LDRSB    R0,[SP, #+88]
   \   00000156   0x9002             STR      R0,[SP, #+8]
   \   00000158   0x9803             LDR      R0,[SP, #+12]
   \   0000015A   0x7840             LDRB     R0,[R0, #+1]
   \   0000015C   0xB110             CBZ.N    R0,??PID_autotune_11
    349                if (hotend < 0)
   \   0000015E   0x9802             LDR      R0,[SP, #+8]
   \   00000160   0x2800             CMP      R0,#+0
   \   00000162   0xD406             BMI.N    ??PID_autotune_10
    350                  soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
    351                else
    352                  soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;}
    353          	else if(PIDTEMP)	soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
   \                     ??PID_autotune_11: (+1)
   \   00000164   0x9902             LDR      R1,[SP, #+8]
   \   00000166   0x.... 0x....      LDR.W    R2,??DataTable55_6
   \   0000016A   0x257F             MOVS     R5,#+127
   \   0000016C   0x548D             STRB     R5,[R1, R2]
   \   0000016E   0x267F             MOVS     R6,#+127
   \   00000170   0xE004             B.N      ??PID_autotune_12
    354          	else soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
   \                     ??PID_autotune_10: (+1)
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable55_6
   \   00000176   0x257F             MOVS     R5,#+127
   \   00000178   0x267F             MOVS     R6,#+127
   \   0000017A   0x70CD             STRB     R5,[R1, #+3]
   \                     ??PID_autotune_12: (+1)
   \   0000017C   0x4638             MOV      R0,R7
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable55_7
   \   00000182   0xF881 0xA000      STRB     R10,[R1, #+0]
   \   00000186   0x.... 0x....      BL       __aeabi_i2f
   \   0000018A   0x9013             STR      R0,[SP, #+76]
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable55_8  ;; 0xc1a00000
   \   00000190   0xF99D 0x005C      LDRSB    R0,[SP, #+92]
   \   00000194   0x9012             STR      R0,[SP, #+72]
   \   00000196   0x9815             LDR      R0,[SP, #+84]
   \   00000198   0x.... 0x....      BL       __aeabi_fadd
   \   0000019C   0x.... 0x....      LDR.W    R1,??DataTable55_9  ;; 0x41a00000
   \   000001A0   0x9011             STR      R0,[SP, #+68]
   \   000001A2   0x9815             LDR      R0,[SP, #+84]
   \   000001A4   0x.... 0x....      BL       __aeabi_fadd
   \   000001A8   0x9010             STR      R0,[SP, #+64]
   \   000001AA   0xF99D 0x0058      LDRSB    R0,[SP, #+88]
   \   000001AE   0x9002             STR      R0,[SP, #+8]
    355          
    356              wait_for_heatup = true;
    357          
    358              // PID Tuning loop
    359              while (wait_for_heatup) {
   \                     ??PID_autotune_13: (+1)
   \   000001B0   0x.... 0x....      LDR.W    R0,??DataTable55_7
   \   000001B4   0x7800             LDRB     R0,[R0, #+0]
   \   000001B6   0x2800             CMP      R0,#+0
   \   000001B8   0xF000 0x8236      BEQ.W    ??PID_autotune_14
    360          
    361                const millis_t ms = millis();
   \   000001BC   0x.... 0x....      BL       HAL_GetTick
   \   000001C0   0x4607             MOV      R7,R0
    362          
    363                if (temp_meas_ready) { // temp sample ready
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable55_6
   \   000001C6   0x7880             LDRB     R0,[R0, #+2]
   \   000001C8   0x2800             CMP      R0,#+0
   \   000001CA   0xF000 0x8127      BEQ.W    ??PID_autotune_15
    364                  updateTemperaturesFromRawValues();
   \   000001CE   0x.... 0x....      BL       _ZN11Temperature31updateTemperaturesFromRawValuesEv
    365          #if 0
    366                  input =
    367                    #if HAS_PID_FOR_BOTH
    368                      hotend < 0 ? current_temperature_bed : current_temperature[hotend]
    369                    #elif ENABLED(PIDTEMP)
    370                      current_temperature[hotend]
    371                    #else
    372                      current_temperature_bed
    373                    #endif
    374                  ;
    375          #endif
    376          		if(HAS_PID_FOR_BOTH) 	input = hotend < 0 ? current_temperature_bed : current_temperature[hotend];
   \   000001D2   0x.... 0x....      LDR.W    R0,??DataTable55
   \   000001D6   0xF890 0x2036      LDRB     R2,[R0, #+54]
   \   000001DA   0xB15A             CBZ.N    R2,??PID_autotune_16
   \   000001DC   0x9803             LDR      R0,[SP, #+12]
   \   000001DE   0x7840             LDRB     R0,[R0, #+1]
   \   000001E0   0xB110             CBZ.N    R0,??PID_autotune_17
   \   000001E2   0x9802             LDR      R0,[SP, #+8]
   \   000001E4   0x2800             CMP      R0,#+0
   \   000001E6   0xD405             BMI.N    ??PID_autotune_16
    377          		else if(PIDTEMP) 		input = current_temperature[hotend];
   \                     ??PID_autotune_17: (+1)
   \   000001E8   0x9802             LDR      R0,[SP, #+8]
   \   000001EA   0x.... 0x....      LDR.W    R1,??DataTable55_10
   \   000001EE   0xF851 0x9020      LDR      R9,[R1, R0, LSL #+2]
   \   000001F2   0xE003             B.N      ??PID_autotune_18
    378          		else					input = current_temperature_bed;
   \                     ??PID_autotune_16: (+1)
   \   000001F4   0x.... 0x....      LDR.W    R0,??DataTable55_6
   \   000001F8   0xF8D0 0x904C      LDR      R9,[R0, #+76]
    379          
    380                  NOLESS(max, input);
   \                     ??PID_autotune_18: (+1)
   \   000001FC   0x9806             LDR      R0,[SP, #+24]
   \   000001FE   0x4649             MOV      R1,R9
   \   00000200   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000204   0xBF38             IT       CC 
   \   00000206   0xF8CD 0x9018      STRCC    R9,[SP, #+24]
    381                  NOMORE(min, input);
   \   0000020A   0x9905             LDR      R1,[SP, #+20]
   \   0000020C   0x4648             MOV      R0,R9
   \   0000020E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000212   0xBF38             IT       CC 
   \   00000214   0xF8CD 0x9014      STRCC    R9,[SP, #+20]
    382          
    383                  #if HAS_AUTO_FAN
    384                    if (ELAPSED(ms, next_auto_fan_check_ms)) {
    385                      checkExtruderAutoFans();
    386                      next_auto_fan_check_ms = ms + 2500UL;
    387                    }
    388                  #endif
    389          
    390                  if (heating && input > temp) {
   \   00000218   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000021C   0xD025             BEQ.N    ??PID_autotune_19
   \   0000021E   0x9815             LDR      R0,[SP, #+84]
   \   00000220   0x4649             MOV      R1,R9
   \   00000222   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000226   0xF080 0x80F9      BCS.W    ??PID_autotune_15
    391                    if (ELAPSED(ms, t2 + 5000UL)) {
   \   0000022A   0x980A             LDR      R0,[SP, #+40]
   \   0000022C   0x.... 0x....      LDR.W    R1,??DataTable55_11  ;; 0xffffec78
   \   00000230   0x1A38             SUBS     R0,R7,R0
   \   00000232   0x1809             ADDS     R1,R1,R0
   \   00000234   0xF100 0x80F2      BMI.W    ??PID_autotune_15
    392                      heating = false;
   \   00000238   0xF04F 0x0A00      MOV      R10,#+0
    393          			#if 0
    394                      #if HAS_PID_FOR_BOTH
    395                        if (hotend < 0)
    396                          soft_pwm_amount_bed = (bias - d) >> 1;
    397                        else
    398                          soft_pwm_amount[hotend] = (bias - d) >> 1;
    399                      #elif ENABLED(PIDTEMP)
    400                        soft_pwm_amount[hotend] = (bias - d) >> 1;
    401                      #elif ENABLED(PIDTEMPBED)
    402                        soft_pwm_amount_bed = (bias - d) >> 1;
    403                      #endif
    404          			#endif
    405          			if(HAS_PID_FOR_BOTH)	{if (hotend < 0) soft_pwm_amount_bed = (bias - d) >> 1; else soft_pwm_amount[hotend] = (bias - d) >> 1;}
   \   0000023C   0xB162             CBZ.N    R2,??PID_autotune_20
   \   0000023E   0x9903             LDR      R1,[SP, #+12]
   \   00000240   0x7849             LDRB     R1,[R1, #+1]
   \   00000242   0xB111             CBZ.N    R1,??PID_autotune_21
   \   00000244   0x9902             LDR      R1,[SP, #+8]
   \   00000246   0x2900             CMP      R1,#+0
   \   00000248   0xD406             BMI.N    ??PID_autotune_20
    406          			else if(PIDTEMP)		soft_pwm_amount[hotend] = (bias - d) >> 1;
   \                     ??PID_autotune_21: (+1)
   \   0000024A   0x9A02             LDR      R2,[SP, #+8]
   \   0000024C   0x.... 0x....      LDR.W    R3,??DataTable55_6
   \   00000250   0x1B71             SUBS     R1,R6,R5
   \   00000252   0x1049             ASRS     R1,R1,#+1
   \   00000254   0x54D1             STRB     R1,[R2, R3]
   \   00000256   0xE004             B.N      ??PID_autotune_22
    407          			else					soft_pwm_amount_bed = (bias - d) >> 1;
   \                     ??PID_autotune_20: (+1)
   \   00000258   0x1B71             SUBS     R1,R6,R5
   \   0000025A   0x.... 0x....      LDR.W    R2,??DataTable55_6
   \   0000025E   0x1049             ASRS     R1,R1,#+1
   \   00000260   0x70D1             STRB     R1,[R2, #+3]
    408          			
    409                      t1 = ms;
    410                      t_high = t1 - t2;
   \                     ??PID_autotune_22: (+1)
   \   00000262   0x9009             STR      R0,[SP, #+36]
   \   00000264   0x970B             STR      R7,[SP, #+44]
    411                      max = temp;
   \   00000266   0x9815             LDR      R0,[SP, #+84]
   \   00000268   0x9006             STR      R0,[SP, #+24]
   \                     ??PID_autotune_19: (+1)
   \   0000026A   0x4648             MOV      R0,R9
   \   0000026C   0x9915             LDR      R1,[SP, #+84]
   \   0000026E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000272   0xF080 0x80D3      BCS.W    ??PID_autotune_15
    412                    }
    413                  }
    414          
    415                  if (!heating && input < temp) {
    416                    if (ELAPSED(ms, t1 + 5000UL)) {
   \   00000276   0x980B             LDR      R0,[SP, #+44]
   \   00000278   0x.... 0x....      LDR.W    R1,??DataTable55_11  ;; 0xffffec78
   \   0000027C   0x1A38             SUBS     R0,R7,R0
   \   0000027E   0x1809             ADDS     R1,R1,R0
   \   00000280   0xF100 0x80CC      BMI.W    ??PID_autotune_15
    417                      heating = true;
   \   00000284   0xF04F 0x0A01      MOV      R10,#+1
    418                      t2 = ms;
   \   00000288   0x970A             STR      R7,[SP, #+40]
    419                      t_low = t2 - t1;
    420                      if (cycles > 0) {
   \   0000028A   0xF1BB 0x0F01      CMP      R11,#+1
   \   0000028E   0xF2C0 0x80AA      BLT.W    ??PID_autotune_23
    421          			  #if 0
    422                        long max_pow =
    423                          #if HAS_PID_FOR_BOTH
    424                            hotend < 0 ? MAX_BED_POWER : PID_MAX
    425                          #elif ENABLED(PIDTEMP)
    426                            PID_MAX
    427                          #else
    428                            MAX_BED_POWER
    429                          #endif
    430          				
    431                        ;
    432          			  #endif
    433                        long max_pow;
    434                        if(HAS_PID_FOR_BOTH)	 max_pow = hotend < 0 ? MAX_BED_POWER : PID_MAX;
    435                        else if(PIDTEMP)	 max_pow = PID_MAX;
    436                        else 			 max_pow = MAX_BED_POWER;
    437          			  
    438                        bias += (d * (t_high - t_low)) / (t_low + t_high);
   \   00000292   0x9909             LDR      R1,[SP, #+36]
   \   00000294   0x1809             ADDS     R1,R1,R0
   \   00000296   0x910C             STR      R1,[SP, #+48]
   \   00000298   0x9909             LDR      R1,[SP, #+36]
   \   0000029A   0x1A08             SUBS     R0,R1,R0
   \   0000029C   0x990C             LDR      R1,[SP, #+48]
   \   0000029E   0x4368             MULS     R0,R0,R5
   \   000002A0   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000002A4   0x1986             ADDS     R6,R0,R6
    439                        bias = constrain(bias, 20, max_pow - 20);
   \   000002A6   0x2E14             CMP      R6,#+20
   \   000002A8   0xDA77             BGE.N    ??PID_autotune_24
   \   000002AA   0x2614             MOVS     R6,#+20
   \                     ??PID_autotune_25: (+1)
   \   000002AC   0x4635             MOV      R5,R6
    440                        d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
    441          
    442                        SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
   \                     ??PID_autotune_26: (+1)
   \   000002AE   0x4631             MOV      R1,R6
   \   000002B0   0x.... 0x....      ADR.W    R0,`?<Constant " bias: ">`
   \   000002B4   0x.... 0x....      BL       _Z17serial_echopair_PPKcl
    443                        SERIAL_PROTOCOLPAIR(MSG_D, d);
   \   000002B8   0x.... 0x....      ADR.W    R0,`?<Constant " d: ">`
   \   000002BC   0x4629             MOV      R1,R5
   \   000002BE   0x.... 0x....      BL       _Z17serial_echopair_PPKcl
    444                        SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
   \   000002C2   0x9905             LDR      R1,[SP, #+20]
   \   000002C4   0x.... 0x....      ADR.W    R0,`?<Constant " min: ">`
   \   000002C8   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    445                        SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
   \   000002CC   0x9906             LDR      R1,[SP, #+24]
   \   000002CE   0x.... 0x....      ADR.W    R0,`?<Constant " max: ">`
   \   000002D2   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    446                        if (cycles > 2) {
   \   000002D6   0xF1BB 0x0F03      CMP      R11,#+3
   \   000002DA   0xF2C0 0x8084      BLT.W    ??PID_autotune_23
    447                          Ku = (4.0 * d) / (M_PI * (max - min) * 0.5);
   \   000002DE   0x4628             MOV      R0,R5
   \   000002E0   0x.... 0x....      BL       __aeabi_i2d
   \   000002E4   0x.... 0x....      LDR.W    R3,??DataTable55_12  ;; 0x40100000
   \   000002E8   0x2200             MOVS     R2,#+0
   \   000002EA   0x.... 0x....      BL       __aeabi_dmul
   \   000002EE   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000002F2   0x9806             LDR      R0,[SP, #+24]
   \   000002F4   0x9905             LDR      R1,[SP, #+20]
   \   000002F6   0x.... 0x....      BL       __aeabi_fsub
   \   000002FA   0x.... 0x....      BL       __aeabi_f2d
   \   000002FE   0x.... 0x....      LDR.W    R2,??DataTable55_13  ;; 0x54442d18
   \   00000302   0x.... 0x....      LDR.W    R3,??DataTable55_14  ;; 0x400921fb
   \   00000306   0x.... 0x....      BL       __aeabi_dmul
   \   0000030A   0x.... 0x....      LDR.W    R3,??DataTable55_15  ;; 0x3fe00000
   \   0000030E   0x2200             MOVS     R2,#+0
   \   00000310   0x.... 0x....      BL       __aeabi_dmul
   \   00000314   0x4602             MOV      R2,R0
   \   00000316   0x460B             MOV      R3,R1
   \   00000318   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   0000031C   0x.... 0x....      BL       __aeabi_ddiv
   \   00000320   0x.... 0x....      BL       __aeabi_d2f
   \   00000324   0x4680             MOV      R8,R0
    448                          Tu = ((float)(t_low + t_high) * 0.001);
   \   00000326   0x980C             LDR      R0,[SP, #+48]
   \   00000328   0x.... 0x....      BL       __aeabi_i2f
   \   0000032C   0x.... 0x....      BL       __aeabi_f2d
   \   00000330   0x.... 0x....      LDR.W    R2,??DataTable55_16  ;; 0xd2f1a9fc
   \   00000334   0x.... 0x....      LDR.W    R3,??DataTable55_17  ;; 0x3f50624d
   \   00000338   0x.... 0x....      BL       __aeabi_dmul
   \   0000033C   0x.... 0x....      BL       __aeabi_d2f
   \   00000340   0x9005             STR      R0,[SP, #+20]
    449                          SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
   \   00000342   0x4641             MOV      R1,R8
   \   00000344   0x.... 0x....      ADR.W    R0,`?<Constant " Ku: ">`
   \   00000348   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    450                          SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
   \   0000034C   0x9905             LDR      R1,[SP, #+20]
   \   0000034E   0x.... 0x....      ADR.W    R0,`?<Constant " Tu: ">`
   \   00000352   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    451                          workKp = 0.6 * Ku;
   \   00000356   0x4640             MOV      R0,R8
   \   00000358   0x.... 0x....      BL       __aeabi_f2d
   \   0000035C   0x.... 0x....      LDR.W    R3,??DataTable55_18  ;; 0x3fe33333
   \   00000360   0xF04F 0x3233      MOV      R2,#+858993459
   \   00000364   0x.... 0x....      BL       __aeabi_dmul
   \   00000368   0x.... 0x....      BL       __aeabi_d2f
   \   0000036C   0x4680             MOV      R8,R0
    452                          workKi = 2 * workKp / Tu;
   \   0000036E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000372   0x4641             MOV      R1,R8
   \   00000374   0x.... 0x....      BL       __aeabi_fmul
   \   00000378   0x9905             LDR      R1,[SP, #+20]
   \   0000037A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000037E   0x9001             STR      R0,[SP, #+4]
    453                          workKd = workKp * Tu * 0.125;
   \   00000380   0x4641             MOV      R1,R8
   \   00000382   0x9805             LDR      R0,[SP, #+20]
   \   00000384   0x.... 0x....      BL       __aeabi_fmul
   \   00000388   0xF04F 0x5178      MOV      R1,#+1040187392
   \   0000038C   0x.... 0x....      BL       __aeabi_fmul
   \   00000390   0x9000             STR      R0,[SP, #+0]
    454                          SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
   \   00000392   0x.... 0x....      ADR.W    R0,`?<Constant "\\n Classic PID \\n">`
   \   00000396   0x9005             STR      R0,[SP, #+20]
   \   00000398   0xE00B             B.N      ??PID_autotune_27
   \                     ??PID_autotune_24: (+1)
   \   0000039A   0x2EEC             CMP      R6,#+236
   \   0000039C   0xBFAC             ITE      GE 
   \   0000039E   0x26EB             MOVGE    R6,#+235
   \   000003A0   0x2E80             CMPLT    R6,#+128
   \   000003A2   0xDB83             BLT.N    ??PID_autotune_25
   \   000003A4   0xF1C6 0x05FE      RSB      R5,R6,#+254
   \   000003A8   0xE781             B.N      ??PID_autotune_26
   \                     ??PID_autotune_28: (+1)
   \   000003AA   0xB2C9             UXTB     R1,R1
   \   000003AC   0x4620             MOV      R0,R4
   \   000003AE   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??PID_autotune_27: (+1)
   \   000003B2   0x9805             LDR      R0,[SP, #+20]
   \   000003B4   0x1C40             ADDS     R0,R0,#+1
   \   000003B6   0x9005             STR      R0,[SP, #+20]
   \   000003B8   0xF910 0x1D01      LDRSB    R1,[R0, #-1]!
   \   000003BC   0x0008             MOVS     R0,R1
   \   000003BE   0xD1F4             BNE.N    ??PID_autotune_28
    455                          SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
   \   000003C0   0x4641             MOV      R1,R8
   \   000003C2   0x.... 0x....      ADR.W    R0,`?<Constant " Kp: ">`
   \   000003C6   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    456                          SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
   \   000003CA   0x9901             LDR      R1,[SP, #+4]
   \   000003CC   0x.... 0x....      ADR.W    R0,`?<Constant " Ki: ">`
   \   000003D0   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    457                          SERIAL_PROTOCOLLNPAIR(MSG_KD, workKd);
   \   000003D4   0x9900             LDR      R1,[SP, #+0]
   \   000003D6   0x.... 0x....      ADR.W    R0,`?<Constant " Kd: ">`
   \   000003DA   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000003DE   0x210A             MOVS     R1,#+10
   \   000003E0   0x4620             MOV      R0,R4
   \   000003E2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    458                          /**
    459                          workKp = 0.33*Ku;
    460                          workKi = workKp/Tu;
    461                          workKd = workKp*Tu/3;
    462                          SERIAL_PROTOCOLLNPGM(" Some overshoot");
    463                          SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
    464                          SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
    465                          SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
    466                          workKp = 0.2*Ku;
    467                          workKi = 2*workKp/Tu;
    468                          workKd = workKp*Tu/3;
    469                          SERIAL_PROTOCOLLNPGM(" No overshoot");
    470                          SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
    471                          SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
    472                          SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
    473                          */
    474                        }
    475                      }
    476          			/*
    477                      #if HAS_PID_FOR_BOTH
    478                        if (hotend < 0)
    479                          soft_pwm_amount_bed = (bias + d) >> 1;
    480                        else
    481                          soft_pwm_amount[hotend] = (bias + d) >> 1;
    482                      #elif ENABLED(PIDTEMP)
    483                        soft_pwm_amount[hotend] = (bias + d) >> 1;
    484                      #else
    485                        soft_pwm_amount_bed = (bias + d) >> 1;
    486                      #endif
    487                      */
    488          		if(HAS_PID_FOR_BOTH)	{if (hotend < 0) soft_pwm_amount_bed = (bias + d) >> 1; else soft_pwm_amount[hotend] = (bias + d) >> 1;}
   \                     ??PID_autotune_23: (+1)
   \   000003E6   0x.... 0x....      LDR.W    R0,??DataTable55
   \   000003EA   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   000003EE   0xB160             CBZ.N    R0,??PID_autotune_29
   \   000003F0   0x9803             LDR      R0,[SP, #+12]
   \   000003F2   0x7840             LDRB     R0,[R0, #+1]
   \   000003F4   0xB110             CBZ.N    R0,??PID_autotune_30
   \   000003F6   0x9802             LDR      R0,[SP, #+8]
   \   000003F8   0x2800             CMP      R0,#+0
   \   000003FA   0xD406             BMI.N    ??PID_autotune_29
    489          		else if(PIDTEMP)		soft_pwm_amount[hotend] = (bias + d) >> 1;
   \                     ??PID_autotune_30: (+1)
   \   000003FC   0x9902             LDR      R1,[SP, #+8]
   \   000003FE   0x.... 0x....      LDR.W    R2,??DataTable55_6
   \   00000402   0x19A8             ADDS     R0,R5,R6
   \   00000404   0x1040             ASRS     R0,R0,#+1
   \   00000406   0x5488             STRB     R0,[R1, R2]
   \   00000408   0xE004             B.N      ??PID_autotune_31
    490          		else					soft_pwm_amount_bed = (bias + d) >> 1;            
   \                     ??PID_autotune_29: (+1)
   \   0000040A   0x19A8             ADDS     R0,R5,R6
   \   0000040C   0x.... 0x....      LDR.W    R1,??DataTable55_6
   \   00000410   0x1040             ASRS     R0,R0,#+1
   \   00000412   0x70C8             STRB     R0,[R1, #+3]
    491                      cycles++;
   \                     ??PID_autotune_31: (+1)
   \   00000414   0xF10B 0x0B01      ADD      R11,R11,#+1
    492                      min = temp;
   \   00000418   0x9815             LDR      R0,[SP, #+84]
   \   0000041A   0x9005             STR      R0,[SP, #+20]
    493                    }
    494                  }
    495                }
    496                #define MAX_OVERSHOOT_PID_AUTOTUNE 20
    497                if (input > temp + MAX_OVERSHOOT_PID_AUTOTUNE) {
   \                     ??PID_autotune_15: (+1)
   \   0000041C   0x4649             MOV      R1,R9
   \   0000041E   0x9810             LDR      R0,[SP, #+64]
   \   00000420   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000424   0xD20B             BCS.N    ??PID_autotune_32
    498                  SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
   \   00000426   0x.... 0x....      ADR.W    R5,`?<Constant "PID Autotune failed! ...">_1`
   \                     ??PID_autotune_33: (+1)
   \   0000042A   0xF915 0x1B01      LDRSB    R1,[R5], #+1
   \   0000042E   0x0008             MOVS     R0,R1
   \   00000430   0xF000 0x80FA      BEQ.W    ??PID_autotune_14
   \   00000434   0xB2C9             UXTB     R1,R1
   \   00000436   0x4620             MOV      R0,R4
   \   00000438   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000043C   0xE7F5             B.N      ??PID_autotune_33
    499                  break;
    500                }
    501                // Every 2 seconds...
    502                if (ELAPSED(ms, next_temp_ms)) {
   \                     ??PID_autotune_32: (+1)
   \   0000043E   0x9807             LDR      R0,[SP, #+28]
   \   00000440   0x1A38             SUBS     R0,R7,R0
   \   00000442   0xD434             BMI.N    ??PID_autotune_34
    503                  #if HAS_TEMP_HOTEND //|| HAS_TEMP_BED
    504                    print_heaterstates();
   \   00000444   0x.... 0x....      BL       _ZN11Temperature18print_heaterstatesEv
    505                    SERIAL_EOL();
   \   00000448   0x210A             MOVS     R1,#+10
   \   0000044A   0x4620             MOV      R0,R4
   \   0000044C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    506                  #endif
    507          
    508                  next_temp_ms = ms + 2000UL;
   \   00000450   0xF507 0x60FA      ADD      R0,R7,#+2000
   \   00000454   0x9007             STR      R0,[SP, #+28]
    509          
    510                  #if WATCH_THE_BED || WATCH_HOTENDS
    511                    if (!heated && input > next_watch_temp) {
   \   00000456   0x980D             LDR      R0,[SP, #+52]
   \   00000458   0xB9E0             CBNZ.N   R0,??PID_autotune_35
   \   0000045A   0x980E             LDR      R0,[SP, #+56]
   \   0000045C   0x4649             MOV      R1,R9
   \   0000045E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000462   0xD210             BCS.N    ??PID_autotune_36
    512                      if (input > watch_temp_target) heated = true;
   \   00000464   0x9808             LDR      R0,[SP, #+32]
   \   00000466   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000046A   0xBF3C             ITT      CC 
   \   0000046C   0x2001             MOVCC    R0,#+1
   \   0000046E   0x900D             STRCC    R0,[SP, #+52]
    513                      next_watch_temp = input + watch_temp_increase;
   \   00000470   0x9813             LDR      R0,[SP, #+76]
   \   00000472   0x.... 0x....      BL       __aeabi_fadd
   \   00000476   0x900E             STR      R0,[SP, #+56]
    514                      temp_change_ms = ms + watch_temp_period * 1000UL;
   \   00000478   0xF44F 0x717A      MOV      R1,#+1000
   \   0000047C   0x9804             LDR      R0,[SP, #+16]
   \   0000047E   0xFB01 0x7000      MLA      R0,R1,R0,R7
   \   00000482   0x900F             STR      R0,[SP, #+60]
   \   00000484   0xE013             B.N      ??PID_autotune_34
    515                    }
   \                     ??PID_autotune_36: (+1)
   \   00000486   0x980F             LDR      R0,[SP, #+60]
   \   00000488   0x1A38             SUBS     R0,R7,R0
   \   0000048A   0xD410             BMI.N    ??PID_autotune_34
    516                    else if (!heated && ELAPSED(ms, temp_change_ms))
    517                      _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
   \   0000048C   0x.... 0x....      ADR.W    R2,`?<Constant "Heating failed">`
   \   00000490   0x4611             MOV      R1,R2
   \   00000492   0xE008             B.N      ??PID_autotune_37
   \                     ??PID_autotune_35: (+1)
   \   00000494   0x9911             LDR      R1,[SP, #+68]
   \   00000496   0x4648             MOV      R0,R9
   \   00000498   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000049C   0xD207             BCS.N    ??PID_autotune_34
    518                    else if (heated && input < temp - MAX_OVERSHOOT_PID_AUTOTUNE)
    519                      _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
   \   0000049E   0x.... 0x....      LDR.W    R2,??DataTable56
   \   000004A2   0x.... 0x....      LDR.W    R1,??DataTable56_1
   \                     ??PID_autotune_37: (+1)
   \   000004A6   0xF99D 0x0058      LDRSB    R0,[SP, #+88]
   \   000004AA   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
    520                  #endif
    521                } // every 2 seconds
    522                // Timeout after 20 minutes since the last undershoot/overshoot cycle
    523                if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
   \                     ??PID_autotune_34: (+1)
   \   000004AE   0x980B             LDR      R0,[SP, #+44]
   \   000004B0   0x990A             LDR      R1,[SP, #+40]
   \   000004B2   0xEBC0 0x0047      RSB      R0,R0,R7, LSL #+1
   \   000004B6   0x1A40             SUBS     R0,R0,R1
   \   000004B8   0x.... 0x....      LDR.W    R1,??DataTable56_2  ;; 0x124f81
   \   000004BC   0x4288             CMP      R0,R1
   \   000004BE   0xD30B             BCC.N    ??PID_autotune_38
    524                  SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
   \   000004C0   0x.... 0x....      ADR.W    R5,`?<Constant "PID Autotune failed! ...">_2`
   \                     ??PID_autotune_39: (+1)
   \   000004C4   0xF915 0x1B01      LDRSB    R1,[R5], #+1
   \   000004C8   0x0008             MOVS     R0,R1
   \   000004CA   0xF000 0x80AD      BEQ.W    ??PID_autotune_14
   \   000004CE   0xB2C9             UXTB     R1,R1
   \   000004D0   0x4620             MOV      R0,R4
   \   000004D2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000004D6   0xE7F5             B.N      ??PID_autotune_39
    525                  break;
    526                }
    527                if (cycles > ncycles) {
   \                     ??PID_autotune_38: (+1)
   \   000004D8   0x9812             LDR      R0,[SP, #+72]
   \   000004DA   0x4558             CMP      R0,R11
   \   000004DC   0xF6BF 0xAE68      BGE.W    ??PID_autotune_13
    528                  SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
   \   000004E0   0x.... 0x....      ADR.W    R5,`?<Constant "PID Autotune finished...">`
   \   000004E4   0xE003             B.N      ??PID_autotune_40
   \                     ??PID_autotune_41: (+1)
   \   000004E6   0xB2C9             UXTB     R1,R1
   \   000004E8   0x4620             MOV      R0,R4
   \   000004EA   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??PID_autotune_40: (+1)
   \   000004EE   0xF915 0x1B01      LDRSB    R1,[R5], #+1
   \   000004F2   0x0008             MOVS     R0,R1
   \   000004F4   0xD1F7             BNE.N    ??PID_autotune_41
    529          /*
    530                  #if HAS_PID_FOR_BOTH
    531                    const char* estring = hotend < 0 ? "bed" : "";
    532                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
    533                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
    534                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
    535                  #elif ENABLED(PIDTEMP)
    536                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL();
    537                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Ki ", workKi); SERIAL_EOL();
    538                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kd ", workKd); SERIAL_EOL();
    539                  #else
    540                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL();
    541                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL();
    542                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL();
    543                  #endif
    544          */
    545          		if(HAS_PID_FOR_BOTH)
   \   000004F6   0x.... 0x....      LDR.W    R0,??DataTable55
   \   000004FA   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   000004FE   0x2800             CMP      R0,#+0
   \   00000500   0xD03F             BEQ.N    ??PID_autotune_42
   \   00000502   0x9803             LDR      R0,[SP, #+12]
   \   00000504   0x7840             LDRB     R0,[R0, #+1]
   \   00000506   0xB330             CBZ.N    R0,??PID_autotune_43
    546          		{
    547          			const char* estring = hotend < 0 ? "bed" : "";
   \   00000508   0xF99D 0x0058      LDRSB    R0,[SP, #+88]
   \   0000050C   0x2800             CMP      R0,#+0
   \   0000050E   0xBF4C             ITE      MI 
   \   00000510   0x....             ADRMI.N  R5,??DataTable51  ;; "bed"
   \   00000512   0x....             ADRPL.N  R5,??DataTable51_1  ;; ""
    548          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
   \   00000514   0x.... 0x....      ADR.W    R6,`?<Constant "#define  DEFAULT_">`
   \   00000518   0x4629             MOV      R1,R5
   \   0000051A   0x4630             MOV      R0,R6
   \   0000051C   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   00000520   0x4641             MOV      R1,R8
   \   00000522   0x....             ADR.N    R0,??DataTable51_2  ;; "Kp "
   \   00000524   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000528   0x210A             MOVS     R1,#+10
   \   0000052A   0x4620             MOV      R0,R4
   \   0000052C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    549          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
   \   00000530   0x4629             MOV      R1,R5
   \   00000532   0x4630             MOV      R0,R6
   \   00000534   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   00000538   0x9901             LDR      R1,[SP, #+4]
   \   0000053A   0x....             ADR.N    R0,??DataTable51_3  ;; "Ki "
   \   0000053C   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000540   0x210A             MOVS     R1,#+10
   \   00000542   0x4620             MOV      R0,R4
   \   00000544   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    550          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
   \   00000548   0x4629             MOV      R1,R5
   \   0000054A   0x4630             MOV      R0,R6
   \   0000054C   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   00000550   0x9900             LDR      R1,[SP, #+0]
   \   00000552   0x....             ADR.N    R0,??DataTable51_4  ;; "Kd "
   \   00000554   0xE02A             B.N      ??PID_autotune_44
    551          		}
    552          		else if(PIDTEMP)
    553          		{
    554          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL();
   \                     ??PID_autotune_43: (+1)
   \   00000556   0x4641             MOV      R1,R8
   \   00000558   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Kp ">`
   \   0000055C   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000560   0x210A             MOVS     R1,#+10
   \   00000562   0x4620             MOV      R0,R4
   \   00000564   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    555          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_Ki ", workKi); SERIAL_EOL();
   \   00000568   0x9901             LDR      R1,[SP, #+4]
   \   0000056A   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Ki ">`
   \   0000056E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000572   0x210A             MOVS     R1,#+10
   \   00000574   0x4620             MOV      R0,R4
   \   00000576   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    556          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kd ", workKd); SERIAL_EOL();
   \   0000057A   0x9900             LDR      R1,[SP, #+0]
   \   0000057C   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Kd ">`
   \   00000580   0xE014             B.N      ??PID_autotune_44
    557          		}
    558          		else
    559          		{
    560          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL();
   \                     ??PID_autotune_42: (+1)
   \   00000582   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_bedKp ">`
   \   00000586   0x4641             MOV      R1,R8
   \   00000588   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000058C   0x210A             MOVS     R1,#+10
   \   0000058E   0x4620             MOV      R0,R4
   \   00000590   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    561          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL();
   \   00000594   0x9901             LDR      R1,[SP, #+4]
   \   00000596   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_bedKi ">`
   \   0000059A   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000059E   0x210A             MOVS     R1,#+10
   \   000005A0   0x4620             MOV      R0,R4
   \   000005A2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    562          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL();
   \   000005A6   0x9900             LDR      R1,[SP, #+0]
   \   000005A8   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_bedKd ">`
   \                     ??PID_autotune_44: (+1)
   \   000005AC   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000005B0   0x210A             MOVS     R1,#+10
   \   000005B2   0x4620             MOV      R0,R4
   \   000005B4   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    563          		}
    564          
    565                  #define _SET_BED_PID() do { \
    566                    bedKp = workKp; \
    567                    bedKi = scalePID_i(workKi); \
    568                    bedKd = scalePID_d(workKd); \
    569                    }while(0)
    570          
    571                  #define _SET_EXTRUDER_PID() do { \
    572                    PID_PARAM(Kp, hotend) = workKp; \
    573                    PID_PARAM(Ki, hotend) = scalePID_i(workKi); \
    574                    PID_PARAM(Kd, hotend) = scalePID_d(workKd); \
    575                    updatePID(); }while(0)
    576          
    577                  // Use the result? (As with "M303 U1")
    578                  if (set_result) {
   \   000005B8   0xF89D 0x0060      LDRB     R0,[SP, #+96]
   \   000005BC   0x2800             CMP      R0,#+0
   \   000005BE   0xBF1E             ITTT     NE 
    579          			/*
    580                    #if HAS_PID_FOR_BOTH
    581                      if (hotend < 0)
    582                        _SET_BED_PID();
    583                      else
    584                        _SET_EXTRUDER_PID();
    585                    #elif ENABLED(PIDTEMP)
    586                      _SET_EXTRUDER_PID();
    587                    #else
    588                      _SET_BED_PID();
    589                    #endif
    590                    */
    591          			if(HAS_PID_FOR_BOTH)	if (set_result) {if (hotend < 0) _SET_BED_PID(); else _SET_EXTRUDER_PID();}
   \   000005C0   0x.... 0x....      LDRNE.W  R0,??DataTable55
   \   000005C4   0xF890 0x0036      LDRBNE   R0,[R0, #+54]
   \   000005C8   0x2800             CMPNE    R0,#+0
   \   000005CA   0xD032             BEQ.N    ??PID_autotune_45
   \   000005CC   0x9803             LDR      R0,[SP, #+12]
   \   000005CE   0x7840             LDRB     R0,[R0, #+1]
   \   000005D0   0xB378             CBZ.N    R0,??PID_autotune_45
   \   000005D2   0x9800             LDR      R0,[SP, #+0]
   \   000005D4   0x.... 0x....      BL       __aeabi_f2d
   \   000005D8   0x.... 0x....      LDR.W    R2,??DataTable57  ;; 0x88e368f1
   \   000005DC   0x.... 0x....      LDR.W    R3,??DataTable57_1  ;; 0x3fc4f8b5
   \   000005E0   0x.... 0x....      BL       __aeabi_ddiv
   \   000005E4   0x.... 0x....      BL       __aeabi_d2f
   \   000005E8   0x4604             MOV      R4,R0
   \   000005EA   0x9801             LDR      R0,[SP, #+4]
   \   000005EC   0x.... 0x....      BL       __aeabi_f2d
   \   000005F0   0x.... 0x....      LDR.W    R2,??DataTable57  ;; 0x88e368f1
   \   000005F4   0x.... 0x....      LDR.W    R3,??DataTable57_1  ;; 0x3fc4f8b5
   \   000005F8   0x.... 0x....      BL       __aeabi_dmul
   \   000005FC   0x.... 0x....      BL       __aeabi_d2f
   \   00000600   0xF99D 0x1058      LDRSB    R1,[SP, #+88]
   \   00000604   0x2900             CMP      R1,#+0
   \   00000606   0x.... 0x....      LDR.W    R1,??DataTable55_6
   \   0000060A   0xD508             BPL.N    ??PID_autotune_46
   \   0000060C   0xF8C1 0x8060      STR      R8,[R1, #+96]
    592          			else if(PIDTEMP)		if (set_result)  _SET_EXTRUDER_PID();
    593          			else 					if (set_result)  _SET_BED_PID();          
    594                  }
    595                  return;
    596                }
    597                lcd_update();
    598              }
    599              disable_all_heaters();
    600            }
   \   00000610   0xB019             ADD      SP,SP,#+100
   \   00000612   0x.... 0x....      LDR.W    R1,??DataTable58
   \   00000616   0x6008             STR      R0,[R1, #+0]
   \   00000618   0x604C             STR      R4,[R1, #+4]
   \   0000061A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??PID_autotune_46: (+1)
   \   0000061E   0xF8C1 0x8054      STR      R8,[R1, #+84]
   \   00000622   0x6588             STR      R0,[R1, #+88]
   \   00000624   0x65CC             STR      R4,[R1, #+92]
   \   00000626   0x....             B.N      ?Subroutine0
   \                     ??PID_autotune_14: (+1)
   \   00000628   0xB019             ADD      SP,SP,#+100
   \   0000062A   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   0000062E   0x.... 0x....      B.W      _ZN11Temperature19disable_all_heatersEv
   \                     ??PID_autotune_45: (+1)
   \   00000632                      REQUIRE ?Subroutine0
   \   00000632                      ;; // Fall through to label ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xB019             ADD      SP,SP,#+100
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    601          
    602          #endif // HAS_PID_HEATING
    603          
    604          /**
    605           * Class and Instance Methods
    606           */
    607          

   \                                 In section .text, align 2, keep-with-next
    608          Temperature::Temperature() { }
   \                     _ZN11TemperatureC1Ev: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    609          

   \                                 In section .text, align 2, keep-with-next
    610          int Temperature::getHeaterPower(int heater) {
    611            return heater < 0 ? soft_pwm_amount_bed : soft_pwm_amount[heater];
   \                     _ZN11Temperature14getHeaterPowerEi: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable55_6
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD501             BPL.N    ??getHeaterPower_0
   \   00000008   0x78C8             LDRB     R0,[R1, #+3]
   \   0000000A   0x4770             BX       LR
   \                     ??getHeaterPower_0: (+1)
   \   0000000C   0x5C40             LDRB     R0,[R0, R1]
   \   0000000E   0x4770             BX       LR               ;; return
    612          }
    613          
    614          #if HAS_AUTO_FAN
    615          
    616            void Temperature::checkExtruderAutoFans() {
    617              static const int8_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
    618              static const uint8_t fanBit[] PROGMEM = {
    619                              0,
    620                AUTO_1_IS_0 ? 0 :               1,
    621                AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
    622                AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
    623                AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4
    624              };
    625              uint8_t fanState = 0;
    626          
    627              HOTEND_LOOP()
    628                if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
    629                  SBI(fanState, pgm_read_byte(&fanBit[e]));
    630          
    631              uint8_t fanDone = 0;
    632              for (uint8_t f = 0; f < COUNT(fanPin); f++) {
    633                int8_t pin = pgm_read_byte(&fanPin[f]);
    634                const uint8_t bit = pgm_read_byte(&fanBit[f]);
    635                if (pin >= 0 && !TEST(fanDone, bit)) {
    636                  uint8_t newFanSpeed = TEST(fanState, bit) ? EXTRUDER_AUTO_FAN_SPEED : 0;
    637                  // this idiom allows both digital and PWM fan outputs (see M42 handling).
    638                  digitalWrite(pin, newFanSpeed);
    639                  analogWrite(pin, newFanSpeed);
    640                  SBI(fanDone, bit);
    641                }
    642              }
    643            }
    644          
    645          #endif // HAS_AUTO_FAN
    646          
    647          #if 1
    648          extern void temper_error_kill();
    649          #endif//
    650          //
    651          // Temperature Error Handlers
    652          //

   \                                 In section .text, align 2, keep-with-next
    653          void Temperature::_temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg) {
   \                     _ZN11Temperature11_temp_errorEaPKcS1_: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    654            static bool killed = false;
    655            if (IsRunning()) {
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable61
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0x460F             MOV      R7,R1
   \   0000000E   0xB3B0             CBZ.N    R0,??_temp_error_0
    656              SERIAL_ERROR_START();
   \   00000010   0x.... 0x....      LDR.W    R8,??DataTable61_1
   \   00000014   0x....             LDR.N    R6,??DataTable55_5
   \   00000016   0xE003             B.N      ??_temp_error_1
   \                     ??_temp_error_2: (+1)
   \   00000018   0xB2C9             UXTB     R1,R1
   \   0000001A   0x4630             MOV      R0,R6
   \   0000001C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??_temp_error_1: (+1)
   \   00000020   0xF918 0x1B01      LDRSB    R1,[R8], #+1
   \   00000024   0x0008             MOVS     R0,R1
   \   00000026   0xD1F7             BNE.N    ??_temp_error_2
    657              serialprintPGM(serial_msg);
   \   00000028   0xE003             B.N      ??_temp_error_3
   \                     ??_temp_error_4: (+1)
   \   0000002A   0xB2C9             UXTB     R1,R1
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??_temp_error_3: (+1)
   \   00000032   0xF917 0x1B01      LDRSB    R1,[R7], #+1
   \   00000036   0x0008             MOVS     R0,R1
   \   00000038   0xD1F7             BNE.N    ??_temp_error_4
    658              SERIAL_ERRORPGM(MSG_STOPPED_HEATER);
   \   0000003A   0x.... 0x....      LDR.W    R7,??DataTable61_2
   \   0000003E   0xE003             B.N      ??_temp_error_5
   \                     ??_temp_error_6: (+1)
   \   00000040   0xB2C9             UXTB     R1,R1
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??_temp_error_5: (+1)
   \   00000048   0xF917 0x1B01      LDRSB    R1,[R7], #+1
   \   0000004C   0x0008             MOVS     R0,R1
   \   0000004E   0xD1F7             BNE.N    ??_temp_error_6
    659              if (e >= 0) {SERIAL_ERRORLN((int)e);} else {SERIAL_ERRORLNPGM(MSG_HEATER_BED);}
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD409             BMI.N    ??_temp_error_7
   \   00000054   0x220A             MOVS     R2,#+10
   \   00000056   0x4621             MOV      R1,R4
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x.... 0x....      BL       _ZN5Print5printEii
   \   0000005E   0x210A             MOVS     R1,#+10
   \   00000060   0x4630             MOV      R0,R6
   \   00000062   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000066   0xE00A             B.N      ??_temp_error_0
   \                     ??_temp_error_7: (+1)
   \   00000068   0x.... 0x....      LDR.W    R4,??DataTable61_3
   \   0000006C   0xE003             B.N      ??_temp_error_8
   \                     ??_temp_error_9: (+1)
   \   0000006E   0xB2C9             UXTB     R1,R1
   \   00000070   0x4630             MOV      R0,R6
   \   00000072   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??_temp_error_8: (+1)
   \   00000076   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   0000007A   0x0008             MOVS     R0,R1
   \   0000007C   0xD1F7             BNE.N    ??_temp_error_9
    660            }
    661            #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
    662              if (!killed) {
   \                     ??_temp_error_0: (+1)
   \   0000007E   0x....             LDR.N    R0,??DataTable55_6
   \   00000080   0x7901             LDRB     R1,[R0, #+4]
   \   00000082   0x2900             CMP      R1,#+0
   \   00000084   0xBF1C             ITT      NE 
    663                Running = false;
    664                killed = true;
    665                //kill(lcd_msg);
    666                #if 1
    667                temper_error_kill();
    668                #endif
    669              }
    670              else
    671                disable_all_heaters(); // paranoia
   \   00000086   0xE8BD 0x41F0      POPNE    {R4-R8,LR}
   \   0000008A   0x.... 0x....      BNE.W    _ZN11Temperature19disable_all_heatersEv
   \   0000008E   0x7029             STRB     R1,[R5, #+0]
   \   00000090   0x2101             MOVS     R1,#+1
   \   00000092   0x7101             STRB     R1,[R0, #+4]
   \   00000094   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000098   0x.... 0x....      B.W      _Z17temper_error_killv
    672            #endif
    673          }
    674          

   \                                 In section .text, align 2, keep-with-next
    675          void Temperature::max_temp_error(const int8_t e) {
   \                     _ZN11Temperature14max_temp_errorEa: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    676            //#if HAS_TEMP_BED
    677            if(HAS_TEMP_BED)
   \   00000002   0x....             LDR.N    R1,??DataTable55
   \   00000004   0xF891 0x1038      LDRB     R1,[R1, #+56]
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0xB131             CBZ.N    R1,??max_temp_error_0
    678            {
    679              _temp_error(e, PSTR(MSG_T_MAXTEMP), e >= 0 ? PSTR(MSG_ERR_MAXTEMP) : PSTR(MSG_ERR_MAXTEMP_BED));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xBF4C             ITE      MI 
   \   00000010   0x.... 0x....      ADRMI.W  R2,`?<Constant "Err: MAXTEMP BED">`
   \   00000014   0x.... 0x....      LDRPL.W  R2,??DataTable62
   \   00000018   0xE001             B.N      ??max_temp_error_1
    680              //temper_error_type=1;
    681            }
    682            //#else
    683            else
    684            {
    685              _temp_error(HOTEND_INDEX, PSTR(MSG_T_MAXTEMP), PSTR(MSG_ERR_MAXTEMP));
   \                     ??max_temp_error_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable62
   \                     ??max_temp_error_1: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable62_1
   \   00000022   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
    686              #if HOTENDS == 1
    687                UNUSED(e);
    688              #endif
    689              //temper_error_type=2;
    690             }
    691             if(e>=0)temper_error_type=2;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable63
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xBF54             ITE      PL 
   \   0000002E   0x2102             MOVPL    R1,#+2
    692             else temper_error_type=1;
   \   00000030   0x2101             MOVMI    R1,#+1
   \   00000032   0x7001             STRB     R1,[R0, #+0]
    693            //#endif
    694          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    695          void Temperature::min_temp_error(const int8_t e) {
   \                     _ZN11Temperature14min_temp_errorEa: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    696            //#if HAS_TEMP_BED
    697            if(HAS_TEMP_BED)
   \   00000002   0x....             LDR.N    R1,??DataTable55
   \   00000004   0xF891 0x1038      LDRB     R1,[R1, #+56]
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0xB131             CBZ.N    R1,??min_temp_error_0
    698            {
    699              _temp_error(e, PSTR(MSG_T_MINTEMP), e >= 0 ? PSTR(MSG_ERR_MINTEMP) : PSTR(MSG_ERR_MINTEMP_BED));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xBF4C             ITE      MI 
   \   00000010   0x.... 0x....      LDRMI.W  R2,??DataTable62_2
   \   00000014   0x.... 0x....      LDRPL.W  R2,??DataTable62_3
   \   00000018   0xE001             B.N      ??min_temp_error_1
    700              //temper_error_type=3;
    701            }
    702            //#else
    703            else
    704            {
    705              _temp_error(HOTEND_INDEX, PSTR(MSG_T_MINTEMP), PSTR(MSG_ERR_MINTEMP));
   \                     ??min_temp_error_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable62_3
   \                     ??min_temp_error_1: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable62_4
   \   00000022   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
    706              #if HOTENDS == 1
    707                UNUSED(e);
    708              #endif
    709              //temper_error_type=4;
    710            }
    711            if(e>=0)temper_error_type=4;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable63
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xBF54             ITE      PL 
   \   0000002E   0x2104             MOVPL    R1,#+4
    712             else temper_error_type=3;
   \   00000030   0x2103             MOVMI    R1,#+3
   \   00000032   0x7001             STRB     R1,[R0, #+0]
    713            //#endif
    714          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    715          

   \                                 In section .text, align 2, keep-with-next
    716          float Temperature::get_pid_output(const int8_t e) {
   \                     _ZN11Temperature14get_pid_outputEa: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
    717            #if HOTENDS == 1
    718              UNUSED(e);
    719              #define _HOTEND_TEST     true
    720            #else
    721              #define _HOTEND_TEST     e == active_extruder
    722            #endif
    723            float pid_output;
    724            //#if ENABLED(PIDTEMP)
    725            if(PIDTEMP) {
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x....             LDR.N    R5,??DataTable55_6
   \   00000008   0xEB05 0x0684      ADD      R6,R5,R4, LSL #+2
   \   0000000C   0xB083             SUB      SP,SP,#+12
   \   0000000E   0xF8D6 0xA03C      LDR      R10,[R6, #+60]
   \   00000012   0x4650             MOV      R0,R10
   \   00000014   0x.... 0x....      BL       __aeabi_i2f
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x....             LDR.N    R0,??DataTable55
   \   0000001C   0xF8D6 0x8044      LDR      R8,[R6, #+68]
   \   00000020   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xF000 0x8086      BEQ.W    ??get_pid_output_0
    726              #if DISABLED(PID_OPENLOOP)
    727                pid_error[HOTEND_INDEX] = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0x4641             MOV      R1,R8
   \   0000002E   0x.... 0x....      BL       __aeabi_fsub
   \   00000032   0x.... 0x....      LDR.W    R6,??DataTable63_1
   \   00000036   0xEB06 0x0784      ADD      R7,R6,R4, LSL #+2
   \   0000003A   0x4681             MOV      R9,R0
   \   0000003C   0xF8C7 0x902C      STR      R9,[R7, #+44]
    728                dTerm[HOTEND_INDEX] = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + PID_K1 * dTerm[HOTEND_INDEX];
   \   00000040   0x6DE8             LDR      R0,[R5, #+92]
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable63_2  ;; 0x999999a0
   \   0000004A   0x.... 0x....      LDR.W    R3,??DataTable63_3  ;; 0x3fa99999
   \   0000004E   0x.... 0x....      BL       __aeabi_dmul
   \   00000052   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000056   0x68F9             LDR      R1,[R7, #+12]
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x.... 0x....      BL       __aeabi_fsub
   \   0000005E   0x.... 0x....      BL       __aeabi_f2d
   \   00000062   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000066   0x.... 0x....      BL       __aeabi_dmul
   \   0000006A   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   0000006E   0x6A78             LDR      R0,[R7, #+36]
   \   00000070   0x.... 0x....      BL       __aeabi_f2d
   \   00000074   0x.... 0x....      LDR.W    R3,??DataTable63_4  ;; 0x3fee6666
   \   00000078   0xF04F 0x3266      MOV      R2,#+1717986918
   \   0000007C   0x.... 0x....      BL       __aeabi_dmul
   \   00000080   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000084   0x.... 0x....      BL       __aeabi_dadd
   \   00000088   0x.... 0x....      BL       __aeabi_d2f
   \   0000008C   0x4683             MOV      R11,R0
    729                temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
    730                #if HEATER_IDLE_HANDLER
    731                  if (heater_idle_timeout_exceeded[HOTEND_INDEX]) {
    732                    pid_output = 0;
    733                    pid_reset[HOTEND_INDEX] = true;
    734                  }
    735                  else
    736                #endif
    737                if (pid_error[HOTEND_INDEX] > PID_FUNCTIONAL_RANGE) {
   \   0000008E   0x4648             MOV      R0,R9
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable63_5  ;; 0x42200001
   \   00000094   0xF8C7 0xB024      STR      R11,[R7, #+36]
   \   00000098   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000009C   0xF8C7 0x800C      STR      R8,[R7, #+12]
   \   000000A0   0xBF98             IT       LS 
    738                  pid_output = BANG_MAX;
   \   000000A2   0x.... 0x....      LDRLS.W  R0,??DataTable63_6  ;; 0x437f0000
    739                  pid_reset[HOTEND_INDEX] = true;
   \   000000A6   0xD908             BLS.N    ??get_pid_output_1
    740                }
    741                else if (pid_error[HOTEND_INDEX] < -(PID_FUNCTIONAL_RANGE) || target_temperature[HOTEND_INDEX] == 0
    742                  #if HEATER_IDLE_HANDLER
    743                    || heater_idle_timeout_exceeded[HOTEND_INDEX]
    744                  #endif
    745                  ) {
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable63_7  ;; 0xc2200000
   \   000000AC   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B0   0xD302             BCC.N    ??get_pid_output_2
   \   000000B2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000B6   0xD103             BNE.N    ??get_pid_output_3
    746                  pid_output = 0;
   \                     ??get_pid_output_2: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
    747                  pid_reset[HOTEND_INDEX] = true;
   \                     ??get_pid_output_1: (+1)
   \   000000BA   0x2101             MOVS     R1,#+1
   \   000000BC   0x55A1             STRB     R1,[R4, R6]
    748                }
    749                else {
    750                  if (pid_reset[HOTEND_INDEX]) {
    751                    temp_iState[HOTEND_INDEX] = 0.0;
    752                    pid_reset[HOTEND_INDEX] = false;
    753                  }
    754                  pTerm[HOTEND_INDEX] = PID_PARAM(Kp, HOTEND_INDEX) * pid_error[HOTEND_INDEX];
    755                  temp_iState[HOTEND_INDEX] += pid_error[HOTEND_INDEX];
    756                  iTerm[HOTEND_INDEX] = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
    757          
    758                  pid_output = pTerm[HOTEND_INDEX] + iTerm[HOTEND_INDEX] - dTerm[HOTEND_INDEX];
    759          
    760                  #if ENABLED(PID_EXTRUSION_SCALING)
    761                    cTerm[HOTEND_INDEX] = 0;
    762                    if (_HOTEND_TEST) {
    763                      long e_position = stepper.position(E_AXIS);
    764                      if (e_position > last_e_position) {
    765                        lpq[lpq_ptr] = e_position - last_e_position;
    766                        last_e_position = e_position;
    767                      }
    768                      else {
    769                        lpq[lpq_ptr] = 0;
    770                      }
    771                      if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
    772                      cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
    773                      pid_output += cTerm[HOTEND_INDEX];
    774                    }
    775                  #endif // PID_EXTRUSION_SCALING
    776          
    777                  if (pid_output > PID_MAX) {
    778                    if (pid_error[HOTEND_INDEX] > 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
    779                    pid_output = PID_MAX;
    780                  }
    781                  else if (pid_output < 0) {
    782                    if (pid_error[HOTEND_INDEX] < 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
    783                    pid_output = 0;
    784                  }
    785                }
    786            	}
    787              #else
    788                pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
    789              #endif // PID_OPENLOOP
    790          
    791              #if ENABLED(PID_DEBUG)
    792                SERIAL_ECHO_START();
    793                SERIAL_ECHOPAIR(MSG_PID_DEBUG, HOTEND_INDEX);
    794                SERIAL_ECHOPAIR(MSG_PID_DEBUG_INPUT, current_temperature[HOTEND_INDEX]);
    795                SERIAL_ECHOPAIR(MSG_PID_DEBUG_OUTPUT, pid_output);
    796                SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, pTerm[HOTEND_INDEX]);
    797                SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, iTerm[HOTEND_INDEX]);
    798                SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, dTerm[HOTEND_INDEX]);
    799                #if ENABLED(PID_EXTRUSION_SCALING)
    800                  SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, cTerm[HOTEND_INDEX]);
    801                #endif
    802                SERIAL_EOL();
    803              #endif // PID_DEBUG
    804          
    805            //#else /* PID off */
    806            else
    807            {
    808              #if HEATER_IDLE_HANDLER
    809                if (heater_idle_timeout_exceeded[HOTEND_INDEX])
    810                  pid_output = 0;
    811                else
    812              #endif
    813              pid_output = (current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? PID_MAX : 0;
    814            }
    815            //#endif
    816          
    817            return pid_output;
   \   000000BE   0x....             B.N      ?Subroutine1
   \                     ??get_pid_output_3: (+1)
   \   000000C0   0x5DA0             LDRB     R0,[R4, R6]
   \   000000C2   0xB110             CBZ.N    R0,??get_pid_output_4
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x6078             STR      R0,[R7, #+4]
   \   000000C8   0x55A0             STRB     R0,[R4, R6]
   \                     ??get_pid_output_4: (+1)
   \   000000CA   0x4649             MOV      R1,R9
   \   000000CC   0x6D68             LDR      R0,[R5, #+84]
   \   000000CE   0x.... 0x....      BL       __aeabi_fmul
   \   000000D2   0x4604             MOV      R4,R0
   \   000000D4   0x617C             STR      R4,[R7, #+20]
   \   000000D6   0x4649             MOV      R1,R9
   \   000000D8   0x6878             LDR      R0,[R7, #+4]
   \   000000DA   0x.... 0x....      BL       __aeabi_fadd
   \   000000DE   0x4606             MOV      R6,R0
   \   000000E0   0x607E             STR      R6,[R7, #+4]
   \   000000E2   0x4631             MOV      R1,R6
   \   000000E4   0x6DA8             LDR      R0,[R5, #+88]
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x4601             MOV      R1,R0
   \   000000EC   0x61F9             STR      R1,[R7, #+28]
   \   000000EE   0x4620             MOV      R0,R4
   \   000000F0   0x.... 0x....      BL       __aeabi_fadd
   \   000000F4   0x4659             MOV      R1,R11
   \   000000F6   0x.... 0x....      BL       __aeabi_fsub
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable63_8  ;; 0x437f0001
   \   000000FE   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000102   0xD80A             BHI.N    ??get_pid_output_5
   \   00000104   0x4648             MOV      R0,R9
   \   00000106   0x2100             MOVS     R1,#+0
   \   00000108   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000010C   0xD217             BCS.N    ??get_pid_output_6
   \   0000010E   0x4630             MOV      R0,R6
   \   00000110   0x4649             MOV      R1,R9
   \   00000112   0x.... 0x....      BL       __aeabi_fsub
   \   00000116   0x6078             STR      R0,[R7, #+4]
   \   00000118   0xE011             B.N      ??get_pid_output_6
   \                     ??get_pid_output_5: (+1)
   \   0000011A   0x2100             MOVS     R1,#+0
   \   0000011C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000120   0xD211             BCS.N    ??get_pid_output_7
   \   00000122   0x4648             MOV      R0,R9
   \   00000124   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000128   0xD20C             BCS.N    ??get_pid_output_8
   \   0000012A   0x4630             MOV      R0,R6
   \   0000012C   0x4649             MOV      R1,R9
   \   0000012E   0x.... 0x....      BL       __aeabi_fsub
   \   00000132   0x6078             STR      R0,[R7, #+4]
   \   00000134   0xE006             B.N      ??get_pid_output_8
   \                     ??get_pid_output_0: (+1)
   \   00000136   0x4640             MOV      R0,R8
   \   00000138   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000013C   0xD202             BCS.N    ??get_pid_output_8
   \                     ??get_pid_output_6: (+1)
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable63_6  ;; 0x437f0000
   \   00000142   0x....             B.N      ?Subroutine1
   \                     ??get_pid_output_8: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \                     ??get_pid_output_7: (+1)
   \   00000146                      REQUIRE ?Subroutine1
   \   00000146                      ;; // Fall through to label ?Subroutine1
    818          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xB003             ADD      SP,SP,#+12
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    819          
    820          #if 1//ENABLED(PIDTEMPBED)

   \                                 In section .text, align 2, keep-with-next
    821            float Temperature::get_pid_output_bed() {
   \                     _ZN11Temperature18get_pid_output_bedEv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    822              float pid_output;
    823              #if DISABLED(PID_OPENLOOP)
    824                pid_error_bed = target_temperature_bed - current_temperature_bed;
   \   00000004   0x....             LDR.N    R6,??DataTable55_6
   \   00000006   0x6CF4             LDR      R4,[R6, #+76]
   \   00000008   0xF9B6 0x0024      LDRSH    R0,[R6, #+36]
   \   0000000C   0x.... 0x....      BL       __aeabi_i2f
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x.... 0x....      BL       __aeabi_fsub
   \   00000016   0x.... 0x....      LDR.W    R5,??DataTable58
   \   0000001A   0x4680             MOV      R8,R0
    825                pTerm_bed = bedKp * pid_error_bed;
   \   0000001C   0x6E30             LDR      R0,[R6, #+96]
   \   0000001E   0xF8C5 0x801C      STR      R8,[R5, #+28]
   \   00000022   0x4641             MOV      R1,R8
   \   00000024   0x.... 0x....      BL       __aeabi_fmul
   \   00000028   0x4606             MOV      R6,R0
    826                temp_iState_bed += pid_error_bed;
   \   0000002A   0x68A8             LDR      R0,[R5, #+8]
   \   0000002C   0x612E             STR      R6,[R5, #+16]
   \   0000002E   0x4641             MOV      R1,R8
   \   00000030   0x.... 0x....      BL       __aeabi_fadd
   \   00000034   0x4607             MOV      R7,R0
    827                iTerm_bed = bedKi * temp_iState_bed;
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0x60AF             STR      R7,[R5, #+8]
   \   0000003A   0x4639             MOV      R1,R7
   \   0000003C   0x.... 0x....      BL       __aeabi_fmul
   \   00000040   0x4681             MOV      R9,R0
    828          
    829                dTerm_bed = PID_K2 * bedKd * (current_temperature_bed - temp_dState_bed) + PID_K1 * dTerm_bed;
   \   00000042   0x6868             LDR      R0,[R5, #+4]
   \   00000044   0xF8C5 0x9014      STR      R9,[R5, #+20]
   \   00000048   0x.... 0x....      BL       __aeabi_f2d
   \   0000004C   0x.... 0x....      LDR.W    R2,??DataTable63_2  ;; 0x999999a0
   \   00000050   0x.... 0x....      LDR.W    R3,??DataTable63_3  ;; 0x3fa99999
   \   00000054   0x.... 0x....      BL       __aeabi_dmul
   \   00000058   0x468B             MOV      R11,R1
   \   0000005A   0x4682             MOV      R10,R0
   \   0000005C   0x68E9             LDR      R1,[R5, #+12]
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       __aeabi_fsub
   \   00000064   0x.... 0x....      BL       __aeabi_f2d
   \   00000068   0x4652             MOV      R2,R10
   \   0000006A   0x465B             MOV      R3,R11
   \   0000006C   0x.... 0x....      BL       __aeabi_dmul
   \   00000070   0x4682             MOV      R10,R0
   \   00000072   0x69A8             LDR      R0,[R5, #+24]
   \   00000074   0x468B             MOV      R11,R1
   \   00000076   0x.... 0x....      BL       __aeabi_f2d
   \   0000007A   0xF04F 0x3266      MOV      R2,#+1717986918
   \   0000007E   0x.... 0x....      LDR.W    R3,??DataTable63_4  ;; 0x3fee6666
   \   00000082   0x.... 0x....      BL       __aeabi_dmul
   \   00000086   0x4652             MOV      R2,R10
   \   00000088   0x465B             MOV      R3,R11
   \   0000008A   0x.... 0x....      BL       __aeabi_dadd
   \   0000008E   0x.... 0x....      BL       __aeabi_d2f
   \   00000092   0x4682             MOV      R10,R0
   \   00000094   0xF8C5 0xA018      STR      R10,[R5, #+24]
    830                temp_dState_bed = current_temperature_bed;
   \   00000098   0x60EC             STR      R4,[R5, #+12]
    831          
    832                pid_output = pTerm_bed + iTerm_bed - dTerm_bed;
   \   0000009A   0x4630             MOV      R0,R6
   \   0000009C   0x4649             MOV      R1,R9
   \   0000009E   0x.... 0x....      BL       __aeabi_fadd
   \   000000A2   0x4651             MOV      R1,R10
   \   000000A4   0x.... 0x....      BL       __aeabi_fsub
    833                if (pid_output > MAX_BED_POWER) {
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable63_8  ;; 0x437f0001
   \   000000AC   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000B0   0xD80C             BHI.N    ??get_pid_output_bed_0
    834                  if (pid_error_bed > 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
   \   000000B2   0x4640             MOV      R0,R8
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000BA   0xD204             BCS.N    ??get_pid_output_bed_1
   \   000000BC   0x4638             MOV      R0,R7
   \   000000BE   0x4641             MOV      R1,R8
   \   000000C0   0x.... 0x....      BL       __aeabi_fsub
   \   000000C4   0x4607             MOV      R7,R0
    835                  pid_output = MAX_BED_POWER;
   \                     ??get_pid_output_bed_1: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable63_6  ;; 0x437f0000
   \   000000CA   0xE00D             B.N      ??get_pid_output_bed_2
    836                }
    837                else if (pid_output < 0) {
   \                     ??get_pid_output_bed_0: (+1)
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D2   0xD209             BCS.N    ??get_pid_output_bed_2
    838                  if (pid_error_bed < 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
   \   000000D4   0x4640             MOV      R0,R8
   \   000000D6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000DA   0xD204             BCS.N    ??get_pid_output_bed_3
   \   000000DC   0x4638             MOV      R0,R7
   \   000000DE   0x4641             MOV      R1,R8
   \   000000E0   0x.... 0x....      BL       __aeabi_fsub
   \   000000E4   0x4607             MOV      R7,R0
    839                  pid_output = 0;
   \                     ??get_pid_output_bed_3: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \                     ??get_pid_output_bed_2: (+1)
   \   000000E8   0x60AF             STR      R7,[R5, #+8]
    840                }
    841              #else
    842                pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
    843              #endif // PID_OPENLOOP
    844          
    845              #if ENABLED(PID_BED_DEBUG)
    846                SERIAL_ECHO_START();
    847                SERIAL_ECHOPGM(" PID_BED_DEBUG ");
    848                SERIAL_ECHOPGM(": Input ");
    849                SERIAL_ECHO(current_temperature_bed);
    850                SERIAL_ECHOPGM(" Output ");
    851                SERIAL_ECHO(pid_output);
    852                SERIAL_ECHOPGM(" pTerm ");
    853                SERIAL_ECHO(pTerm_bed);
    854                SERIAL_ECHOPGM(" iTerm ");
    855                SERIAL_ECHO(iTerm_bed);
    856                SERIAL_ECHOPGM(" dTerm ");
    857                SERIAL_ECHOLN(dTerm_bed);
    858              #endif // PID_BED_DEBUG
    859          
    860              return pid_output;
   \   000000EA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    861            }
    862          #endif // PIDTEMPBED
    863          
    864          /**
    865           * Manage heating activities for extruder hot-ends and a heated bed
    866           *  - Acquire updated temperature readings
    867           *    - Also resets the watchdog timer
    868           *  - Invoke thermal runaway protection
    869           *  - Manage extruder auto-fan
    870           *  - Apply filament width to the extrusion rate (may move)
    871           *  - Update the heated bed PID output value
    872           */
    873          static float current_temper_bak;
    874          

   \                                 In section .text, align 2, keep-with-next
    875          void Temperature::manage_heater() {
   \                     _ZN11Temperature13manage_heaterEv: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
    876          
    877            if (!temp_meas_ready) return;
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable62_5
   \   00000008   0xB089             SUB      SP,SP,#+36
   \   0000000A   0x78B0             LDRB     R0,[R6, #+2]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF000 0x81AB      BEQ.W    ??manage_heater_0
    878          
    879            updateTemperaturesFromRawValues(); // also resets the watchdog
   \   00000012   0x.... 0x....      BL       _ZN11Temperature31updateTemperaturesFromRawValuesEv
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable65
   \   0000001A   0x9003             STR      R0,[SP, #+12]
   \   0000001C   0xF990 0x0016      LDRSB    R0,[R0, #+22]
   \   00000020   0xF110 0x0F03      CMN      R0,#+3
   \   00000024   0xD159             BNE.N    ??manage_heater_1
    880          
    881            //#if ENABLED(HEATER_0_USES_MAX6675)
    882             if(TEMP_SENSOR_0 == sensors_MAX31855)
    883             {
    884              if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) 
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable65_1
   \   0000002A   0xF9B0 0x0030      LDRSH    R0,[R0, #+48]
   \   0000002E   0xF240 0x7107      MOVW     R1,#+1799
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xDA04             BGE.N    ??manage_heater_2
   \   00000036   0x.... 0x....      BL       __aeabi_i2d
   \   0000003A   0x4604             MOV      R4,R0
   \   0000003C   0x460D             MOV      R5,R1
   \   0000003E   0xE002             B.N      ??manage_heater_3
   \                     ??manage_heater_2: (+1)
   \   00000040   0x2400             MOVS     R4,#+0
   \   00000042   0x.... 0x....      LDR.W    R5,??DataTable65_2  ;; 0x409c1c00
   \                     ??manage_heater_3: (+1)
   \   00000046   0xF8D6 0x8044      LDR      R8,[R6, #+68]
   \   0000004A   0x.... 0x....      LDR.W    R7,??DataTable65_3
   \   0000004E   0x4640             MOV      R0,R8
   \   00000050   0x.... 0x....      BL       __aeabi_f2d
   \   00000054   0x4602             MOV      R2,R0
   \   00000056   0x460B             MOV      R3,R1
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x4629             MOV      R1,R5
   \   0000005C   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000060   0xD216             BCS.N    ??manage_heater_4
    885              {
    886                  if(current_temperature[0] == 1800)
   \   00000062   0x4640             MOV      R0,R8
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable65_4  ;; 0x44e10000
   \   00000068   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000006C   0xD103             BNE.N    ??manage_heater_5
    887                  {
    888                     current_temperature[0] = current_temper_bak;
   \   0000006E   0xF8D6 0x0080      LDR      R0,[R6, #+128]
   \   00000072   0x6470             STR      R0,[R6, #+68]
   \   00000074   0xE00C             B.N      ??manage_heater_4
    889                  }
    890                  else
    891                  {
    892                      max_temp_error(0);
   \                     ??manage_heater_5: (+1)
   \   00000076   0x7A38             LDRB     R0,[R7, #+8]
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable62_1
   \   0000007C   0x.... 0x....      LDR.W    R2,??DataTable62
   \   00000080   0xB100             CBZ.N    R0,??manage_heater_6
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??manage_heater_6: (+1)
   \   00000084   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable63
   \   0000008C   0x2002             MOVS     R0,#+2
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
    893                  }
    894              }
    895              if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
   \                     ??manage_heater_4: (+1)
   \   00000090   0xF46F 0x7186      MVN      R1,#+268
   \   00000094   0x9803             LDR      R0,[SP, #+12]
   \   00000096   0xF9B0 0x0010      LDRSH    R0,[R0, #+16]
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xDB04             BLT.N    ??manage_heater_7
   \   0000009E   0x.... 0x....      BL       __aeabi_i2d
   \   000000A2   0x4604             MOV      R4,R0
   \   000000A4   0x460D             MOV      R5,R1
   \   000000A6   0xE003             B.N      ??manage_heater_8
   \                     ??manage_heater_7: (+1)
   \   000000A8   0x.... 0x....      LDR.W    R4,??DataTable65_5  ;; 0xa3d70a4
   \   000000AC   0x.... 0x....      LDR.W    R5,??DataTable65_6  ;; 0xc070dfd7
   \                     ??manage_heater_8: (+1)
   \   000000B0   0x6C70             LDR      R0,[R6, #+68]
   \   000000B2   0x.... 0x....      BL       __aeabi_f2d
   \   000000B6   0x4622             MOV      R2,R4
   \   000000B8   0x462B             MOV      R3,R5
   \   000000BA   0x.... 0x....      BL       __aeabi_cdcmple
   \   000000BE   0xD20C             BCS.N    ??manage_heater_1
   \   000000C0   0x7A38             LDRB     R0,[R7, #+8]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable62_4
   \   000000C6   0x.... 0x....      LDR.W    R2,??DataTable62_3
   \   000000CA   0xB100             CBZ.N    R0,??manage_heater_9
   \   000000CC   0x2000             MOVS     R0,#+0
   \                     ??manage_heater_9: (+1)
   \   000000CE   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable63
   \   000000D6   0x2004             MOVS     R0,#+4
   \   000000D8   0x7008             STRB     R0,[R1, #+0]
    896             }
    897             current_temper_bak = current_temperature[0];
   \                     ??manage_heater_1: (+1)
   \   000000DA   0x6C70             LDR      R0,[R6, #+68]
   \   000000DC   0xF8C6 0x0080      STR      R0,[R6, #+128]
    898            //#endif
    899          
    900            //#if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
    901              millis_t ms = millis();
   \   000000E0   0x.... 0x....      BL       HAL_GetTick
   \   000000E4   0x4604             MOV      R4,R0
    902            //#endif
    903          
    904            HOTEND_LOOP() {
   \   000000E6   0xF206 0x0086      ADDW     R0,R6,#+134
   \   000000EA   0x9008             STR      R0,[SP, #+32]
   \   000000EC   0x2500             MOVS     R5,#+0
   \   000000EE   0xF106 0x001C      ADD      R0,R6,#+28
   \   000000F2   0x9006             STR      R0,[SP, #+24]
   \   000000F4   0x9607             STR      R6,[SP, #+28]
   \   000000F6   0xF106 0x0020      ADD      R0,R6,#+32
   \   000000FA   0x9005             STR      R0,[SP, #+20]
   \   000000FC   0xF106 0x0A3C      ADD      R10,R6,#+60
   \   00000100   0xF106 0x0030      ADD      R0,R6,#+48
   \   00000104   0x9004             STR      R0,[SP, #+16]
   \   00000106   0xF106 0x0944      ADD      R9,R6,#+68
   \   0000010A   0xF106 0x0888      ADD      R8,R6,#+136
   \   0000010E   0xF106 0x0770      ADD      R7,R6,#+112
   \   00000112   0xE01A             B.N      ??manage_heater_10
    905          
    906              #if HEATER_IDLE_HANDLER
    907                if (!heater_idle_timeout_exceeded[e] && heater_idle_timeout_ms[e] && ELAPSED(ms, heater_idle_timeout_ms[e]))
    908                  heater_idle_timeout_exceeded[e] = true;
    909              #endif
    910          
    911              #if ENABLED(THERMAL_PROTECTION_HOTENDS)
    912                // Check for thermal runaway
    913                thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
    914              #endif
    915          
    916              soft_pwm_amount[e] = (current_temperature[e] > minttemp[e] || is_preheating(e)) && current_temperature[e] < maxttemp[e] ? (int)get_pid_output(e) >> 1 : 0;
    917          
    918              #if WATCH_HOTENDS
    919          
    920                // Make sure temperature is increasing
    921                if (watch_heater_next_ms[e] && ELAPSED(ms, watch_heater_next_ms[e])) { // Time to check this extruder?
    922                  if (degHotend(e) < watch_target_temp[e])                             // Failed to increase enough?
    923                  {
    924                    _temp_error(e, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    925                    temper_error_type=5;
    926                  }
    927                  else                                                                 // Start again if the target is still far off
    928                    start_watching_heater(e);
   \                     ??manage_heater_11: (+1)
   \   00000114   0xB2E8             UXTB     R0,R5
   \   00000116   0x.... 0x....      BL       _ZN11Temperature21start_watching_heaterEh
   \                     ??manage_heater_12: (+1)
   \   0000011A   0x9804             LDR      R0,[SP, #+16]
   \   0000011C   0x1C80             ADDS     R0,R0,#+2
   \   0000011E   0x9004             STR      R0,[SP, #+16]
   \   00000120   0x1C6D             ADDS     R5,R5,#+1
   \   00000122   0x9805             LDR      R0,[SP, #+20]
   \   00000124   0x1C80             ADDS     R0,R0,#+2
   \   00000126   0x9005             STR      R0,[SP, #+20]
   \   00000128   0xB26D             SXTB     R5,R5
   \   0000012A   0x9806             LDR      R0,[SP, #+24]
   \   0000012C   0x1C80             ADDS     R0,R0,#+2
   \   0000012E   0x9006             STR      R0,[SP, #+24]
   \   00000130   0x1D3F             ADDS     R7,R7,#+4
   \   00000132   0x9807             LDR      R0,[SP, #+28]
   \   00000134   0x1C40             ADDS     R0,R0,#+1
   \   00000136   0x9007             STR      R0,[SP, #+28]
   \   00000138   0xF108 0x0804      ADD      R8,R8,#+4
   \   0000013C   0x9808             LDR      R0,[SP, #+32]
   \   0000013E   0x1C40             ADDS     R0,R0,#+1
   \   00000140   0xF109 0x0904      ADD      R9,R9,#+4
   \   00000144   0xF10A 0x0A04      ADD      R10,R10,#+4
   \   00000148   0x9008             STR      R0,[SP, #+32]
   \                     ??manage_heater_10: (+1)
   \   0000014A   0x9803             LDR      R0,[SP, #+12]
   \   0000014C   0x7DC0             LDRB     R0,[R0, #+23]
   \   0000014E   0x4285             CMP      R5,R0
   \   00000150   0xDA4E             BGE.N    ??manage_heater_13
   \   00000152   0x9803             LDR      R0,[SP, #+12]
   \   00000154   0x7880             LDRB     R0,[R0, #+2]
   \   00000156   0x9002             STR      R0,[SP, #+8]
   \   00000158   0x9500             STR      R5,[SP, #+0]
   \   0000015A   0x.... 0x....      LDR.W    R0,??DataTable65_1
   \   0000015E   0xF8B0 0x00E0      LDRH     R0,[R0, #+224]
   \   00000162   0x9001             STR      R0,[SP, #+4]
   \   00000164   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000168   0x.... 0x....      BL       __aeabi_i2f
   \   0000016C   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \   00000170   0x4603             MOV      R3,R0
   \   00000172   0x9808             LDR      R0,[SP, #+32]
   \   00000174   0x4641             MOV      R1,R8
   \   00000176   0x.... 0x....      BL       _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffatt
   \   0000017A   0x9806             LDR      R0,[SP, #+24]
   \   0000017C   0xF8D9 0xB000      LDR      R11,[R9, #+0]
   \   00000180   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000184   0x.... 0x....      BL       __aeabi_i2f
   \   00000188   0x4659             MOV      R1,R11
   \   0000018A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000018E   0xD210             BCS.N    ??manage_heater_14
   \   00000190   0x9805             LDR      R0,[SP, #+20]
   \   00000192   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000196   0x.... 0x....      BL       __aeabi_i2f
   \   0000019A   0x4601             MOV      R1,R0
   \   0000019C   0x4658             MOV      R0,R11
   \   0000019E   0x.... 0x....      BL       __aeabi_cfcmple
   \   000001A2   0xD206             BCS.N    ??manage_heater_14
   \   000001A4   0x4628             MOV      R0,R5
   \   000001A6   0x.... 0x....      BL       _ZN11Temperature14get_pid_outputEa
   \   000001AA   0x.... 0x....      BL       __aeabi_f2iz
   \   000001AE   0x1040             ASRS     R0,R0,#+1
   \   000001B0   0xE000             B.N      ??manage_heater_15
   \                     ??manage_heater_14: (+1)
   \   000001B2   0x2000             MOVS     R0,#+0
   \                     ??manage_heater_15: (+1)
   \   000001B4   0x9907             LDR      R1,[SP, #+28]
   \   000001B6   0x7008             STRB     R0,[R1, #+0]
   \   000001B8   0x6838             LDR      R0,[R7, #+0]
   \   000001BA   0x2800             CMP      R0,#+0
   \   000001BC   0xD0AD             BEQ.N    ??manage_heater_12
   \   000001BE   0x1A20             SUBS     R0,R4,R0
   \   000001C0   0xD4AB             BMI.N    ??manage_heater_12
   \   000001C2   0x9804             LDR      R0,[SP, #+16]
   \   000001C4   0x8800             LDRH     R0,[R0, #+0]
   \   000001C6   0x.... 0x....      BL       __aeabi_ui2f
   \   000001CA   0x4601             MOV      R1,R0
   \   000001CC   0xB2E8             UXTB     R0,R5
   \   000001CE   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \   000001D2   0x6C40             LDR      R0,[R0, #+68]
   \   000001D4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000001D8   0xD29C             BCS.N    ??manage_heater_11
   \   000001DA   0x.... 0x....      ADR.W    R2,`?<Constant "Heating failed">`
   \   000001DE   0x4611             MOV      R1,R2
   \   000001E0   0x4628             MOV      R0,R5
   \   000001E2   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   000001E6   0x.... 0x....      LDR.W    R1,??DataTable63
   \   000001EA   0x2005             MOVS     R0,#+5
   \   000001EC   0x7008             STRB     R0,[R1, #+0]
   \   000001EE   0xE794             B.N      ??manage_heater_12
    929                }
    930                
    931              #endif
    932          
    933              #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    934                // Make sure measured temperatures are close together
    935                if (FABS(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
    936                  _temp_error(0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
    937              #endif
    938          
    939            } // HOTEND_LOOP
    940          
    941            #if HAS_AUTO_FAN
    942              if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
    943                checkExtruderAutoFans();
    944                next_auto_fan_check_ms = ms + 2500UL;
    945              }
    946            #endif
    947          
    948            #if ENABLED(FILAMENT_WIDTH_SENSOR)
    949              /**
    950               * Filament Width Sensor dynamically sets the volumetric multiplier
    951               * based on a delayed measurement of the filament diameter.
    952               */
    953              if (filament_sensor) {
    954                meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
    955                if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
    956                meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
    957                planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
    958              }
    959            #endif // FILAMENT_WIDTH_SENSOR
    960          
    961            #if WATCH_THE_BED
    962              // Make sure temperature is increasing
    963              if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
   \                     ??manage_heater_13: (+1)
   \   000001F0   0x6FB0             LDR      R0,[R6, #+120]
   \   000001F2   0x2800             CMP      R0,#+0
   \   000001F4   0xD04C             BEQ.N    ??manage_heater_16
   \   000001F6   0x1A20             SUBS     R0,R4,R0
   \   000001F8   0xD44A             BMI.N    ??manage_heater_16
    964                if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
   \   000001FA   0x8CF0             LDRH     R0,[R6, #+38]
   \   000001FC   0x.... 0x....      BL       __aeabi_ui2f
   \   00000200   0x4601             MOV      R1,R0
   \   00000202   0x6CF0             LDR      R0,[R6, #+76]
   \   00000204   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000208   0xD240             BCS.N    ??manage_heater_17
    965                {
    966                  _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
   \   0000020A   0x.... 0x....      LDR.W    R5,??DataTable61
   \   0000020E   0x7828             LDRB     R0,[R5, #+0]
   \   00000210   0xB368             CBZ.N    R0,??manage_heater_18
   \   00000212   0x.... 0x....      LDR.W    R8,??DataTable61_1
   \   00000216   0x.... 0x....      LDR.W    R7,??DataTable66
   \   0000021A   0xE003             B.N      ??manage_heater_19
   \                     ??manage_heater_20: (+1)
   \   0000021C   0xB2C9             UXTB     R1,R1
   \   0000021E   0x4638             MOV      R0,R7
   \   00000220   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??manage_heater_19: (+1)
   \   00000224   0xF918 0x1B01      LDRSB    R1,[R8], #+1
   \   00000228   0x0008             MOVS     R0,R1
   \   0000022A   0xD1F7             BNE.N    ??manage_heater_20
   \   0000022C   0x.... 0x....      ADR.W    R8,`?<Constant "Heating failed">`
   \   00000230   0xE003             B.N      ??manage_heater_21
   \                     ??manage_heater_22: (+1)
   \   00000232   0xB2C9             UXTB     R1,R1
   \   00000234   0x4638             MOV      R0,R7
   \   00000236   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??manage_heater_21: (+1)
   \   0000023A   0xF918 0x1B01      LDRSB    R1,[R8], #+1
   \   0000023E   0x0008             MOVS     R0,R1
   \   00000240   0xD1F7             BNE.N    ??manage_heater_22
   \   00000242   0x.... 0x....      LDR.W    R8,??DataTable61_2
   \   00000246   0xE003             B.N      ??manage_heater_23
   \                     ??manage_heater_24: (+1)
   \   00000248   0xB2C9             UXTB     R1,R1
   \   0000024A   0x4638             MOV      R0,R7
   \   0000024C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??manage_heater_23: (+1)
   \   00000250   0xF918 0x1B01      LDRSB    R1,[R8], #+1
   \   00000254   0x0008             MOVS     R0,R1
   \   00000256   0xD1F7             BNE.N    ??manage_heater_24
   \   00000258   0x.... 0x....      LDR.W    R8,??DataTable61_3
   \   0000025C   0xE003             B.N      ??manage_heater_25
   \                     ??manage_heater_26: (+1)
   \   0000025E   0xB2C9             UXTB     R1,R1
   \   00000260   0x4638             MOV      R0,R7
   \   00000262   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??manage_heater_25: (+1)
   \   00000266   0xF918 0x1B01      LDRSB    R1,[R8], #+1
   \   0000026A   0x0008             MOVS     R0,R1
   \   0000026C   0xD1F7             BNE.N    ??manage_heater_26
   \                     ??manage_heater_18: (+1)
   \   0000026E   0x7930             LDRB     R0,[R6, #+4]
   \   00000270   0xB928             CBNZ.N   R0,??manage_heater_27
   \   00000272   0x7028             STRB     R0,[R5, #+0]
   \   00000274   0x2001             MOVS     R0,#+1
   \   00000276   0x7130             STRB     R0,[R6, #+4]
   \   00000278   0x.... 0x....      BL       _Z17temper_error_killv
   \   0000027C   0xE001             B.N      ??manage_heater_28
   \                     ??manage_heater_27: (+1)
   \   0000027E   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
    967                  temper_error_type=6;
   \                     ??manage_heater_28: (+1)
   \   00000282   0x2006             MOVS     R0,#+6
   \   00000284   0x.... 0x....      LDR.W    R1,??DataTable63
   \   00000288   0x7008             STRB     R0,[R1, #+0]
   \   0000028A   0xE001             B.N      ??manage_heater_16
    968                }
    969                else                                                            // Start again if the target is still far off
    970                  start_watching_bed();
   \                     ??manage_heater_17: (+1)
   \   0000028C   0x.... 0x....      BL       _ZN11Temperature18start_watching_bedEv
    971              }
    972            #endif // WATCH_THE_BED
    973          
    974            //#if DISABLED(PIDTEMPBED)
    975          	if(PIDTEMPBED == 0) {  
   \                     ??manage_heater_16: (+1)
   \   00000290   0x.... 0x....      LDR.W    R7,??DataTable65_3
   \   00000294   0x79F8             LDRB     R0,[R7, #+7]
   \   00000296   0xB930             CBNZ.N   R0,??manage_heater_29
    976              	if (PENDING(ms, next_bed_check_ms)) return;
   \   00000298   0x6FF0             LDR      R0,[R6, #+124]
   \   0000029A   0x1A20             SUBS     R0,R4,R0
   \   0000029C   0xD464             BMI.N    ??manage_heater_0
    977              	next_bed_check_ms = ms + BED_CHECK_INTERVAL;
   \   0000029E   0xF504 0x5098      ADD      R0,R4,#+4864
   \   000002A2   0x3088             ADDS     R0,R0,#+136
   \   000002A4   0x67F0             STR      R0,[R6, #+124]
    978          	}
    979            //#endif
    980          
    981            //#if HAS_TEMP_BED
    982            if (HAS_TEMP_BED)
   \                     ??manage_heater_29: (+1)
   \   000002A6   0x7A38             LDRB     R0,[R7, #+8]
   \   000002A8   0x2800             CMP      R0,#+0
   \   000002AA   0xD05D             BEQ.N    ??manage_heater_0
    983            	{
    984              #if HEATER_IDLE_HANDLER
    985                if (!bed_idle_timeout_exceeded && bed_idle_timeout_ms && ELAPSED(ms, bed_idle_timeout_ms))
    986                  bed_idle_timeout_exceeded = true;
    987              #endif
    988          
    989              #if HAS_THERMALLY_PROTECTED_BED
    990          	if(HAS_TEMP_BED)
    991                thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
   \   000002AC   0x9803             LDR      R0,[SP, #+12]
   \   000002AE   0x7A80             LDRB     R0,[R0, #+10]
   \   000002B0   0x9002             STR      R0,[SP, #+8]
   \   000002B2   0x9803             LDR      R0,[SP, #+12]
   \   000002B4   0x8900             LDRH     R0,[R0, #+8]
   \   000002B6   0x9001             STR      R0,[SP, #+4]
   \   000002B8   0xF04F 0x30FF      MOV      R0,#-1
   \   000002BC   0x9000             STR      R0,[SP, #+0]
   \   000002BE   0xF9B6 0x0024      LDRSH    R0,[R6, #+36]
   \   000002C2   0x.... 0x....      BL       __aeabi_i2f
   \   000002C6   0x6CF2             LDR      R2,[R6, #+76]
   \   000002C8   0x4603             MOV      R3,R0
   \   000002CA   0xF106 0x0190      ADD      R1,R6,#+144
   \   000002CE   0xF106 0x0084      ADD      R0,R6,#+132
   \   000002D2   0x.... 0x....      BL       _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffatt
   \   000002D6   0xF9B7 0x0004      LDRSH    R0,[R7, #+4]
   \   000002DA   0x.... 0x....      BL       __aeabi_i2f
   \   000002DE   0x4604             MOV      R4,R0
   \   000002E0   0x6CF5             LDR      R5,[R6, #+76]
   \   000002E2   0x79F8             LDRB     R0,[R7, #+7]
   \   000002E4   0xB1B0             CBZ.N    R0,??manage_heater_30
    992              #endif
    993          
    994              #if HEATER_IDLE_HANDLER
    995                if (bed_idle_timeout_exceeded)
    996                {
    997                  soft_pwm_amount_bed = 0;
    998          
    999                  //#if DISABLED(PIDTEMPBED)
   1000                  if(PIDTEMPBED == 0)
   1001                  {
   1002                    WRITE_HEATER_BED(LOW);
   1003                  }
   1004                  //#endif
   1005                }
   1006                else
   1007              #endif
   1008              {
   1009              #if 0
   1010                #if ENABLED(PIDTEMPBED)
   1011                  soft_pwm_amount_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
   1012          
   1013                #elif ENABLED(BED_LIMIT_SWITCHING)
   1014                  // Check if temperature is within the correct band
   1015                  if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
   1016                    if (current_temperature_bed >= target_temperature_bed + BED_HYSTERESIS)
   1017                      soft_pwm_amount_bed = 0;
   1018                    else if (current_temperature_bed <= target_temperature_bed - (BED_HYSTERESIS))
   1019                      soft_pwm_amount_bed = MAX_BED_POWER >> 1;
   1020                  }
   1021                  else {
   1022                    soft_pwm_amount_bed = 0;
   1023                    WRITE_HEATER_BED(LOW);
   1024                  }
   1025                #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
   1026                  // Check if temperature is within the correct range
   1027                  if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
   1028                    soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
   1029                  }
   1030                  else {
   1031                    soft_pwm_amount_bed = 0;
   1032                    WRITE_HEATER_BED(LOW);
   1033                  }
   1034                #endif
   1035          	  #endif
   1036          		if(PIDTEMPBED)
   1037          		{
   1038          			float pid_output = get_pid_output_bed();
   \   000002E6   0x.... 0x....      BL       _ZN11Temperature18get_pid_output_bedEv
   \   000002EA   0x4680             MOV      R8,R0
   1039          			soft_pwm_amount_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)pid_output >> 1 : 0;
   \   000002EC   0x4628             MOV      R0,R5
   \   000002EE   0x4621             MOV      R1,R4
   \   000002F0   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000002F4   0xD80C             BHI.N    ??manage_heater_31
   \   000002F6   0xF9B7 0x0002      LDRSH    R0,[R7, #+2]
   \   000002FA   0x.... 0x....      BL       __aeabi_i2f
   \   000002FE   0x4629             MOV      R1,R5
   \   00000300   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000304   0xD804             BHI.N    ??manage_heater_31
   \   00000306   0x4640             MOV      R0,R8
   \   00000308   0x.... 0x....      BL       __aeabi_f2iz
   \   0000030C   0x1040             ASRS     R0,R0,#+1
   \   0000030E   0xE019             B.N      ??manage_heater_32
   \                     ??manage_heater_31: (+1)
   \   00000310   0x2000             MOVS     R0,#+0
   \   00000312   0xE017             B.N      ??manage_heater_32
   1040          		}
   1041          		else
   1042          		{
   1043          			// Check if temperature is within the correct range
   1044          			if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) 
   \                     ??manage_heater_30: (+1)
   \   00000314   0x4628             MOV      R0,R5
   \   00000316   0x4621             MOV      R1,R4
   \   00000318   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000031C   0xD814             BHI.N    ??manage_heater_33
   \   0000031E   0xF9B7 0x0002      LDRSH    R0,[R7, #+2]
   \   00000322   0x.... 0x....      BL       __aeabi_i2f
   \   00000326   0x4629             MOV      R1,R5
   \   00000328   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000032C   0xD80C             BHI.N    ??manage_heater_33
   1045          			{
   1046          		  		soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
   \   0000032E   0xF9B6 0x0024      LDRSH    R0,[R6, #+36]
   \   00000332   0x.... 0x....      BL       __aeabi_i2f
   \   00000336   0x4601             MOV      R1,R0
   \   00000338   0x4628             MOV      R0,R5
   \   0000033A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000033E   0xBF34             ITE      CC 
   \   00000340   0x207F             MOVCC    R0,#+127
   \   00000342   0x2000             MOVCS    R0,#+0
   \                     ??manage_heater_32: (+1)
   \   00000344   0x70F0             STRB     R0,[R6, #+3]
   1047          			}
   1048          			else 
   1049          			{
   1050          		  		soft_pwm_amount_bed = 0;
   1051          		  		WRITE_HEATER_BED(LOW);
   1052          			}
   1053          		}	  
   1054              }
   1055            }
   1056            //#endif // HAS_TEMP_BED
   1057          }
   \   00000346   0x....             B.N      ?Subroutine2
   \                     ??manage_heater_33: (+1)
   \   00000348   0x2000             MOVS     R0,#+0
   \   0000034A   0x70F0             STRB     R0,[R6, #+3]
   \   0000034C   0x.... 0x....      LDR.W    R0,??DataTable67
   \   00000350   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000352   0xB948             CBNZ.N   R0,??manage_heater_0
   \   00000354   0x.... 0x....      LDR.W    R0,??DataTable67_1
   \   00000358   0x8D41             LDRH     R1,[R0, #+42]
   \   0000035A   0x.... 0x....      LDR.W    R0,??DataTable67_2
   \   0000035E   0x6D40             LDR      R0,[R0, #+84]
   \   00000360   0xB009             ADD      SP,SP,#+36
   \   00000362   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000366   0x....             B.N      ?Subroutine3
   \                     ??manage_heater_0: (+1)
   \   00000368                      REQUIRE ?Subroutine2
   \   00000368                      ;; // Fall through to label ?Subroutine2

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xB009             ADD      SP,SP,#+36
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x.... 0x....      B.W      HAL_GPIO_WritePin
   1058          
   1059          //#define PGM_RD_W(x)   (short)pgm_read_word(&x)
   1060          #define PGM_RD_W(x)   (short)(x)
   1061          
   1062          // Derived from RepRap FiveD extruder::getTemperature()
   1063          // For hot end temperature measurement.

   \                                 In section .text, align 2, keep-with-next
   1064          float Temperature::analog2temp(const int raw, const uint8_t e) {
   \                     _ZN11Temperature11analog2tempEih: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   1065            #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   1066              if (e > HOTENDS)
   1067            #else
   1068              if (e >= HOTENDS)
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xDB23             BLT.N    ??analog2temp_0
   1069            #endif
   1070              {
   1071                SERIAL_ERROR_START();
   \   0000000C   0x.... 0x....      LDR.W    R9,??DataTable61_1
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable66
   \   00000014   0xE003             B.N      ??analog2temp_1
   \                     ??analog2temp_2: (+1)
   \   00000016   0xB2C9             UXTB     R1,R1
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??analog2temp_1: (+1)
   \   0000001E   0xF919 0x1B01      LDRSB    R1,[R9], #+1
   \   00000022   0x0008             MOVS     R0,R1
   \   00000024   0xD1F7             BNE.N    ??analog2temp_2
   1072                SERIAL_ERROR((int)e);
   \   00000026   0x220A             MOVS     R2,#+10
   \   00000028   0x4621             MOV      R1,R4
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       _ZN5Print5printEii
   1073                SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
   \   00000030   0x.... 0x....      ADR.W    R9,`?<Constant " - Invalid extruder n...">`
   \   00000034   0xE003             B.N      ??analog2temp_3
   \                     ??analog2temp_4: (+1)
   \   00000036   0xB2C9             UXTB     R1,R1
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??analog2temp_3: (+1)
   \   0000003E   0xF919 0x1B01      LDRSB    R1,[R9], #+1
   \   00000042   0x0008             MOVS     R0,R1
   \   00000044   0xD1F7             BNE.N    ??analog2temp_4
   1074                kill(PSTR(MSG_KILLED));
   \   00000046   0x.... 0x....      ADR.W    R0,`?<Constant "KILLED. ">`
   \   0000004A   0x.... 0x....      BL       _Z4killPKc
   1075                return 0.0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1076              }
   1077          
   1078            //#if ENABLED(HEATER_0_USES_MAX6675)
   1079            if(TEMP_SENSOR_0 == sensors_MAX31855)
   \                     ??analog2temp_0: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable65_1
   \   00000058   0xF990 0x00F6      LDRSB    R0,[R0, #+246]
   \   0000005C   0xF110 0x0F03      CMN      R0,#+3
   \   00000060   0xBF08             IT       EQ 
   1080              if (e == 0) return 0.25 * raw;
   \   00000062   0x2900             CMPEQ    R1,#+0
   \   00000064   0xD106             BNE.N    ??analog2temp_5
   \   00000066   0x4648             MOV      R0,R9
   \   00000068   0x.... 0x....      BL       __aeabi_i2d
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0x.... 0x....      LDR.W    R3,??DataTable67_3  ;; 0x3fd00000
   \   00000072   0xE048             B.N      ??analog2temp_6
   1081            //#endif
   1082          
   1083            if (heater_ttbl_map[e] != NULL) {
   \                     ??analog2temp_5: (+1)
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable67_4
   \   00000078   0xEB01 0x0084      ADD      R0,R1,R4, LSL #+2
   \   0000007C   0x6845             LDR      R5,[R0, #+4]
   \   0000007E   0x2D00             CMP      R5,#+0
   \   00000080   0xD03B             BEQ.N    ??analog2temp_7
   1084              float celsius = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   1085              uint8_t i;
   1086              short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
   1087          
   1088              for (i = 1; i < heater_ttbllen_map[e]; i++) {
   \   00000084   0x2601             MOVS     R6,#+1
   \   00000086   0xE001             B.N      ??analog2temp_8
   \                     ??analog2temp_9: (+1)
   \   00000088   0x1C76             ADDS     R6,R6,#+1
   \   0000008A   0xB2F6             UXTB     R6,R6
   \                     ??analog2temp_8: (+1)
   \   0000008C   0x5C67             LDRB     R7,[R4, R1]
   \   0000008E   0x42BE             CMP      R6,R7
   \   00000090   0xDA28             BGE.N    ??analog2temp_10
   \   00000092   0xF935 0x8026      LDRSH    R8,[R5, R6, LSL #+2]
   \   00000096   0x45C1             CMP      R9,R8
   \   00000098   0xDAF6             BGE.N    ??analog2temp_9
   1089                if (PGM_RD_W((*tt)[i][0]) > raw) {
   1090                  celsius = PGM_RD_W((*tt)[i - 1][1]) +
   1091                            (raw - PGM_RD_W((*tt)[i - 1][0])) *
   1092                            (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i - 1][1])) /
   1093                            (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i - 1][0]));
   \   0000009A   0xEB05 0x0486      ADD      R4,R5,R6, LSL #+2
   \   0000009E   0x1F20             SUBS     R0,R4,#+4
   \   000000A0   0xF9B0 0xB002      LDRSH    R11,[R0, #+2]
   \   000000A4   0xF934 0xAC04      LDRSH    R10,[R4, #-4]
   \   000000A8   0x4658             MOV      R0,R11
   \   000000AA   0x.... 0x....      BL       __aeabi_i2f
   \   000000AE   0x9000             STR      R0,[SP, #+0]
   \   000000B0   0xEBA9 0x000A      SUB      R0,R9,R10
   \   000000B4   0x.... 0x....      BL       __aeabi_i2f
   \   000000B8   0x4681             MOV      R9,R0
   \   000000BA   0xF9B4 0x0002      LDRSH    R0,[R4, #+2]
   \   000000BE   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000C2   0x.... 0x....      BL       __aeabi_i2f
   \   000000C6   0x4649             MOV      R1,R9
   \   000000C8   0x.... 0x....      BL       __aeabi_fmul
   \   000000CC   0x4604             MOV      R4,R0
   \   000000CE   0xEBA8 0x000A      SUB      R0,R8,R10
   \   000000D2   0x.... 0x....      BL       __aeabi_i2f
   \   000000D6   0x4601             MOV      R1,R0
   \   000000D8   0x4620             MOV      R0,R4
   \   000000DA   0x.... 0x....      BL       __aeabi_fdiv
   \   000000DE   0x9900             LDR      R1,[SP, #+0]
   \   000000E0   0x.... 0x....      BL       __aeabi_fadd
   1094                  break;
   1095                }
   1096              }
   1097          
   1098              // Overflow: Set to last value in the table
   1099              if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i - 1][1]);
   \                     ??analog2temp_10: (+1)
   \   000000E4   0x42BE             CMP      R6,R7
   \   000000E6   0xD114             BNE.N    ??analog2temp_11
   \   000000E8   0xEB05 0x0086      ADD      R0,R5,R6, LSL #+2
   \   000000EC   0xE8BD 0x4FF2      POP      {R1,R4-R11,LR}
   \   000000F0   0x1F00             SUBS     R0,R0,#+4
   \   000000F2   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   000000F6   0x.... 0x....      B.W      __aeabi_i2f
   1100          
   1101              return celsius;
   1102            }
   1103            return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
   \                     ??analog2temp_7: (+1)
   \   000000FA   0x4648             MOV      R0,R9
   \   000000FC   0x.... 0x....      BL       __aeabi_i2d
   \   00000100   0x.... 0x....      LDR.W    R3,??DataTable69  ;; 0x3f9f4000
   \   00000104   0x2200             MOVS     R2,#+0
   \                     ??analog2temp_6: (+1)
   \   00000106   0x.... 0x....      BL       __aeabi_dmul
   \   0000010A   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   0000010E   0x.... 0x....      B.W      __aeabi_d2f
   \                     ??analog2temp_11: (+1)
   \   00000112   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1104          }
   1105          
   1106          #if 1//HAS_TEMP_BED
   1107            // Derived from RepRap FiveD extruder::getTemperature()
   1108            // For bed temperature measurement.

   \                                 In section .text, align 2, keep-with-next
   1109            float Temperature::analog2tempBed(const int raw) {
   \                     _ZN11Temperature14analog2tempBedEi: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4606             MOV      R6,R0
   1110              #if ENABLED(BED_USES_THERMISTOR)
   1111                float celsius = 0;
   1112                byte i;
   1113          
   1114                for (i = 1; i < BEDTEMPTABLE_LEN; i++) {
   \   00000006   0x.... 0x....      ADR.W    R5,temptable_1
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x2401             MOVS     R4,#+1
   \   0000000E   0x1D29             ADDS     R1,R5,#+4
   1115                  if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw) {
   \                     ??analog2tempBed_0: (+1)
   \   00000010   0xF931 0x2B04      LDRSH    R2,[R1], #+4
   \   00000014   0x4296             CMP      R6,R2
   \   00000016   0xDA28             BGE.N    ??analog2tempBed_1
   1116                    celsius  = PGM_RD_W(BEDTEMPTABLE[i - 1][1]) +
   1117                               (raw - PGM_RD_W(BEDTEMPTABLE[i - 1][0])) *
   1118                               (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i - 1][1])) /
   1119                               (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i - 1][0]));
   \                     ??analog2tempBed_2: (+1)
   \   00000018   0xEB05 0x0784      ADD      R7,R5,R4, LSL #+2
   \   0000001C   0xF1A7 0x0804      SUB      R8,R7,#+4
   \   00000020   0xF9B8 0x0002      LDRSH    R0,[R8, #+2]
   \   00000024   0x.... 0x....      BL       __aeabi_i2f
   \   00000028   0x4681             MOV      R9,R0
   \   0000002A   0xF937 0x0C04      LDRSH    R0,[R7, #-4]
   \   0000002E   0x1A30             SUBS     R0,R6,R0
   \   00000030   0x.... 0x....      BL       __aeabi_i2f
   \   00000034   0x4606             MOV      R6,R0
   \   00000036   0xF9B7 0x0002      LDRSH    R0,[R7, #+2]
   \   0000003A   0xF9B8 0x1002      LDRSH    R1,[R8, #+2]
   \   0000003E   0x1A40             SUBS     R0,R0,R1
   \   00000040   0x.... 0x....      BL       __aeabi_i2f
   \   00000044   0x4631             MOV      R1,R6
   \   00000046   0x.... 0x....      BL       __aeabi_fmul
   \   0000004A   0x4606             MOV      R6,R0
   \   0000004C   0xF935 0x0024      LDRSH    R0,[R5, R4, LSL #+2]
   \   00000050   0xF937 0x1C04      LDRSH    R1,[R7, #-4]
   \   00000054   0x1A40             SUBS     R0,R0,R1
   \   00000056   0x.... 0x....      BL       __aeabi_i2f
   \   0000005A   0x4601             MOV      R1,R0
   \   0000005C   0x4630             MOV      R0,R6
   \   0000005E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000062   0x4649             MOV      R1,R9
   \   00000064   0x.... 0x....      BL       __aeabi_fadd
   1120                    break;
   \   00000068   0xE00F             B.N      ??analog2tempBed_3
   1121                  }
   \                     ??analog2tempBed_1: (+1)
   \   0000006A   0xF931 0x2B04      LDRSH    R2,[R1], #+4
   \   0000006E   0x1C64             ADDS     R4,R4,#+1
   \   00000070   0xB2E4             UXTB     R4,R4
   \   00000072   0x4296             CMP      R6,R2
   \   00000074   0xBFA1             ITTTT    GE 
   \   00000076   0x1C64             ADDGE    R4,R4,#+1
   \   00000078   0xB2E4             UXTBGE   R4,R4
   \   0000007A   0xF931 0x2B04      LDRSHGE  R2,[R1], #+4
   \   0000007E   0x4296             CMPGE    R6,R2
   \   00000080   0xDBCA             BLT.N    ??analog2tempBed_2
   1122                }
   \   00000082   0x1C64             ADDS     R4,R4,#+1
   \   00000084   0xB2E4             UXTB     R4,R4
   \   00000086   0x2C40             CMP      R4,#+64
   \   00000088   0xD3C2             BCC.N    ??analog2tempBed_0
   1123          
   1124                // Overflow: Set to last value in the table
   1125                if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i - 1][1]);
   \                     ??analog2tempBed_3: (+1)
   \   0000008A   0x2C40             CMP      R4,#+64
   \   0000008C   0xBF08             IT       EQ 
   \   0000008E   0x.... 0x....      LDREQ.W  R0,??DataTable69_2  ;; 0xc1c80000
   1126          
   1127                return celsius;
   \   00000092   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1128          
   1129              #elif defined(BED_USES_AD595)
   1130          
   1131                return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
   1132          
   1133              #else
   1134          
   1135                UNUSED(raw);
   1136                return 0;
   1137          
   1138              #endif
   1139            }
   1140          #endif // HAS_TEMP_BED
   1141          
   1142          /**
   1143           * Get the raw values into the actual temperatures.
   1144           * The raw values are created in interrupt context,
   1145           * and this function is called from normal context
   1146           * as it would block the stepper routine.
   1147           */

   \                                 In section .text, align 4, keep-with-next
   1148          void Temperature::updateTemperaturesFromRawValues() {
   \                     _ZN11Temperature31updateTemperaturesFromRawValuesEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1149            //#if ENABLED(HEATER_0_USES_MAX6675)
   1150          	if(TEMP_SENSOR_0 == sensors_MAX31855)
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable65_1
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable69_3
   \   0000000C   0xF995 0x00F6      LDRSB    R0,[R5, #+246]
   \   00000010   0xF110 0x0F03      CMN      R0,#+3
   \   00000014   0xD102             BNE.N    ??updateTemperaturesFromRawValues_0
   1151          	{
   1152              	current_temperature_raw[0] = read_max6675();
   \   00000016   0x.... 0x....      BL       _ZN11Temperature12read_max6675Ev
   \   0000001A   0x6360             STR      R0,[R4, #+52]
   1153          	}
   1154            //#endif
   1155            HOTEND_LOOP()
   \                     ??updateTemperaturesFromRawValues_0: (+1)
   \   0000001C   0x2600             MOVS     R6,#+0
   \   0000001E   0xF104 0x0734      ADD      R7,R4,#+52
   \   00000022   0xF104 0x0844      ADD      R8,R4,#+68
   \   00000026   0xE008             B.N      ??updateTemperaturesFromRawValues_1
   1156              current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
   \                     ??updateTemperaturesFromRawValues_2: (+1)
   \   00000028   0xF857 0x0B04      LDR      R0,[R7], #+4
   \   0000002C   0xB2F1             UXTB     R1,R6
   \   0000002E   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   00000032   0x1C76             ADDS     R6,R6,#+1
   \   00000034   0xF848 0x0B04      STR      R0,[R8], #+4
   \   00000038   0xB276             SXTB     R6,R6
   \                     ??updateTemperaturesFromRawValues_1: (+1)
   \   0000003A   0xF895 0x00F7      LDRB     R0,[R5, #+247]
   \   0000003E   0x4286             CMP      R6,R0
   \   00000040   0xDBF2             BLT.N    ??updateTemperaturesFromRawValues_2
   1157            //#if HAS_TEMP_BED
   1158            if(HAS_TEMP_BED)
   \   00000042   0xF895 0x0038      LDRB     R0,[R5, #+56]
   \   00000046   0xB118             CBZ.N    R0,??updateTemperaturesFromRawValues_3
   1159            {
   1160              current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
   \   00000048   0x6D20             LDR      R0,[R4, #+80]
   \   0000004A   0x.... 0x....      BL       _ZN11Temperature14analog2tempBedEi
   \   0000004E   0x64E0             STR      R0,[R4, #+76]
   1161            }
   1162            //#endif
   1163            #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   1164              redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
   1165            #endif
   1166            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1167              filament_width_meas = analog2widthFil();
   1168            #endif
   1169          
   1170            #if ENABLED(USE_WATCHDOG)
   1171              // Reset the watchdog after we know we have a temperature measurement.
   1172              watchdog_reset();
   1173            #endif
   1174          
   1175            CRITICAL_SECTION_START;
   \                     ??updateTemperaturesFromRawValues_3: (+1)
   \   00000050   0xB672             cpsid i
   1176            temp_meas_ready = false;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x70A0             STRB     R0,[R4, #+2]
   1177            CRITICAL_SECTION_END;
   \   00000056   0xB662             cpsie i
   1178          }
   \   00000058   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1179          
   1180          
   1181          #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1182          
   1183            // Convert raw Filament Width to millimeters
   1184            float Temperature::analog2widthFil() {
   1185              return current_raw_filwidth * 5.0 * (1.0 / 16383.0);
   1186            }
   1187          
   1188            /**
   1189             * Convert Filament Width (mm) to a simple ratio
   1190             * and reduce to an 8 bit value.
   1191             *
   1192             * A nominal width of 1.75 and measured width of 1.73
   1193             * gives (100 * 1.75 / 1.73) for a ratio of 101 and
   1194             * a return value of 1.
   1195             */
   1196            int8_t Temperature::widthFil_to_size_ratio() {
   1197              if (FABS(filament_width_nominal - filament_width_meas) <= FILWIDTH_ERROR_MARGIN)
   1198                return int(100.0 * filament_width_nominal / filament_width_meas) - 100;
   1199              return 0;
   1200            }
   1201          
   1202          #endif
   1203          
   1204          #if 0//ENABLED(HEATER_0_USES_MAX6675)
   1205            #ifndef MAX6675_SCK_PIN
   1206              #define MAX6675_SCK_PIN SCK_PIN
   1207            #endif
   1208            #ifndef MAX6675_DO_PIN
   1209              #define MAX6675_DO_PIN MISO_PIN
   1210            #endif
   1211            SPI<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
   1212          #endif
   1213          
   1214          /**
   1215           * Initialize the temperature manager
   1216           * The manager is implemented by periodic calls to manage_heater()
   1217           */

   \                                 In section .text, align 2, keep-with-next
   1218          void Temperature::init() {
   \                     _ZN11Temperature4initEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1219          
   1220            #if 0//MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1)
   1221              // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
   1222              MCUCR = _BV(JTD);
   1223              MCUCR = _BV(JTD);
   1224            #endif
   1225            //sean 19.12.30
   1226            #if 1
   1227          	  minttemp_raw[0] = HEATER_0_RAW_LO_TEMP;//ARRAY_BY_HOTENDS( , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP);
   \   00000002   0x....             LDR.N    R4,??DataTable62_5
   1228          	  minttemp_raw[1] = HEATER_1_RAW_LO_TEMP;
   1229          	  maxttemp_raw[0] = HEATER_0_RAW_HI_TEMP;// ARRAY_BY_HOTENDS( , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP);
   1230          	  maxttemp_raw[1] = HEATER_1_RAW_HI_TEMP; 
   1231          
   1232          	  #ifdef BED_MINTEMP
   1233          	  bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
   1234          	  #endif
   1235          
   1236          	  #ifdef BED_MAXTEMP
   1237          	   bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
   1238          	  #endif
   1239            #endif
   1240            // Finish init of mult hotend arrays
   1241            HOTEND_LOOP() maxttemp[e] = maxttemp[0];
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable69_5
   \   00000008   0xF643 0x70FF      MOVW     R0,#+16383
   \   0000000C   0x82A0             STRH     R0,[R4, #+20]
   \   0000000E   0x82E0             STRH     R0,[R4, #+22]
   \   00000010   0x8560             STRH     R0,[R4, #+42]
   \   00000012   0xF105 0x06F0      ADD      R6,R5,#+240
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x79F0             LDRB     R0,[R6, #+7]
   \   0000001A   0x8321             STRH     R1,[R4, #+24]
   \   0000001C   0x8361             STRH     R1,[R4, #+26]
   \   0000001E   0x85A1             STRH     R1,[R4, #+44]
   \   00000020   0xB130             CBZ.N    R0,??init_0
   \   00000022   0xF104 0x0120      ADD      R1,R4,#+32
   \                     ??init_1: (+1)
   \   00000026   0x8C22             LDRH     R2,[R4, #+32]
   \   00000028   0xF821 0x2B02      STRH     R2,[R1], #+2
   \   0000002C   0x1E40             SUBS     R0,R0,#+1
   \   0000002E   0xD1FA             BNE.N    ??init_1
   1242          
   1243            #if 0//ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
   1244              last_e_position = 0;
   1245            #endif
   1246          
   1247            #if HAS_HEATER_0
   1248              SET_OUTPUT(HEATER_0_PIN);
   1249            #endif
   1250            #if HAS_HEATER_1
   1251              SET_OUTPUT(HEATER_1_PIN);
   1252            #endif
   1253            #if HAS_HEATER_2
   1254              SET_OUTPUT(HEATER_2_PIN);
   1255            #endif
   1256            #if HAS_HEATER_3
   1257              SET_OUTPUT(HEATER_3_PIN);
   1258            #endif
   1259            #if HAS_HEATER_4
   1260              SET_OUTPUT(HEATER_3_PIN);
   1261            #endif
   1262            #if HAS_HEATER_BED
   1263              SET_OUTPUT(HEATER_BED_PIN);
   1264            #endif
   1265          
   1266            #if HAS_FAN0
   1267              SET_OUTPUT(FAN_PIN);
   1268              #if ENABLED(FAST_PWM_FAN)
   1269                setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1270              #endif
   1271            #endif
   1272          
   1273            #if HAS_FAN1
   1274              SET_OUTPUT(FAN1_PIN);
   1275              #if ENABLED(FAST_PWM_FAN)
   1276                setPwmFrequency(FAN1_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1277              #endif
   1278            #endif
   1279          
   1280            #if HAS_FAN2
   1281              SET_OUTPUT(FAN2_PIN);
   1282              #if ENABLED(FAST_PWM_FAN)
   1283                setPwmFrequency(FAN2_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1284              #endif
   1285            #endif
   1286          
   1287            #if 0//ENABLED(HEATER_0_USES_MAX6675)
   1288          
   1289              OUT_WRITE(SCK_PIN, LOW);
   1290              OUT_WRITE(MOSI_PIN, HIGH);
   1291              SET_INPUT_PULLUP(MISO_PIN);
   1292          
   1293              max6675_spi.init();
   1294          
   1295              OUT_WRITE(SS_PIN, HIGH);
   1296              OUT_WRITE(MAX6675_SS, HIGH);
   1297          
   1298            #endif // HEATER_0_USES_MAX6675
   1299          
   1300            #ifdef DIDR2
   1301              #define ANALOG_SELECT(pin) do{ if (pin < 8) SBI(DIDR0, pin); else SBI(DIDR2, pin - 8); }while(0)
   1302            #else
   1303              #define ANALOG_SELECT(pin) do{ SBI(DIDR0, pin); }while(0)
   1304            #endif
   1305          #if 0
   1306            // Set analog inputs
   1307            ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
   1308            DIDR0 = 0;
   1309            #ifdef DIDR2
   1310              DIDR2 = 0;
   1311            #endif
   1312            #if HAS_TEMP_0
   1313              ANALOG_SELECT(TEMP_0_PIN);
   1314            #endif
   1315            #if HAS_TEMP_1
   1316              ANALOG_SELECT(TEMP_1_PIN);
   1317            #endif
   1318            #if HAS_TEMP_2
   1319              ANALOG_SELECT(TEMP_2_PIN);
   1320            #endif
   1321            #if HAS_TEMP_3
   1322              ANALOG_SELECT(TEMP_3_PIN);
   1323            #endif
   1324            #if HAS_TEMP_4
   1325              ANALOG_SELECT(TEMP_4_PIN);
   1326            #endif
   1327            #if HAS_TEMP_BED
   1328              ANALOG_SELECT(TEMP_BED_PIN);
   1329            #endif
   1330            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1331              ANALOG_SELECT(FILWIDTH_PIN);
   1332            #endif
   1333          
   1334            #if HAS_AUTO_FAN_0
   1335              #if E0_AUTO_FAN_PIN == FAN1_PIN
   1336                SET_OUTPUT(E0_AUTO_FAN_PIN);
   1337                #if ENABLED(FAST_PWM_FAN)
   1338                  setPwmFrequency(E0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1339                #endif
   1340              #else
   1341                SET_OUTPUT(E0_AUTO_FAN_PIN);
   1342              #endif
   1343            #endif
   1344            #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
   1345              #if E1_AUTO_FAN_PIN == FAN1_PIN
   1346                SET_OUTPUT(E1_AUTO_FAN_PIN);
   1347                #if ENABLED(FAST_PWM_FAN)
   1348                  setPwmFrequency(E1_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1349                #endif
   1350              #else
   1351                SET_OUTPUT(E1_AUTO_FAN_PIN);
   1352              #endif
   1353            #endif
   1354            #if HAS_AUTO_FAN_2 && !AUTO_2_IS_0 && !AUTO_2_IS_1
   1355              #if E2_AUTO_FAN_PIN == FAN1_PIN
   1356                SET_OUTPUT(E2_AUTO_FAN_PIN);
   1357                #if ENABLED(FAST_PWM_FAN)
   1358                  setPwmFrequency(E2_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1359                #endif
   1360              #else
   1361                SET_OUTPUT(E2_AUTO_FAN_PIN);
   1362              #endif
   1363            #endif
   1364            #if HAS_AUTO_FAN_3 && !AUTO_3_IS_0 && !AUTO_3_IS_1 && !AUTO_3_IS_2
   1365              #if E3_AUTO_FAN_PIN == FAN1_PIN
   1366                SET_OUTPUT(E3_AUTO_FAN_PIN);
   1367                #if ENABLED(FAST_PWM_FAN)
   1368                  setPwmFrequency(E3_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1369                #endif
   1370              #else
   1371                SET_OUTPUT(E3_AUTO_FAN_PIN);
   1372              #endif
   1373            #endif
   1374            #if HAS_AUTO_FAN_4 && !AUTO_4_IS_0 && !AUTO_4_IS_1 && !AUTO_4_IS_2 && !AUTO_4_IS_3
   1375              #if E4_AUTO_FAN_PIN == FAN1_PIN
   1376                SET_OUTPUT(E4_AUTO_FAN_PIN);
   1377                #if ENABLED(FAST_PWM_FAN)
   1378                  setPwmFrequency(E4_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1379                #endif
   1380              #else
   1381                SET_OUTPUT(E4_AUTO_FAN_PIN);
   1382              #endif
   1383            #endif
   1384          
   1385            // Use timer0 for temperature measurement
   1386            // Interleave temperature interrupt with millies interrupt
   1387            OCR0B = 128;
   1388            SBI(TIMSK0, OCIE0B);
   1389          
   1390            // Wait for temperature measurement to settle
   1391            delay(250);
   1392          #endif
   1393            #define TEMP_MIN_ROUTINE(NR) \
   1394              minttemp[NR] = HEATER_ ##NR## _MINTEMP; \
   1395              while (analog2temp(minttemp_raw[NR], NR) < HEATER_ ##NR## _MINTEMP) { \
   1396                if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
   1397                  minttemp_raw[NR] += OVERSAMPLENR; \
   1398                else \
   1399                  minttemp_raw[NR] -= OVERSAMPLENR; \
   1400              }
   1401            #define TEMP_MAX_ROUTINE(NR) \
   1402              maxttemp[NR] = HEATER_ ##NR## _MAXTEMP; \
   1403              while (analog2temp(maxttemp_raw[NR], NR) > HEATER_ ##NR## _MAXTEMP) { \
   1404                if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
   1405                  maxttemp_raw[NR] -= OVERSAMPLENR; \
   1406                else \
   1407                  maxttemp_raw[NR] += OVERSAMPLENR; \
   1408              }
   1409          
   1410            #ifdef HEATER_0_MINTEMP
   1411              TEMP_MIN_ROUTINE(0);
   \                     ??init_0: (+1)
   \   00000030   0xF8B5 0x00F0      LDRH     R0,[R5, #+240]
   \   00000034   0x83A0             STRH     R0,[R4, #+28]
   \   00000036   0xE002             B.N      ??init_2
   \                     ??init_3: (+1)
   \   00000038   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000003A   0x3810             SUBS     R0,R0,#+16
   \   0000003C   0x82A0             STRH     R0,[R4, #+20]
   \                     ??init_2: (+1)
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xF9B4 0x0014      LDRSH    R0,[R4, #+20]
   \   00000044   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   00000048   0x4607             MOV      R7,R0
   \   0000004A   0xF9B5 0x00F0      LDRSH    R0,[R5, #+240]
   \   0000004E   0x.... 0x....      BL       __aeabi_i2f
   \   00000052   0x4601             MOV      R1,R0
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000005A   0xD3ED             BCC.N    ??init_3
   1412            #endif
   1413            #ifdef HEATER_0_MAXTEMP
   1414              TEMP_MAX_ROUTINE(0);
   \   0000005C   0x8E28             LDRH     R0,[R5, #+48]
   \   0000005E   0x8420             STRH     R0,[R4, #+32]
   \   00000060   0xE002             B.N      ??init_4
   \                     ??init_5: (+1)
   \   00000062   0x8B20             LDRH     R0,[R4, #+24]
   \   00000064   0x3010             ADDS     R0,R0,#+16
   \   00000066   0x8320             STRH     R0,[R4, #+24]
   \                     ??init_4: (+1)
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0xF9B4 0x0018      LDRSH    R0,[R4, #+24]
   \   0000006E   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   00000072   0x4607             MOV      R7,R0
   \   00000074   0xF9B5 0x0030      LDRSH    R0,[R5, #+48]
   \   00000078   0x.... 0x....      BL       __aeabi_i2f
   \   0000007C   0x4639             MOV      R1,R7
   \   0000007E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000082   0xD3EE             BCC.N    ??init_5
   1415            #endif
   1416            #if HOTENDS > 1
   1417              #ifdef HEATER_1_MINTEMP
   1418                TEMP_MIN_ROUTINE(1);
   \   00000084   0xF996 0x0002      LDRSB    R0,[R6, #+2]
   \   00000088   0x83E0             STRH     R0,[R4, #+30]
   \   0000008A   0xE002             B.N      ??init_6
   \                     ??init_7: (+1)
   \   0000008C   0x8AE0             LDRH     R0,[R4, #+22]
   \   0000008E   0x3810             SUBS     R0,R0,#+16
   \   00000090   0x82E0             STRH     R0,[R4, #+22]
   \                     ??init_6: (+1)
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0xF9B4 0x0016      LDRSH    R0,[R4, #+22]
   \   00000098   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   0000009C   0x4607             MOV      R7,R0
   \   0000009E   0xF996 0x0002      LDRSB    R0,[R6, #+2]
   \   000000A2   0x.... 0x....      BL       __aeabi_i2f
   \   000000A6   0x4601             MOV      R1,R0
   \   000000A8   0x4638             MOV      R0,R7
   \   000000AA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000AE   0xD3ED             BCC.N    ??init_7
   1419              #endif
   1420              #ifdef HEATER_1_MAXTEMP
   1421                TEMP_MAX_ROUTINE(1);
   \   000000B0   0x88B0             LDRH     R0,[R6, #+4]
   \   000000B2   0x8460             STRH     R0,[R4, #+34]
   \   000000B4   0xE002             B.N      ??init_8
   \                     ??init_9: (+1)
   \   000000B6   0x8B60             LDRH     R0,[R4, #+26]
   \   000000B8   0x3010             ADDS     R0,R0,#+16
   \   000000BA   0x8360             STRH     R0,[R4, #+26]
   \                     ??init_8: (+1)
   \   000000BC   0x2101             MOVS     R1,#+1
   \   000000BE   0xF9B4 0x001A      LDRSH    R0,[R4, #+26]
   \   000000C2   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   000000C6   0x4607             MOV      R7,R0
   \   000000C8   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \   000000CC   0x.... 0x....      BL       __aeabi_i2f
   \   000000D0   0x4639             MOV      R1,R7
   \   000000D2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D6   0xD3EE             BCC.N    ??init_9
   1422              #endif
   1423              #if HOTENDS > 2
   1424                #ifdef HEATER_2_MINTEMP
   1425                  TEMP_MIN_ROUTINE(2);
   1426                #endif
   1427                #ifdef HEATER_2_MAXTEMP
   1428                  TEMP_MAX_ROUTINE(2);
   1429                #endif
   1430                #if HOTENDS > 3
   1431                  #ifdef HEATER_3_MINTEMP
   1432                    TEMP_MIN_ROUTINE(3);
   1433                  #endif
   1434                  #ifdef HEATER_3_MAXTEMP
   1435                    TEMP_MAX_ROUTINE(3);
   1436                  #endif
   1437                  #if HOTENDS > 4
   1438                    #ifdef HEATER_4_MINTEMP
   1439                      TEMP_MIN_ROUTINE(4);
   1440                    #endif
   1441                    #ifdef HEATER_4_MAXTEMP
   1442                      TEMP_MAX_ROUTINE(4);
   1443                    #endif
   1444                  #endif // HOTENDS > 4
   1445                #endif // HOTENDS > 3
   1446              #endif // HOTENDS > 2
   1447            #endif // HOTENDS > 1
   1448          
   1449            //#if HAS_TEMP_BED
   1450            if(HAS_TEMP_BED)
   \   000000D8   0x3530             ADDS     R5,R5,#+48
   \   000000DA   0x7A28             LDRB     R0,[R5, #+8]
   \   000000DC   0xB330             CBZ.N    R0,??init_10
   \   000000DE   0xF9B4 0x602A      LDRSH    R6,[R4, #+42]
   \   000000E2   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \   000000E6   0x.... 0x....      BL       __aeabi_i2f
   \   000000EA   0x4607             MOV      R7,R0
   \   000000EC   0xE000             B.N      ??init_11
   1451              {
   1452              #ifdef BED_MINTEMP
   1453                while (analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
   1454                  #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
   1455                    bed_minttemp_raw += OVERSAMPLENR;
   1456                  #else
   1457                    bed_minttemp_raw -= OVERSAMPLENR;
   \                     ??init_12: (+1)
   \   000000EE   0x3E10             SUBS     R6,R6,#+16
   1458                  #endif
   1459                }
   \                     ??init_11: (+1)
   \   000000F0   0xB236             SXTH     R6,R6
   \   000000F2   0x4630             MOV      R0,R6
   \   000000F4   0x.... 0x....      BL       _ZN11Temperature14analog2tempBedEi
   \   000000F8   0x4639             MOV      R1,R7
   \   000000FA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000FE   0xD3F6             BCC.N    ??init_12
   1460              #endif // BED_MINTEMP
   1461              //#ifdef BED_MAXTEMP
   1462              if(BED_MAXTEMP)
   \   00000100   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \   00000104   0x8566             STRH     R6,[R4, #+42]
   \   00000106   0xB918             CBNZ.N   R0,??init_13
   \   00000108   0xBDF1             POP      {R0,R4-R7,PC}
   1463              {
   1464                while (analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
   1465                  #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
   1466                    bed_maxttemp_raw -= OVERSAMPLENR;
   1467                  #else
   1468                    bed_maxttemp_raw += OVERSAMPLENR;
   \                     ??init_14: (+1)
   \   0000010A   0xF106 0x0010      ADD      R0,R6,#+16
   \   0000010E   0x85A0             STRH     R0,[R4, #+44]
   1469                  #endif
   1470                }
   \                     ??init_13: (+1)
   \   00000110   0xF9B4 0x602C      LDRSH    R6,[R4, #+44]
   \   00000114   0x4630             MOV      R0,R6
   \   00000116   0x.... 0x....      BL       _ZN11Temperature14analog2tempBedEi
   \   0000011A   0x4607             MOV      R7,R0
   \   0000011C   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \   00000120   0x.... 0x....      BL       __aeabi_i2f
   \   00000124   0x4639             MOV      R1,R7
   \   00000126   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000012A   0xD3EE             BCC.N    ??init_14
   1471              }
   1472              //#endif // BED_MAXTEMP
   1473              }
   1474            //#endif //HAS_TEMP_BED
   1475          
   1476            #if ENABLED(PROBING_HEATERS_OFF)
   1477              paused = false;
   1478            #endif
   1479          }
   \                     ??init_10: (+1)
   \   0000012C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1480          
   1481          #if WATCH_HOTENDS
   1482            /**
   1483             * Start Heating Sanity Check for hotends that are below
   1484             * their target temperature by a configurable margin.
   1485             * This is called when the temperature is set. (M104, M109)
   1486             */

   \                                 In section .text, align 2, keep-with-next
   1487            void Temperature::start_watching_heater(const uint8_t e) {
   \                     _ZN11Temperature21start_watching_heaterEh: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4680             MOV      R8,R0
   1488              #if HOTENDS == 1
   1489                UNUSED(e);
   1490              #endif
   1491              if (degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable65_1
   \   0000000A   0x.... 0x....      LDR.W    R9,??DataTable69_3
   \   0000000E   0xF105 0x00E4      ADD      R0,R5,#+228
   \   00000012   0xEB09 0x0488      ADD      R4,R9,R8, LSL #+2
   \   00000016   0x7887             LDRB     R7,[R0, #+2]
   \   00000018   0x6C66             LDR      R6,[R4, #+68]
   \   0000001A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000001C   0x.... 0x....      BL       __aeabi_i2f
   \   00000020   0x4682             MOV      R10,R0
   \   00000022   0x1CF8             ADDS     R0,R7,#+3
   \   00000024   0x.... 0x....      BL       __aeabi_i2f
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x4650             MOV      R0,R10
   \   0000002C   0x.... 0x....      BL       __aeabi_fsub
   \   00000030   0x4601             MOV      R1,R0
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000038   0xD213             BCS.N    ??start_watching_heater_0
   1492                watch_target_temp[HOTEND_INDEX] = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
                                                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000003A   0x4638             MOV      R0,R7
   \   0000003C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000040   0x4631             MOV      R1,R6
   \   00000042   0x.... 0x....      BL       __aeabi_fadd
   \   00000046   0x.... 0x....      BL       __aeabi_f2iz
   \   0000004A   0xEB09 0x0148      ADD      R1,R9,R8, LSL #+1
   \   0000004E   0x8608             STRH     R0,[R1, #+48]
   1493                watch_heater_next_ms[HOTEND_INDEX] = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
   \   00000050   0x.... 0x....      BL       HAL_GetTick
   \   00000054   0xF44F 0x727A      MOV      R2,#+1000
   \   00000058   0xF9B5 0x10E4      LDRSH    R1,[R5, #+228]
   \   0000005C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000060   0xE000             B.N      ??start_watching_heater_1
   1494              }
   1495              else
   1496                watch_heater_next_ms[HOTEND_INDEX] = 0;
   \                     ??start_watching_heater_0: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??start_watching_heater_1: (+1)
   \   00000064   0x6720             STR      R0,[R4, #+112]
   1497            }
   \   00000066   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1498          #endif
   1499          
   1500          #if WATCH_THE_BED
   1501            /**
   1502             * Start Heating Sanity Check for hotends that are below
   1503             * their target temperature by a configurable margin.
   1504             * This is called when the temperature is set. (M140, M190)
   1505             */

   \                                 In section .text, align 2, keep-with-next
   1506            void Temperature::start_watching_bed() {
   \                     _ZN11Temperature18start_watching_bedEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1507              if (degBed() < degTargetBed() - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
   \   00000004   0x....             LDR.N    R4,??DataTable65_1
   \   00000006   0x....             LDR.N    R6,??DataTable62_5
   \   00000008   0x6CF7             LDR      R7,[R6, #+76]
   \   0000000A   0xF104 0x00EC      ADD      R0,R4,#+236
   \   0000000E   0x7885             LDRB     R5,[R0, #+2]
   \   00000010   0xF9B6 0x0024      LDRSH    R0,[R6, #+36]
   \   00000014   0x.... 0x....      BL       __aeabi_i2f
   \   00000018   0x4680             MOV      R8,R0
   \   0000001A   0x1CE8             ADDS     R0,R5,#+3
   \   0000001C   0x.... 0x....      BL       __aeabi_i2f
   \   00000020   0x4601             MOV      R1,R0
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x.... 0x....      BL       __aeabi_fsub
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x4638             MOV      R0,R7
   \   0000002C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000030   0xD211             BCS.N    ??start_watching_bed_0
   1508                watch_target_bed_temp = degBed() + WATCH_BED_TEMP_INCREASE;
                                             ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       __aeabi_ui2f
   \   00000038   0x4639             MOV      R1,R7
   \   0000003A   0x.... 0x....      BL       __aeabi_fadd
   \   0000003E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000042   0x84F0             STRH     R0,[R6, #+38]
   1509                watch_bed_next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
   \   00000044   0x.... 0x....      BL       HAL_GetTick
   \   00000048   0xF9B4 0x10EC      LDRSH    R1,[R4, #+236]
   \   0000004C   0xF44F 0x727A      MOV      R2,#+1000
   \   00000050   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000054   0xE000             B.N      ??start_watching_bed_1
   1510              }
   1511              else
   1512                watch_bed_next_ms = 0;
   \                     ??start_watching_bed_0: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??start_watching_bed_1: (+1)
   \   00000058   0x67B0             STR      R0,[R6, #+120]
   1513            }
   \   0000005A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1514          #endif
   1515          
   1516          #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
   1517          
   1518            #if ENABLED(THERMAL_PROTECTION_HOTENDS)
   1519              Temperature::TRState Temperature::thermal_runaway_state_machine[HOTENDS] = { TRInactive };
   1520              millis_t Temperature::thermal_runaway_timer[HOTENDS] = { 0 };
   1521            #endif
   1522          
   1523            #if HAS_THERMALLY_PROTECTED_BED
   1524              Temperature::TRState Temperature::thermal_runaway_bed_state_machine = TRInactive;
   1525              millis_t Temperature::thermal_runaway_bed_timer;
   1526            #endif
   1527          

   \                                 In section .text, align 2, keep-with-next
   1528            void Temperature::thermal_runaway_protection(Temperature::TRState * const state, millis_t * const timer, const float current, const float target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
   \                     _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffatt: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0xF99D 0x9020      LDRSB    R9,[SP, #+32]
   1529          
   1530              static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
   1531          
   1532              /**
   1533                  SERIAL_ECHO_START();
   1534                  SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
   1535                  if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
   1536                  SERIAL_ECHOPAIR(" ;  State:", *state);
   1537                  SERIAL_ECHOPAIR(" ;  Timer:", *timer);
   1538                  SERIAL_ECHOPAIR(" ;  Temperature:", current);
   1539                  SERIAL_ECHOPAIR(" ;  Target Temp:", target);
   1540                  if (heater_id >= 0)
   1541                    SERIAL_ECHOPAIR(" ;  Idle Timeout:", heater_idle_timeout_exceeded[heater_id]);
   1542                  else
   1543                    SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle_timeout_exceeded);
   1544                  SERIAL_EOL();
   1545              */
   1546          
   1547              const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
   \   00000008   0x464F             MOV      R7,R9
   \   0000000A   0x4605             MOV      R5,R0
   \   0000000C   0x460C             MOV      R4,R1
   \   0000000E   0x4616             MOV      R6,R2
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xBF48             IT       MI 
   \   00000014   0x2702             MOVMI    R7,#+2
   1548          
   1549              #if HEATER_IDLE_HANDLER
   1550                // If the heater idle timeout expires, restart
   1551                if (heater_id >= 0 && heater_idle_timeout_exceeded[heater_id]) {
   1552                  *state = TRInactive;
   1553                  tr_target_temperature[heater_index] = 0;
   1554                }
   1555                #if HAS_TEMP_BED
   1556                  else if (heater_id < 0 && bed_idle_timeout_exceeded) {
   1557                    *state = TRInactive;
   1558                    tr_target_temperature[heater_index] = 0;
   1559                  }
   1560                #endif
   1561                else
   1562              #endif
   1563              // If the target temperature changes, restart
   1564              if (tr_target_temperature[heater_index] != target) {
   \   00000016   0x.... 0x....      LDR.W    R8,??DataTable69_7
   \   0000001A   0xF858 0x0027      LDR      R0,[R8, R7, LSL #+2]
   \   0000001E   0x4619             MOV      R1,R3
   \   00000020   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000024   0xD009             BEQ.N    ??thermal_runaway_protection_0
   1565                tr_target_temperature[heater_index] = target;
   1566                *state = target > 0 ? TRFirstHeating : TRInactive;
   \   00000026   0x4618             MOV      R0,R3
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF848 0x3027      STR      R3,[R8, R7, LSL #+2]
   \   0000002E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000032   0xBF34             ITE      CC 
   \   00000034   0x2001             MOVCC    R0,#+1
   \   00000036   0x2000             MOVCS    R0,#+0
   \   00000038   0x7028             STRB     R0,[R5, #+0]
   1567              }
   1568          
   1569              switch (*state) {
   \                     ??thermal_runaway_protection_0: (+1)
   \   0000003A   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD005             BEQ.N    ??thermal_runaway_protection_1
   \   00000042   0xD334             BCC.N    ??thermal_runaway_protection_2
   \   00000044   0x2803             CMP      R0,#+3
   \   00000046   0xD028             BEQ.N    ??thermal_runaway_protection_3
   \   00000048   0xD309             BCC.N    ??thermal_runaway_protection_4
   1570                // Inactive state waits for a target temperature to be set
   1571                case TRInactive: break;
   1572                // When first heating, wait for the temperature to be reached then go to Stable state
   1573                case TRFirstHeating:
   1574                  if (current < tr_target_temperature[heater_index]) break;
   1575                  *state = TRStable;
   1576                // While the temperature is stable watch for a bad temperature
   1577                case TRStable:
   1578                  if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
   1579                    *timer = millis() + period_seconds * 1000UL;
   1580                    break;
   1581                  }
   1582                  else if (PENDING(millis(), *timer)) break;
   1583                  *state = TRRunaway;
   1584                case TRRunaway:
   1585                  _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
   1586                  temper_error_type=7;
   1587              }
   1588            }
   \   0000004A   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
   \                     ??thermal_runaway_protection_1: (+1)
   \   0000004E   0xF858 0x1027      LDR      R1,[R8, R7, LSL #+2]
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000058   0xD329             BCC.N    ??thermal_runaway_protection_2
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x7028             STRB     R0,[R5, #+0]
   \                     ??thermal_runaway_protection_4: (+1)
   \   0000005E   0x980A             LDR      R0,[SP, #+40]
   \   00000060   0x.... 0x....      BL       __aeabi_ui2f
   \   00000064   0x4601             MOV      R1,R0
   \   00000066   0xF858 0x0027      LDR      R0,[R8, R7, LSL #+2]
   \   0000006A   0x.... 0x....      BL       __aeabi_fsub
   \   0000006E   0x4601             MOV      R1,R0
   \   00000070   0x4630             MOV      R0,R6
   \   00000072   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000076   0xD809             BHI.N    ??thermal_runaway_protection_5
   \   00000078   0x.... 0x....      BL       HAL_GetTick
   \   0000007C   0x9909             LDR      R1,[SP, #+36]
   \   0000007E   0xF44F 0x727A      MOV      R2,#+1000
   \   00000082   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000086   0x6020             STR      R0,[R4, #+0]
   \   00000088   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
   \                     ??thermal_runaway_protection_5: (+1)
   \   0000008C   0x.... 0x....      BL       HAL_GetTick
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x1A40             SUBS     R0,R0,R1
   \   00000094   0xD40B             BMI.N    ??thermal_runaway_protection_2
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0x7028             STRB     R0,[R5, #+0]
   \                     ??thermal_runaway_protection_3: (+1)
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0x.... 0x....      ADR.W    R2,`?<Constant "THERMAL RUNAWAY">`
   \   000000A0   0x.... 0x....      ADR.W    R1,`?<Constant "Thermal Runaway">`
   \   000000A4   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   000000A8   0x....             LDR.N    R1,??DataTable63
   \   000000AA   0x2007             MOVS     R0,#+7
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
   \                     ??thermal_runaway_protection_2: (+1)
   \   000000AE   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .bss, align 4
   \                     ??tr_target_temperature:
   \   00000000                      DS8 12
   1589          
   1590          #endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
   1591          

   \                                 In section .text, align 2, keep-with-next
   1592          void Temperature::disable_all_heaters() {
   \                     _ZN11Temperature19disable_all_heatersEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1593          
   1594            #if ENABLED(AUTOTEMP)
   1595              planner.autotemp_enabled = false;
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable69_8
   1596            #endif
   1597          
   1598            HOTEND_LOOP() setTargetHotend(0, e);
   \   00000008   0x.... 0x....      LDR.W    R8,??DataTable65_1
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
   \   00000010   0x2500             MOVS     R5,#+0
   \   00000012   0xE00A             B.N      ??disable_all_heaters_0
   \                     ??disable_all_heaters_1: (+1)
   \   00000014   0xB2ED             UXTB     R5,R5
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable69_3
   \   0000001A   0xEB01 0x0185      ADD      R1,R1,R5, LSL #+2
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x63C8             STR      R0,[R1, #+60]
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       _ZN11Temperature21start_watching_heaterEh
   \   00000028   0x1C6D             ADDS     R5,R5,#+1
   \                     ??disable_all_heaters_0: (+1)
   \   0000002A   0xF898 0x10F7      LDRB     R1,[R8, #+247]
   \   0000002E   0xB268             SXTB     R0,R5
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xDBEF             BLT.N    ??disable_all_heaters_1
   1599            setTargetBed(0);
   \   00000034   0xF9B8 0x0032      LDRSH    R0,[R8, #+50]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xBFA8             IT       GE 
   \   0000003C   0x2000             MOVGE    R0,#+0
   \   0000003E   0x.... 0x....      LDR.W    R5,??DataTable69_3
   \   00000042   0x84A8             STRH     R0,[R5, #+36]
   \   00000044   0x.... 0x....      BL       _ZN11Temperature18start_watching_bedEv
   1600          
   1601            // Unpause and reset everything
   1602            #if ENABLED(PROBING_HEATERS_OFF)
   1603              pause(false);
   1604            #endif
   1605          
   1606            // If all heaters go down then for sure our print job has stopped
   1607            print_job_timer.stop();
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable69_9
   \   0000004C   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   1608          
   1609            #define DISABLE_HEATER(NR) { \
   1610              setTargetHotend(0, NR); \
   1611              soft_pwm_amount[NR] = 0; \
   1612              WRITE_HEATER_ ##NR (LOW); \
   1613            }
   1614          
   1615            #if HAS_TEMP_HOTEND
   1616              DISABLE_HEATER(0);
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x63E8             STR      R0,[R5, #+60]
   \   00000054   0x.... 0x....      BL       _ZN11Temperature21start_watching_heaterEh
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x7028             STRB     R0,[R5, #+0]
   \   0000005C   0x.... 0x....      LDR.W    R4,??DataTable67
   \   00000060   0x.... 0x....      LDR.W    R6,??DataTable67_2
   \   00000064   0x7CE0             LDRB     R0,[R4, #+19]
   \   00000066   0x.... 0x....      LDR.W    R7,??DataTable67_1
   \   0000006A   0xB920             CBNZ.N   R0,??disable_all_heaters_2
   \   0000006C   0x6DB0             LDR      R0,[R6, #+88]
   \   0000006E   0x8DB9             LDRH     R1,[R7, #+44]
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x.... 0x....      BL       HAL_GPIO_WritePin
   1617              #if HOTENDS > 1
   1618                DISABLE_HEATER(1);
   \                     ??disable_all_heaters_2: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x6428             STR      R0,[R5, #+64]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x.... 0x....      BL       _ZN11Temperature21start_watching_heaterEh
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x7068             STRB     R0,[R5, #+1]
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0x8DF9             LDRH     R1,[R7, #+46]
   \   00000088   0x6DF0             LDR      R0,[R6, #+92]
   \   0000008A   0x.... 0x....      BL       HAL_GPIO_WritePin
   1619                #if HOTENDS > 2
   1620                  DISABLE_HEATER(2);
   1621                  #if HOTENDS > 3
   1622                    DISABLE_HEATER(3);
   1623                    #if HOTENDS > 4
   1624                      DISABLE_HEATER(4);
   1625                    #endif // HOTENDS > 4
   1626                  #endif // HOTENDS > 3
   1627                #endif // HOTENDS > 2
   1628              #endif // HOTENDS > 1
   1629            #endif
   1630          
   1631            //#if HAS_TEMP_BED
   1632            if(HAS_TEMP_BED) {
   \   0000008E   0xF898 0x0038      LDRB     R0,[R8, #+56]
   \   00000092   0xB148             CBZ.N    R0,??disable_all_heaters_3
   1633              target_temperature_bed = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x84A8             STRH     R0,[R5, #+36]
   1634              soft_pwm_amount_bed = 0;
   \   00000098   0x70E8             STRB     R0,[R5, #+3]
   1635              #if HAS_HEATER_BED
   1636                WRITE_HEATER_BED(LOW);
   \   0000009A   0x7CE0             LDRB     R0,[R4, #+19]
   \   0000009C   0xB920             CBNZ.N   R0,??disable_all_heaters_3
   \   0000009E   0x8D79             LDRH     R1,[R7, #+42]
   \   000000A0   0x6D70             LDR      R0,[R6, #+84]
   \   000000A2   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000A6   0x....             B.N      ?Subroutine3
   1637              #endif
   1638            	}
   1639            //#endif
   1640          }
   \                     ??disable_all_heaters_3: (+1)
   \   000000A8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1641          
   1642          #if ENABLED(PROBING_HEATERS_OFF)
   1643          
   1644            void Temperature::pause(const bool p) {
   1645              if (p != paused) {
   1646                paused = p;
   1647                if (p) {
   1648                  HOTEND_LOOP() start_heater_idle_timer(e, 0); // timeout immediately
   1649                  //#if HAS_TEMP_BED
   1650          		if(HAS_TEMP_BED) {
   1651                    start_bed_idle_timer(0); // timeout immediately
   1652          		}
   1653                  //#endif
   1654                }
   1655                else {
   1656                  HOTEND_LOOP() reset_heater_idle_timer(e);
   1657                  //#if HAS_TEMP_BED
   1658                  if(HAS_TEMP_BED) {
   1659                    reset_bed_idle_timer();
   1660                  }
   1661                  //#endif
   1662                }
   1663              }
   1664            }
   1665          
   1666          #endif // PROBING_HEATERS_OFF
   1667          
   1668          #if 1//ENABLED(HEATER_0_USES_MAX6675)
   1669          
   1670            #define MAX6675_HEAT_INTERVAL 250u
   1671          
   1672            #if ENABLED(MAX6675_IS_MAX31855)
   1673              uint32_t max6675_temp = 2000;
   1674              #define MAX6675_ERROR_MASK 7
   1675              #define MAX6675_DISCARD_BITS 18
   1676              #define MAX6675_SPEED_BITS (_BV(SPR1)) // clock ÷ 64
   1677            #else
   1678              uint16_t max6675_temp = 2000;
   1679              #define MAX6675_ERROR_MASK 4
   1680              #define MAX6675_DISCARD_BITS 3
   1681              #define MAX6675_SPEED_BITS (_BV(SPR0)) // clock ÷ 16
   1682            #endif
   1683          

   \                                 In section .text, align 4, keep-with-next
   1684            int Temperature::read_max6675() {
   \                     _ZN11Temperature12read_max6675Ev: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1685          
   1686              static millis_t next_max6675_ms = 0;
   1687          
   1688              millis_t ms = millis();
   \   00000002   0x.... 0x....      BL       HAL_GetTick
   1689          
   1690              if (PENDING(ms, next_max6675_ms)) return (int)max6675_temp;
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable69_10
   \   0000000A   0x6861             LDR      R1,[R4, #+4]
   \   0000000C   0x1A41             SUBS     R1,R0,R1
   \   0000000E   0xD471             BMI.N    ??read_max6675_0
   1691          
   1692              next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;
   \   00000010   0x30FA             ADDS     R0,R0,#+250
   \   00000012   0x6060             STR      R0,[R4, #+4]
   1693          #if 0
   1694              CBI(
   1695                #ifdef PRR
   1696                  PRR
   1697                #elif defined(PRR0)
   1698                  PRR0
   1699                #endif
   1700                  , PRSPI);
   1701              SPCR = _BV(MSTR) | _BV(SPE) | MAX6675_SPEED_BITS;
   1702          #endif
   1703              //WRITE(MAX6675_SS, 0); // enable TT_MAX6675
   1704          	TC1_CS_OP = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R5,??DataTable69_11  ;; 0x42230194
   \   0000001A   0x6028             STR      R0,[R5, #+0]
   1705          
   1706              // ensure 100ns delay - a bit extra is fine
   1707              asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   \   0000001C   0xBF00             nop
   1708              asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   \   0000001E   0xBF00             nop
   1709          
   1710              // Read a big-endian temperature value
   1711              max6675_temp = 0;
   \   00000020   0x6020             STR      R0,[R4, #+0]
   1712              for (uint8_t i = sizeof(max6675_temp); i--;) {
   \   00000022   0x2604             MOVS     R6,#+4
   \   00000024   0xE001             B.N      ??read_max6675_1
   1713                //max6675_temp |= max6675_spi.receive();
   1714                max6675_temp |= SPI2_ReadWriteByte(0x00);
   1715                if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
   \                     ??read_max6675_2: (+1)
   \   00000026   0x0208             LSLS     R0,R1,#+8
   \   00000028   0x6020             STR      R0,[R4, #+0]
   \                     ??read_max6675_1: (+1)
   \   0000002A   0x1E76             SUBS     R6,R6,#+1
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       SPI2_ReadWriteByte
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x4301             ORRS     R1,R0,R1
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD1F5             BNE.N    ??read_max6675_2
   \   0000003A   0x6021             STR      R1,[R4, #+0]
   1716              }
   1717          
   1718              //WRITE(MAX6675_SS, 1); // disable TT_MAX6675
   1719          	TC1_CS_OP = 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x6028             STR      R0,[R5, #+0]
   1720          
   1721              if (max6675_temp & MAX6675_ERROR_MASK) {
   \   00000040   0xF011 0x0F07      TST      R1,#0x7
   \   00000044   0xD04D             BEQ.N    ??read_max6675_3
   1722                SERIAL_ERROR_START();
   \   00000046   0x.... 0x....      LDR.W    R6,??DataTable69_12
   \   0000004A   0x.... 0x....      LDR.W    R5,??DataTable66
   \   0000004E   0xE003             B.N      ??read_max6675_4
   \                     ??read_max6675_5: (+1)
   \   00000050   0xB2C9             UXTB     R1,R1
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??read_max6675_4: (+1)
   \   00000058   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   0000005C   0x0008             MOVS     R0,R1
   \   0000005E   0xD1F7             BNE.N    ??read_max6675_5
   1723                SERIAL_ERRORPGM("Temp measurement error! ");
   \   00000060   0x.... 0x....      ADR.W    R6,`?<Constant "Temp measurement error! ">`
   \   00000064   0xE003             B.N      ??read_max6675_6
   \                     ??read_max6675_7: (+1)
   \   00000066   0xB2C9             UXTB     R1,R1
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??read_max6675_6: (+1)
   \   0000006E   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   00000072   0x0008             MOVS     R0,R1
   \   00000074   0xD1F7             BNE.N    ??read_max6675_7
   1724                #if MAX6675_ERROR_MASK == 7
   1725                  SERIAL_ERRORPGM("MAX31855 ");
   \   00000076   0x.... 0x....      ADR.W    R6,`?<Constant "MAX31855 ">`
   \   0000007A   0xE003             B.N      ??read_max6675_8
   \                     ??read_max6675_9: (+1)
   \   0000007C   0xB2C9             UXTB     R1,R1
   \   0000007E   0x4628             MOV      R0,R5
   \   00000080   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??read_max6675_8: (+1)
   \   00000084   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   00000088   0x0008             MOVS     R0,R1
   \   0000008A   0xD1F7             BNE.N    ??read_max6675_9
   1726                  if (max6675_temp & 1)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x07C1             LSLS     R1,R0,#+31
   \   00000090   0xD50A             BPL.N    ??read_max6675_10
   1727                    SERIAL_ERRORLNPGM("Open Circuit");
   \   00000092   0x.... 0x....      ADR.W    R6,`?<Constant "Open Circuit\\n">`
   \                     ??read_max6675_11: (+1)
   \   00000096   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   0000009A   0x0008             MOVS     R0,R1
   \   0000009C   0xD01E             BEQ.N    ??read_max6675_12
   \   0000009E   0xB2C9             UXTB     R1,R1
   \   000000A0   0x4628             MOV      R0,R5
   \   000000A2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000000A6   0xE7F6             B.N      ??read_max6675_11
   1728                  else if (max6675_temp & 2)
   \                     ??read_max6675_10: (+1)
   \   000000A8   0x0781             LSLS     R1,R0,#+30
   \   000000AA   0xD50A             BPL.N    ??read_max6675_13
   1729                    SERIAL_ERRORLNPGM("Short to GND");
   \   000000AC   0x.... 0x....      ADR.W    R6,`?<Constant "Short to GND\\n">`
   \                     ??read_max6675_14: (+1)
   \   000000B0   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   000000B4   0x0008             MOVS     R0,R1
   \   000000B6   0xD011             BEQ.N    ??read_max6675_12
   \   000000B8   0xB2C9             UXTB     R1,R1
   \   000000BA   0x4628             MOV      R0,R5
   \   000000BC   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000000C0   0xE7F6             B.N      ??read_max6675_14
   1730                  else if (max6675_temp & 4)
   \                     ??read_max6675_13: (+1)
   \   000000C2   0x0740             LSLS     R0,R0,#+29
   \   000000C4   0xD50A             BPL.N    ??read_max6675_12
   1731                    SERIAL_ERRORLNPGM("Short to VCC");
   \   000000C6   0x.... 0x....      ADR.W    R6,`?<Constant "Short to VCC\\n">`
   \   000000CA   0xE003             B.N      ??read_max6675_15
   \                     ??read_max6675_16: (+1)
   \   000000CC   0xB2C9             UXTB     R1,R1
   \   000000CE   0x4628             MOV      R0,R5
   \   000000D0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??read_max6675_15: (+1)
   \   000000D4   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   000000D8   0x0008             MOVS     R0,R1
   \   000000DA   0xD1F7             BNE.N    ??read_max6675_16
   1732                #else
   1733                  SERIAL_ERRORLNPGM("MAX6675");
   1734                #endif
   1735                max6675_temp = MAX6675_TMAX * 4; // thermocouple open
   \                     ??read_max6675_12: (+1)
   \   000000DC   0xF44F 0x50E1      MOV      R0,#+7200
   \   000000E0   0xE000             B.N      ??read_max6675_17
   1736              }
   1737              else
   1738                max6675_temp >>= MAX6675_DISCARD_BITS;
   \                     ??read_max6675_3: (+1)
   \   000000E2   0x0C88             LSRS     R0,R1,#+18
   \                     ??read_max6675_17: (+1)
   \   000000E4   0x6020             STR      R0,[R4, #+0]
   1739                #if ENABLED(MAX6675_IS_MAX31855)
   1740                  // Support negative temperature
   1741                  if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000;
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x0481             LSLS     R1,R0,#+18
   \   000000EA   0xD503             BPL.N    ??read_max6675_0
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable69_13  ;; 0xffffc000
   \   000000F0   0x4308             ORRS     R0,R1,R0
   \   000000F2   0x6020             STR      R0,[R4, #+0]
   1742                #endif
   1743          
   1744              return (int)max6675_temp;
   \                     ??read_max6675_0: (+1)
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0xBD70             POP      {R4-R6,PC}       ;; return
   1745            }
   1746          
   1747          #endif // HEATER_0_USES_MAX6675
   1748          
   1749          /**
   1750           * Get raw temperatures
   1751           */

   \                                 In section .text, align 2, keep-with-next
   1752          void Temperature::set_current_temp_raw() {
   1753            //#if HAS_TEMP_0 && DISABLED(HEATER_0_USES_MAX6675)
   1754            if(TEMP_SENSOR_0 == sensors_100k)
   \                     _ZN11Temperature20set_current_temp_rawEv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable67_5
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable69_3
   \   00000008   0xF991 0x10F6      LDRSB    R1,[R1, #+246]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xBF04             ITT      EQ 
   1755              current_temperature_raw[0] = raw_temp_value[0];
   \   00000010   0x8A01             LDRHEQ   R1,[R0, #+16]
   \   00000012   0x6341             STREQ    R1,[R0, #+52]
   1756            //#endif
   1757            #if HAS_TEMP_1
   1758              #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   1759                redundant_temperature_raw = raw_temp_value[1];
   1760              #else
   1761                current_temperature_raw[1] = raw_temp_value[1];
   \   00000014   0x8A41             LDRH     R1,[R0, #+18]
   \   00000016   0x6381             STR      R1,[R0, #+56]
   1762              #endif
   1763              #if HAS_TEMP_2
   1764                current_temperature_raw[2] = raw_temp_value[2];
   1765                #if HAS_TEMP_3
   1766                  current_temperature_raw[3] = raw_temp_value[3];
   1767                  #if HAS_TEMP_4
   1768                    current_temperature_raw[4] = raw_temp_value[4];
   1769                  #endif
   1770                #endif
   1771              #endif
   1772            #endif
   1773            current_temperature_bed_raw = raw_temp_bed_value;
   \   00000018   0x8D01             LDRH     R1,[R0, #+40]
   \   0000001A   0x6501             STR      R1,[R0, #+80]
   1774            temp_meas_ready = true;
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7081             STRB     R1,[R0, #+2]
   1775          }
   \   00000020   0x4770             BX       LR               ;; return
   1776          
   1777          #if ENABLED(PINS_DEBUGGING)
   1778            /**
   1779             * monitors endstops & Z probe for changes
   1780             *
   1781             * If a change is detected then the LED is toggled and
   1782             * a message is sent out the serial port
   1783             *
   1784             * Yes, we could miss a rapid back & forth change but
   1785             * that won't matter because this is all manual.
   1786             *
   1787             */
   1788            void endstop_monitor() {
   1789              static uint16_t old_endstop_bits_local = 0;
   1790              static uint8_t local_LED_status = 0;
   1791              uint16_t current_endstop_bits_local = 0;
   1792              #if HAS_X_MIN	if(mksCfg.use_xmin_plug)
   1793                if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
   1794              #endif
   1795              #if HAS_X_MAX	if(mksCfg.use_xmax_plug)
   1796                if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
   1797              #endif
   1798              #if HAS_Y_MIN	if(mksCfg.use_ymin_plug)
   1799                if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
   1800              #endif
   1801              #if HAS_Y_MAX	if(mksCfg.use_ymax_plug)
   1802                if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
   1803              #endif
   1804              #if HAS_Z_MIN	if(mksCfg.use_zmin_plug)
   1805                if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
   1806              #endif
   1807              #if HAS_Z_MAX
   1808          	if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   1809          	{
   1810          		if(mksCfg.use_zmax_plug)	
   1811                		if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
   1812          	}
   1813              #endif
   1814              #if HAS_Z_MIN_PROBE_PIN
   1815                if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
   1816              #endif
   1817              #if HAS_Z2_MIN
   1818                if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
   1819              #endif
   1820              #if HAS_Z2_MAX
   1821                if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
   1822              #endif
   1823          
   1824              uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
   1825          
   1826              if (endstop_change) {
   1827                #if HAS_X_MIN	if(mksCfg.use_xmin_plug)
   1828                  if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
   1829                #endif
   1830                #if HAS_X_MAX	if(mksCfg.use_xmax_plug)
   1831                  if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
   1832                #endif
   1833                #if HAS_Y_MIN	if(mksCfg.use_ymin_plug)
   1834                  if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
   1835                #endif
   1836                #if HAS_Y_MAX	if(mksCfg.use_ymax_plug)
   1837                  if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
   1838                #endif
   1839                #if HAS_Z_MIN	if(mksCfg.use_zmin_plug)
   1840                  if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
   1841                #endif
   1842                #if HAS_Z_MAX
   1843          	  if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   1844          	  	{
   1845          	 	 	if(mksCfg.use_zmax_plug)	 
   1846          	 	 	{
   1847                  		if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
   1848          	 	 	}
   1849          	  	}
   1850                #endif
   1851                #if HAS_Z_MIN_PROBE_PIN
   1852                  if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
   1853                #endif
   1854                #if HAS_Z2_MIN
   1855                  if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
   1856                #endif
   1857                #if HAS_Z2_MAX
   1858                  if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
   1859                #endif
   1860                SERIAL_PROTOCOLPGM("\n\n");
   1861                analogWrite(LED_PIN, local_LED_status);
   1862                local_LED_status ^= 255;
   1863                old_endstop_bits_local = current_endstop_bits_local;
   1864              }
   1865            }
   1866          #endif // PINS_DEBUGGING
   1867          
   1868          /**
   1869           * Timer 0 is shared with millies so don't change the prescaler.
   1870           *
   1871           * This ISR uses the compare method so it runs at the base
   1872           * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
   1873           * in OCR0B above (128 or halfway between OVFs).
   1874           *
   1875           *  - Manage PWM to all the heaters and fan
   1876           *  - Prepare or Measure one of the raw ADC sensor values
   1877           *  - Check new temperature values for MIN/MAX errors (kill on error)
   1878           *  - Step the babysteps value for each axis towards 0
   1879           *  - For PINS_DEBUGGING, monitor and report endstop pins
   1880           *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
   1881           */
   1882          //ISR(TIMER0_COMPB_vect) { Temperature::isr(); }
   1883          
   1884          volatile bool Temperature::in_temp_isr = false;
   1885          
   1886          //void Temperature::isr() {

   \                                 In section .text, align 2, keep-with-next
   1887            void IsrTemperatureHandler() { Temperature::TemperatureHandler(); }
   \                     IsrTemperatureHandler: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002                      REQUIRE _ZN11Temperature18TemperatureHandlerEv
   \   00000002                      ;; // Fall through to label Temperature::TemperatureHandler()

   \                                 In section .text, align 2, keep-with-next
   1888            void Temperature::TemperatureHandler(void)  {
   \                     _ZN11Temperature18TemperatureHandlerEv: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   1889          
   1890            // The stepper ISR can interrupt this ISR. When it does it re-enables this ISR
   1891            // at the end of its run, potentially causing re-entry. This flag prevents it.
   1892            if (in_temp_isr) return;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable69_3
   \   00000008   0xB085             SUB      SP,SP,#+20
   \   0000000A   0x7960             LDRB     R0,[R4, #+5]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF040 0x81B9      BNE.W    ??TemperatureHandler_0
   1893            in_temp_isr = true;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7160             STRB     R0,[R4, #+5]
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable69_14
   1894          
   1895            // Allow UART and stepper ISRs
   1896            //CBI(TIMSK0, OCIE0B); //Disable Temperature ISR
   1897            //sei();
   1898            HAL_TIM_Base_Stop_IT(&htim4);
   \   0000001A   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   1899          
   1900            static int8_t temp_count = -1;
   1901            static ADCSensorState adc_sensor_state = StartupDelay;
   1902            static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   1903            // avoid multiple loads of pwm_count
   1904            uint8_t pwm_count_tmp = pwm_count;
   \   0000001E   0x7A25             LDRB     R5,[R4, #+8]
   1905            #if ENABLED(ADC_KEYPAD)
   1906              static unsigned int raw_ADCKey_value = 0;
   1907            #endif
   1908          
   1909            // Static members for each heater
   1910            #if ENABLED(SLOW_PWM_HEATERS)
   1911              static uint8_t slow_pwm_count = 0;
   1912              #define ISR_STATICS(n) \
   1913                static uint8_t soft_pwm_count_ ## n, \
   1914                               state_heater_ ## n = 0, \
   1915                               state_timer_heater_ ## n = 0
   1916            #else
   1917              #define ISR_STATICS(n) static uint8_t soft_pwm_count_ ## n = 0
   1918            #endif
   1919          
   1920            // Statics per heater
   1921            ISR_STATICS(0);
   1922            #if HOTENDS > 1
   1923              ISR_STATICS(1);
   1924              #if HOTENDS > 2
   1925                ISR_STATICS(2);
   1926                #if HOTENDS > 3
   1927                  ISR_STATICS(3);
   1928                  #if HOTENDS > 4
   1929                    ISR_STATICS(4);
   1930                  #endif // HOTENDS > 4
   1931                #endif // HOTENDS > 3
   1932              #endif // HOTENDS > 2
   1933            #endif // HOTENDS > 1
   1934            #if HAS_HEATER_BED
   1935              ISR_STATICS(BED);
   1936            #endif
   1937          
   1938            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1939              static unsigned long raw_filwidth_value = 0;
   1940            #endif
   1941          
   1942            #if DISABLED(SLOW_PWM_HEATERS)
   1943              constexpr uint8_t pwm_mask =
   1944                #if ENABLED(SOFT_PWM_DITHER)
   1945                  _BV(SOFT_PWM_SCALE) - 1
   1946                #else
   1947                  0
   1948                #endif
   1949              ;
   1950          
   1951              /**
   1952               * Standard PWM modulation
   1953               */
   1954              if (pwm_count_tmp >= 127) {
   \   00000020   0x2D7F             CMP      R5,#+127
   \   00000022   0xDB2B             BLT.N    ??TemperatureHandler_1
   1955                pwm_count_tmp -= 127;
   1956                soft_pwm_count_0 = (soft_pwm_count_0 & pwm_mask) + soft_pwm_amount[0];
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x7260             STRB     R0,[R4, #+9]
   \   00000028   0x3D7F             SUBS     R5,R5,#+127
   \   0000002A   0xB2ED             UXTB     R5,R5
   1957                //WRITE_HEATER_0(soft_pwm_count_0 > pwm_mask ? HIGH : LOW);
   1958          	  if(soft_pwm_count_0 > pwm_mask) WRITE_HEATER_0(HIGH);
   \   0000002C   0xB160             CBZ.N    R0,??TemperatureHandler_2
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable67
   \   00000032   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000034   0xB940             CBNZ.N   R0,??TemperatureHandler_2
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable67_1
   \   0000003A   0x8D81             LDRH     R1,[R0, #+44]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable67_2
   \   00000040   0x6D80             LDR      R0,[R0, #+88]
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x.... 0x....      BL       HAL_GPIO_WritePin
   1959          	  else WRITE_HEATER_0(LOW);      
   1960                #if HOTENDS > 1
   1961                  soft_pwm_count_1 = (soft_pwm_count_1 & pwm_mask) + soft_pwm_amount[1];
   \                     ??TemperatureHandler_2: (+1)
   \   00000048   0x7860             LDRB     R0,[R4, #+1]
   \   0000004A   0x72A0             STRB     R0,[R4, #+10]
   1962                  WRITE_HEATER_1(soft_pwm_count_1 > pwm_mask ? HIGH : LOW);
   \   0000004C   0xB240             SXTB     R0,R0
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xBFAC             ITE      GE 
   \   00000052   0x2201             MOVGE    R2,#+1
   \   00000054   0x2200             MOVLT    R2,#+0
   \   00000056   0x.... 0x....      LDR.W    R6,??DataTable67_2
   \   0000005A   0x.... 0x....      LDR.W    R7,??DataTable67_1
   \   0000005E   0x6DF0             LDR      R0,[R6, #+92]
   \   00000060   0x8DF9             LDRH     R1,[R7, #+46]
   \   00000062   0x.... 0x....      BL       HAL_GPIO_WritePin
   1963                  #if HOTENDS > 2
   1964                    soft_pwm_count_2 = (soft_pwm_count_2 & pwm_mask) + soft_pwm_amount[2];
   1965                    WRITE_HEATER_2(soft_pwm_count_2 > pwm_mask ? HIGH : LOW);
   1966                    #if HOTENDS > 3
   1967                      soft_pwm_count_3 = (soft_pwm_count_3 & pwm_mask) + soft_pwm_amount[3];
   1968                      WRITE_HEATER_3(soft_pwm_count_3 > pwm_mask ? HIGH : LOW);
   1969                      #if HOTENDS > 4
   1970                        soft_pwm_count_4 = (soft_pwm_count_4 & pwm_mask) + soft_pwm_amount[4];
   1971                        WRITE_HEATER_4(soft_pwm_count_4 > pwm_mask ? HIGH : LOW);
   1972                      #endif // HOTENDS > 4
   1973                    #endif // HOTENDS > 3
   1974                  #endif // HOTENDS > 2
   1975                #endif // HOTENDS > 1
   1976          
   1977                #if HAS_HEATER_BED
   1978                  soft_pwm_count_BED = (soft_pwm_count_BED & pwm_mask) + soft_pwm_amount_bed;
   \   00000066   0x78E0             LDRB     R0,[R4, #+3]
   \   00000068   0x72E0             STRB     R0,[R4, #+11]
   1979                  //WRITE_HEATER_BED(soft_pwm_count_BED > pwm_mask ? HIGH : LOW);
   1980          		if(soft_pwm_count_BED > pwm_mask) WRITE_HEATER_BED(HIGH);
   \   0000006A   0xB370             CBZ.N    R0,??TemperatureHandler_3
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable67
   \   00000070   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000072   0xBB00             CBNZ.N   R0,??TemperatureHandler_4
   \   00000074   0x8D79             LDRH     R1,[R7, #+42]
   \   00000076   0x6D70             LDR      R0,[R6, #+84]
   \   00000078   0x2201             MOVS     R2,#+1
   \   0000007A   0xE024             B.N      ??TemperatureHandler_5
   1981          		else WRITE_HEATER_BED(LOW);        
   1982                #endif
   1983          
   1984                #if ENABLED(FAN_SOFT_PWM)
   1985                  #if HAS_FAN0
   1986                    soft_pwm_count_fan[0] = (soft_pwm_count_fan[0] & pwm_mask) + (soft_pwm_amount_fan[0] >> 1);
   1987                    WRITE_FAN(soft_pwm_count_fan[0] > pwm_mask ? HIGH : LOW);
   1988                  #endif
   1989                  #if HAS_FAN1
   1990                    soft_pwm_count_fan[1] = (soft_pwm_count_fan[1] & pwm_mask) + (soft_pwm_amount_fan[1] >> 1);
   1991                    WRITE_FAN1(soft_pwm_count_fan[1] > pwm_mask ? HIGH : LOW);
   1992                  #endif
   1993                  #if HAS_FAN2
   1994                    soft_pwm_count_fan[2] = (soft_pwm_count_fan[2] & pwm_mask) + (soft_pwm_amount_fan[2] >> 1);
   1995                    WRITE_FAN2(soft_pwm_count_fan[2] > pwm_mask ? HIGH : LOW);
   1996                  #endif
   1997                #endif
   1998              }
   1999              else {
   2000                if (soft_pwm_count_0 <= pwm_count_tmp) WRITE_HEATER_0(LOW);
   \                     ??TemperatureHandler_1: (+1)
   \   0000007C   0x7A60             LDRB     R0,[R4, #+9]
   \   0000007E   0x4285             CMP      R5,R0
   \   00000080   0xDB0C             BLT.N    ??TemperatureHandler_6
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable67
   \   00000086   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000088   0xB940             CBNZ.N   R0,??TemperatureHandler_6
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable67_1
   \   0000008E   0x8D81             LDRH     R1,[R0, #+44]
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable67_2
   \   00000094   0x6D80             LDR      R0,[R0, #+88]
   \   00000096   0x2200             MOVS     R2,#+0
   \   00000098   0x.... 0x....      BL       HAL_GPIO_WritePin
   2001                #if HOTENDS > 1
   2002                  if (soft_pwm_count_1 <= pwm_count_tmp) WRITE_HEATER_1(LOW);
   \                     ??TemperatureHandler_6: (+1)
   \   0000009C   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000009E   0x4285             CMP      R5,R0
   \   000000A0   0xDB06             BLT.N    ??TemperatureHandler_7
   \   000000A2   0x....             LDR.N    R0,??DataTable67_1
   \   000000A4   0x8DC1             LDRH     R1,[R0, #+46]
   \   000000A6   0x....             LDR.N    R0,??DataTable67_2
   \   000000A8   0x6DC0             LDR      R0,[R0, #+92]
   \   000000AA   0x2200             MOVS     R2,#+0
   \   000000AC   0x.... 0x....      BL       HAL_GPIO_WritePin
   2003                  #if HOTENDS > 2
   2004                    if (soft_pwm_count_2 <= pwm_count_tmp) WRITE_HEATER_2(LOW);
   2005                    #if HOTENDS > 3
   2006                      if (soft_pwm_count_3 <= pwm_count_tmp) WRITE_HEATER_3(LOW);
   2007                      #if HOTENDS > 4
   2008                        if (soft_pwm_count_4 <= pwm_count_tmp) WRITE_HEATER_4(LOW);
   2009                      #endif // HOTENDS > 4
   2010                    #endif // HOTENDS > 3
   2011                  #endif // HOTENDS > 2
   2012                #endif // HOTENDS > 1
   2013          
   2014                #if HAS_HEATER_BED
   2015                  if (soft_pwm_count_BED <= pwm_count_tmp) WRITE_HEATER_BED(LOW);
   \                     ??TemperatureHandler_7: (+1)
   \   000000B0   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000B2   0x4285             CMP      R5,R0
   \   000000B4   0xDB09             BLT.N    ??TemperatureHandler_3
   \                     ??TemperatureHandler_4: (+1)
   \   000000B6   0x....             LDR.N    R0,??DataTable67
   \   000000B8   0x7CC0             LDRB     R0,[R0, #+19]
   \   000000BA   0xB930             CBNZ.N   R0,??TemperatureHandler_3
   \   000000BC   0x....             LDR.N    R0,??DataTable67_1
   \   000000BE   0x8D41             LDRH     R1,[R0, #+42]
   \   000000C0   0x....             LDR.N    R0,??DataTable67_2
   \   000000C2   0x6D40             LDR      R0,[R0, #+84]
   \   000000C4   0x2200             MOVS     R2,#+0
   \                     ??TemperatureHandler_5: (+1)
   \   000000C6   0x.... 0x....      BL       HAL_GPIO_WritePin
   2016                #endif
   2017          
   2018                #if ENABLED(FAN_SOFT_PWM)
   2019                  #if HAS_FAN0
   2020                    if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
   2021                  #endif
   2022                  #if HAS_FAN1
   2023                    if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
   2024                  #endif
   2025                  #if HAS_FAN2
   2026                    if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
   2027                  #endif
   2028                #endif
   2029              }
   2030          
   2031              // SOFT_PWM_SCALE to frequency:
   2032              //
   2033              // 0: 16000000/64/256/128 =   7.6294 Hz
   2034              // 1:                / 64 =  15.2588 Hz
   2035              // 2:                / 32 =  30.5176 Hz
   2036              // 3:                / 16 =  61.0352 Hz
   2037              // 4:                /  8 = 122.0703 Hz
   2038              // 5:                /  4 = 244.1406 Hz
   2039              pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
   \                     ??TemperatureHandler_3: (+1)
   \   000000CA   0x1C68             ADDS     R0,R5,#+1
   \   000000CC   0x7220             STRB     R0,[R4, #+8]
   2040          
   2041            #else // SLOW_PWM_HEATERS
   2042          
   2043              /**
   2044               * SLOW PWM HEATERS
   2045               *
   2046               * For relay-driven heaters
   2047               */
   2048              #ifndef MIN_STATE_TIME
   2049                #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
   2050              #endif
   2051          
   2052              // Macros for Slow PWM timer logic
   2053              #define _SLOW_PWM_ROUTINE(NR, src) \
   2054                soft_pwm_count_ ##NR = src; \
   2055                if (soft_pwm_count_ ##NR > 0) { \
   2056                  if (state_timer_heater_ ##NR == 0) { \
   2057                    if (state_heater_ ##NR == 0) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   2058                    state_heater_ ##NR = 1; \
   2059                    WRITE_HEATER_ ##NR(1); \
   2060                  } \
   2061                } \
   2062                else { \
   2063                  if (state_timer_heater_ ##NR == 0) { \
   2064                    if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   2065                    state_heater_ ##NR = 0; \
   2066                    WRITE_HEATER_ ##NR(0); \
   2067                  } \
   2068                }
   2069              #define SLOW_PWM_ROUTINE(n) _SLOW_PWM_ROUTINE(n, soft_pwm_amount[n])
   2070          
   2071              #define PWM_OFF_ROUTINE(NR) \
   2072                if (soft_pwm_count_ ##NR < slow_pwm_count) { \
   2073                  if (state_timer_heater_ ##NR == 0) { \
   2074                    if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   2075                    state_heater_ ##NR = 0; \
   2076                    WRITE_HEATER_ ##NR (0); \
   2077                  } \
   2078                }
   2079          
   2080              if (slow_pwm_count == 0) {
   2081          
   2082                SLOW_PWM_ROUTINE(0);
   2083                #if HOTENDS > 1
   2084                  SLOW_PWM_ROUTINE(1);
   2085                  #if HOTENDS > 2
   2086                    SLOW_PWM_ROUTINE(2);
   2087                    #if HOTENDS > 3
   2088                      SLOW_PWM_ROUTINE(3);
   2089                      #if HOTENDS > 4
   2090                        SLOW_PWM_ROUTINE(4);
   2091                      #endif // HOTENDS > 4
   2092                    #endif // HOTENDS > 3
   2093                  #endif // HOTENDS > 2
   2094                #endif // HOTENDS > 1
   2095                #if HAS_HEATER_BED
   2096                  _SLOW_PWM_ROUTINE(BED, soft_pwm_amount_bed); // BED
   2097                #endif
   2098          
   2099              } // slow_pwm_count == 0
   2100          
   2101              PWM_OFF_ROUTINE(0);
   2102              #if HOTENDS > 1
   2103                PWM_OFF_ROUTINE(1);
   2104                #if HOTENDS > 2
   2105                  PWM_OFF_ROUTINE(2);
   2106                  #if HOTENDS > 3
   2107                    PWM_OFF_ROUTINE(3);
   2108                    #if HOTENDS > 4
   2109                      PWM_OFF_ROUTINE(4);
   2110                    #endif // HOTENDS > 4
   2111                  #endif // HOTENDS > 3
   2112                #endif // HOTENDS > 2
   2113              #endif // HOTENDS > 1
   2114              #if HAS_HEATER_BED
   2115                PWM_OFF_ROUTINE(BED); // BED
   2116              #endif
   2117          
   2118              #if ENABLED(FAN_SOFT_PWM)
   2119                if (pwm_count_tmp >= 127) {
   2120                  pwm_count_tmp = 0;
   2121                  #if HAS_FAN0
   2122                    soft_pwm_count_fan[0] = soft_pwm_amount_fan[0] >> 1;
   2123                    WRITE_FAN(soft_pwm_count_fan[0] > 0 ? HIGH : LOW);
   2124                  #endif
   2125                  #if HAS_FAN1
   2126                    soft_pwm_count_fan[1] = soft_pwm_amount_fan[1] >> 1;
   2127                    WRITE_FAN1(soft_pwm_count_fan[1] > 0 ? HIGH : LOW);
   2128                  #endif
   2129                  #if HAS_FAN2
   2130                    soft_pwm_count_fan[2] = soft_pwm_amount_fan[2] >> 1;
   2131                    WRITE_FAN2(soft_pwm_count_fan[2] > 0 ? HIGH : LOW);
   2132                  #endif
   2133                }
   2134                #if HAS_FAN0
   2135                  if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
   2136                #endif
   2137                #if HAS_FAN1
   2138                  if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
   2139                #endif
   2140                #if HAS_FAN2
   2141                  if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
   2142                #endif
   2143              #endif // FAN_SOFT_PWM
   2144          
   2145              // SOFT_PWM_SCALE to frequency:
   2146              //
   2147              // 0: 16000000/64/256/128 =   7.6294 Hz
   2148              // 1:                / 64 =  15.2588 Hz
   2149              // 2:                / 32 =  30.5176 Hz
   2150              // 3:                / 16 =  61.0352 Hz
   2151              // 4:                /  8 = 122.0703 Hz
   2152              // 5:                /  4 = 244.1406 Hz
   2153              pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
   2154          
   2155              // increment slow_pwm_count only every 64th pwm_count,
   2156              // i.e. yielding a PWM frequency of 16/128 Hz (8s).
   2157              if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
   2158                slow_pwm_count++;
   2159                slow_pwm_count &= 0x7F;
   2160          
   2161                if (state_timer_heater_0 > 0) state_timer_heater_0--;
   2162                #if HOTENDS > 1
   2163                  if (state_timer_heater_1 > 0) state_timer_heater_1--;
   2164                  #if HOTENDS > 2
   2165                    if (state_timer_heater_2 > 0) state_timer_heater_2--;
   2166                    #if HOTENDS > 3
   2167                      if (state_timer_heater_3 > 0) state_timer_heater_3--;
   2168                      #if HOTENDS > 4
   2169                        if (state_timer_heater_4 > 0) state_timer_heater_4--;
   2170                      #endif // HOTENDS > 4
   2171                    #endif // HOTENDS > 3
   2172                  #endif // HOTENDS > 2
   2173                #endif // HOTENDS > 1
   2174                #if HAS_HEATER_BED
   2175                  if (state_timer_heater_BED > 0) state_timer_heater_BED--;
   2176                #endif
   2177              } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
   2178          
   2179            #endif // SLOW_PWM_HEATERS
   2180          
   2181            //
   2182            // Update lcd buttons 488 times per second
   2183            //
   2184            static bool do_buttons;
   2185            if ((do_buttons ^= true)) lcd_buttons_update();
   \   000000CE   0x7B20             LDRB     R0,[R4, #+12]
   \   000000D0   0xF080 0x0001      EOR      R0,R0,#0x1
   \   000000D4   0x1E40             SUBS     R0,R0,#+1
   \   000000D6   0x4180             SBCS     R0,R0,R0
   \   000000D8   0x43C0             MVNS     R0,R0
   \   000000DA   0x0FC0             LSRS     R0,R0,#+31
   \   000000DC   0x7320             STRB     R0,[R4, #+12]
   2186          
   2187            /**
   2188             * One sensor is sampled on every other call of the ISR.
   2189             * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
   2190             *
   2191             * On each Prepare pass, ADC is started for a sensor pin.
   2192             * On the next pass, the ADC value is read and accumulated.
   2193             *
   2194             * This gives each ADC 0.9765ms to charge up.
   2195             */
   2196          #if 0
   2197            #define SET_ADMUX_ADCSRA(pin) ADMUX = _BV(REFS0) | (pin & 0x07); SBI(ADCSRA, ADSC)
   2198            #ifdef MUX5
   2199              #define START_ADC(pin) if (pin > 7) ADCSRB = _BV(MUX5); else ADCSRB = 0; SET_ADMUX_ADCSRA(pin)
   2200            #else
   2201              #define START_ADC(pin) ADCSRB = 0; SET_ADMUX_ADCSRA(pin)
   2202            #endif
   2203          #endif
   2204            switch (adc_sensor_state) {
   \   000000DE   0xF994 0x0007      LDRSB    R0,[R4, #+7]
   \   000000E2   0x2801             CMP      R0,#+1
   \   000000E4   0xD013             BEQ.N    ??TemperatureHandler_8
   \   000000E6   0x2803             CMP      R0,#+3
   \   000000E8   0xD021             BEQ.N    ??TemperatureHandler_9
   \   000000EA   0x2805             CMP      R0,#+5
   \   000000EC   0xD017             BEQ.N    ??TemperatureHandler_10
   \   000000EE   0x2806             CMP      R0,#+6
   \   000000F0   0xD12C             BNE.N    ??TemperatureHandler_11
   2205          
   2206              case SensorsReady: {
   2207                // All sensors have been read. Stay in this state for a few
   2208                // ISRs to save on calls to temp update/checking code below.
   2209                constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
   2210                static uint8_t delay_count = 0;
   2211                if (extra_loops > 0) {
   2212                  if (delay_count == 0) delay_count = extra_loops;   // Init this delay
   \   000000F2   0x7B60             LDRB     R0,[R4, #+13]
   \   000000F4   0xB908             CBNZ.N   R0,??TemperatureHandler_12
   \   000000F6   0x2004             MOVS     R0,#+4
   \   000000F8   0x7360             STRB     R0,[R4, #+13]
   2213                  if (--delay_count)                                 // While delaying...
   \                     ??TemperatureHandler_12: (+1)
   \   000000FA   0x7B60             LDRB     R0,[R4, #+13]
   \   000000FC   0x1E40             SUBS     R0,R0,#+1
   \   000000FE   0x7360             STRB     R0,[R4, #+13]
   \   00000100   0xB2C0             UXTB     R0,R0
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xF000 0x811C      BEQ.W    ??TemperatureHandler_13
   2214                    adc_sensor_state = (ADCSensorState)(int(SensorsReady) - 1); // retain this state (else, next state will be 0)
   \   00000108   0x2005             MOVS     R0,#+5
   \   0000010A   0x71E0             STRB     R0,[R4, #+7]
   \   0000010C   0xE118             B.N      ??TemperatureHandler_13
   2215                  break;
   2216                }
   2217                else
   2218                  adc_sensor_state = (ADCSensorState)0; // Fall-through to start first sensor now
   2219              }
   2220          
   2221              #if HAS_TEMP_0
   2222                case PrepareTemp_0:
   2223                  //START_ADC(TEMP_0_PIN);
   2224                  break;
   2225                case MeasureTemp_0:
   2226          		#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)|| defined(MKS_ROBIN_NANO)
   2227          			raw_temp_value[0] += uhADCxConvertedValue[1]>>2;	//TH1
   \                     ??TemperatureHandler_8: (+1)
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable69_15
   \   00000112   0x8A20             LDRH     R0,[R4, #+16]
   \   00000114   0x8849             LDRH     R1,[R1, #+2]
   \   00000116   0xEB00 0x0091      ADD      R0,R0,R1, LSR #+2
   \   0000011A   0x8220             STRH     R0,[R4, #+16]
   2228          		#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2229          			raw_temp_value[0] += uhADCxConvertedValue[1];   	//TH1
   2230          		#endif 
   2231          
   2232                  break;
   \   0000011C   0xE110             B.N      ??TemperatureHandler_13
   2233              #endif
   2234          
   2235              #if 1//HAS_TEMP_BED
   2236                case PrepareTemp_BED:
   2237                  //START_ADC(TEMP_BED_PIN);
   2238                  break;
   2239                case MeasureTemp_BED:
   2240          			#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)|| defined(MKS_ROBIN_NANO)
   2241          				raw_temp_bed_value += uhADCxConvertedValue[0]>>2;	//TB
   \                     ??TemperatureHandler_10: (+1)
   \   0000011E   0x.... 0x....      LDR.W    R1,??DataTable69_15
   \   00000122   0x8D20             LDRH     R0,[R4, #+40]
   \   00000124   0x8809             LDRH     R1,[R1, #+0]
   \   00000126   0xEB00 0x0091      ADD      R0,R0,R1, LSR #+2
   \   0000012A   0x8520             STRH     R0,[R4, #+40]
   2242          			#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2243          				raw_temp_bed_value += uhADCxConvertedValue[0];	//TB
   2244          			#endif 		
   2245                  break;
   \   0000012C   0xE108             B.N      ??TemperatureHandler_13
   2246              #endif
   2247          
   2248              #if HAS_TEMP_1
   2249                case PrepareTemp_1:
   2250                  //START_ADC(TEMP_1_PIN);
   2251                  break;
   2252                case MeasureTemp_1:
   2253          		#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)|| defined(MKS_ROBIN_NANO)
   2254          			
   2255          			if(gCfgItems.singleNozzle == 1)
   \                     ??TemperatureHandler_9: (+1)
   \   0000012E   0x8A60             LDRH     R0,[R4, #+18]
   \   00000130   0x.... 0x....      LDR.W    R2,??DataTable69_16
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable69_15
   \   00000138   0xF892 0x22B2      LDRB     R2,[R2, #+690]
   \   0000013C   0x2A01             CMP      R2,#+1
   \   0000013E   0xBF0C             ITE      EQ 
   2256          				raw_temp_value[1] += uhADCxConvertedValue[1]>>2;		//TH2
   \   00000140   0x8849             LDRHEQ   R1,[R1, #+2]
   2257          			else
   2258          				raw_temp_value[1] += uhADCxConvertedValue[2]>>2;		//TH2
   \   00000142   0x8889             LDRHNE   R1,[R1, #+4]
   \   00000144   0xEB00 0x0091      ADD      R0,R0,R1, LSR #+2
   \   00000148   0x8260             STRH     R0,[R4, #+18]
   \   0000014A   0xE0F9             B.N      ??TemperatureHandler_13
   2259          		#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2260          			raw_temp_value[1] += uhADCxConvertedValue[2];   //TH2
   2261          		#endif 
   2262          
   2263                  break;
   2264              #endif
   2265          
   2266              #if HAS_TEMP_2
   2267                case PrepareTemp_2:
   2268                  START_ADC(TEMP_2_PIN);
   2269                  break;
   2270                case MeasureTemp_2:
   2271                  raw_temp_value[2] += ADC;
   2272                  break;
   2273              #endif
   2274          
   2275              #if HAS_TEMP_3
   2276                case PrepareTemp_3:
   2277                  START_ADC(TEMP_3_PIN);
   2278                  break;
   2279                case MeasureTemp_3:
   2280                  raw_temp_value[3] += ADC;
   2281                  break;
   2282              #endif
   2283          
   2284              #if HAS_TEMP_4
   2285                case PrepareTemp_4:
   2286                  START_ADC(TEMP_4_PIN);
   2287                  break;
   2288                case MeasureTemp_4:
   2289                  raw_temp_value[4] += ADC;
   2290                  break;
   2291              #endif
   2292          
   2293              #if ENABLED(FILAMENT_WIDTH_SENSOR)
   2294                case Prepare_FILWIDTH:
   2295                  START_ADC(FILWIDTH_PIN);
   2296                break;
   2297                case Measure_FILWIDTH:
   2298                  if (ADC > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
   2299                    raw_filwidth_value -= (raw_filwidth_value >> 7); // Subtract 1/128th of the raw_filwidth_value
   2300                    raw_filwidth_value += ((unsigned long)ADC << 7); // Add new ADC reading, scaled by 128
   2301                  }
   2302                break;
   2303              #endif
   2304          
   2305              #if ENABLED(ADC_KEYPAD)
   2306                case Prepare_ADC_KEY:
   2307                  START_ADC(ADC_KEYPAD_PIN);
   2308                  break;
   2309                case Measure_ADC_KEY:
   2310                  if (ADCKey_count < 16) {
   2311                    raw_ADCKey_value = ADC;
   2312                    if (raw_ADCKey_value > 900) {
   2313                      //ADC Key release
   2314                      ADCKey_count = 0;
   2315                      current_ADCKey_raw = 0;
   2316                    }
   2317                    else {
   2318                      current_ADCKey_raw += raw_ADCKey_value;
   2319                      ADCKey_count++;
   2320                    }
   2321                  }
   2322                  break;
   2323              #endif // ADC_KEYPAD
   2324          
   2325              case StartupDelay: break;
   2326          
   2327            } // switch(adc_sensor_state)
   2328          
   2329            if (!adc_sensor_state && ++temp_count >= OVERSAMPLENR) { // 10 * 16 * 1/(16000000/64/256)  = 164ms.
   \                     ??TemperatureHandler_11: (+1)
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xF040 0x80F7      BNE.W    ??TemperatureHandler_13
   \   00000152   0x79A0             LDRB     R0,[R4, #+6]
   \   00000154   0x1C40             ADDS     R0,R0,#+1
   \   00000156   0x71A0             STRB     R0,[R4, #+6]
   \   00000158   0xB240             SXTB     R0,R0
   \   0000015A   0x2810             CMP      R0,#+16
   \   0000015C   0xF2C0 0x80F0      BLT.W    ??TemperatureHandler_13
   2330          
   2331              temp_count = 0;
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x71A0             STRB     R0,[R4, #+6]
   2332          
   2333              // Update the raw values if they've been read. Else we could be updating them during reading.
   2334              if (!temp_meas_ready) set_current_temp_raw();
   \   00000164   0x78A0             LDRB     R0,[R4, #+2]
   \   00000166   0xB908             CBNZ.N   R0,??TemperatureHandler_14
   \   00000168   0x.... 0x....      BL       _ZN11Temperature20set_current_temp_rawEv
   2335          
   2336              // Filament Sensor - can be read any time since IIR filtering is used
   2337              #if ENABLED(FILAMENT_WIDTH_SENSOR)
   2338                current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   2339              #endif
   2340          
   2341              ZERO(raw_temp_value);
   2342              raw_temp_bed_value = 0;
   2343          
   2344              #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
   2345          #if 0
   2346              int constexpr temp_dir[] = {
   2347                #if ENABLED(HEATER_0_USES_MAX6675)
   2348                   0
   2349                #else
   2350                  TEMPDIR(0)
   2351                #endif
   2352                #if HOTENDS > 1
   2353                  , TEMPDIR(1)
   2354                  #if HOTENDS > 2
   2355                    , TEMPDIR(2)
   2356                    #if HOTENDS > 3
   2357                      , TEMPDIR(3)
   2358                      #if HOTENDS > 4
   2359                        , TEMPDIR(4)
   2360                      #endif // HOTENDS > 4
   2361                    #endif // HOTENDS > 3
   2362                  #endif // HOTENDS > 2
   2363                #endif // HOTENDS > 1
   2364              };
   2365          #endif
   2366          	int  temp_dir[2];
   2367          	if(TEMP_SENSOR_0 == sensors_MAX31855)
   \                     ??TemperatureHandler_14: (+1)
   \   0000016C   0x....             LDR.N    R2,??DataTable67_5
   \   0000016E   0xF992 0x20F6      LDRSB    R2,[R2, #+246]
   \   00000172   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000176   0x2100             MOVS     R1,#+0
   \   00000178   0x6001             STR      R1,[R0, #+0]
   \   0000017A   0x8521             STRH     R1,[R4, #+40]
   \   0000017C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000180   0xA903             ADD      R1,SP,#+12
   \   00000182   0xF112 0x0F03      CMN      R2,#+3
   \   00000186   0xBF06             ITTE     EQ 
   2368          		{
   2369          		temp_dir[0]=0;
   \   00000188   0x2200             MOVEQ    R2,#+0
   \   0000018A   0x9203             STREQ    R2,[SP, #+12]
   2370          		temp_dir[1]=TEMPDIR(1);       //mks_TC
   2371          		}
   2372          	else
   2373          		{
   2374          		temp_dir[0]=TEMPDIR(0);
   \   0000018C   0x9003             STRNE    R0,[SP, #+12]
   2375          		temp_dir[1]=TEMPDIR(1);       //mks_TC
   \   0000018E   0x6048             STR      R0,[R1, #+4]
   2376          		}
   2377          	
   2378          
   2379              for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
   \   00000190   0x2500             MOVS     R5,#+0
   \   00000192   0x9401             STR      R4,[SP, #+4]
   \   00000194   0xF104 0x0618      ADD      R6,R4,#+24
   \   00000198   0xF104 0x0714      ADD      R7,R4,#+20
   \   0000019C   0xF10D 0x080C      ADD      R8,SP,#+12
   \   000001A0   0xF104 0x0934      ADD      R9,R4,#+52
   \   000001A4   0xF104 0x0A3C      ADD      R10,R4,#+60
   2380                const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
   \                     ??TemperatureHandler_15: (+1)
   \   000001A8   0xF9B8 0x0000      LDRSH    R0,[R8, #+0]
   \   000001AC   0x9000             STR      R0,[SP, #+0]
   \   000001AE   0x9900             LDR      R1,[SP, #+0]
   \   000001B0   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000001B4   0x4348             MULS     R0,R1,R0
   \   000001B6   0xB200             SXTH     R0,R0
   \   000001B8   0x9002             STR      R0,[SP, #+8]
   2381                //const 
   2382                 bool heater_on; //= 0 <
   2383                  /*
   2384                  #if ENABLED(PIDTEMP)
   2385                    soft_pwm_amount[e]
   2386                  #else
   2387                    target_temperature[e]
   2388                  #endif
   2389                ;
   2390                */
   2391                if(PIDTEMP)
   \   000001BA   0x....             LDR.N    R0,??DataTable67_5
   \   000001BC   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   000001C0   0xB150             CBZ.N    R0,??TemperatureHandler_16
   2392                  heater_on = 0 < soft_pwm_amount[e];
   \   000001C2   0x9801             LDR      R0,[SP, #+4]
   \   000001C4   0x7800             LDRB     R0,[R0, #+0]
   \   000001C6   0xF1B0 0x0B01      SUBS     R11,R0,#+1
   \   000001CA   0xEB6B 0x0B0B      SBC      R11,R11,R11
   \   000001CE   0xEA6F 0x000B      MVN      R0,R11
   \   000001D2   0xEA4F 0x7BD0      LSR      R11,R0,#+31
   \   000001D6   0xE007             B.N      ??TemperatureHandler_17
   2393                else
   2394                  heater_on = 0 < target_temperature[e];
   \                     ??TemperatureHandler_16: (+1)
   \   000001D8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000001DC   0x2801             CMP      R0,#+1
   \   000001DE   0xBFAC             ITE      GE 
   \   000001E0   0xF04F 0x0B01      MOVGE    R11,#+1
   \   000001E4   0xF04F 0x0B00      MOVLT    R11,#+0
   2395                
   2396                //if (rawtemp > maxttemp_raw[e] * tdir && heater_on) max_temp_error(e);
   2397                if (rawtemp > maxttemp_raw[e] * tdir && loop_start) max_temp_error(e);
   \                     ??TemperatureHandler_17: (+1)
   \   000001E8   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   000001EC   0x9900             LDR      R1,[SP, #+0]
   \   000001EE   0x4348             MULS     R0,R1,R0
   \   000001F0   0x9902             LDR      R1,[SP, #+8]
   \   000001F2   0x4288             CMP      R0,R1
   \   000001F4   0xDA0E             BGE.N    ??TemperatureHandler_18
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable69_17
   \   000001FA   0x7800             LDRB     R0,[R0, #+0]
   \   000001FC   0xB150             CBZ.N    R0,??TemperatureHandler_18
   \   000001FE   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MAXTEMP">`
   \   00000202   0x.... 0x....      ADR.W    R1,`?<Constant "MAXTEMP triggered">`
   \   00000206   0xB268             SXTB     R0,R5
   \   00000208   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   0000020C   0x.... 0x....      LDR.W    R1,??DataTable69_18
   \   00000210   0x2002             MOVS     R0,#+2
   \   00000212   0x7008             STRB     R0,[R1, #+0]
   2398                if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && heater_on) {
   \                     ??TemperatureHandler_18: (+1)
   \   00000214   0xF9B7 0x1000      LDRSH    R1,[R7, #+0]
   \   00000218   0x9A00             LDR      R2,[SP, #+0]
   \   0000021A   0x9802             LDR      R0,[SP, #+8]
   \   0000021C   0x4351             MULS     R1,R2,R1
   \   0000021E   0x4288             CMP      R0,R1
   \   00000220   0xDA05             BGE.N    ??TemperatureHandler_19
   \   00000222   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000226   0xBF1C             ITT      NE 
   2399                  #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   2400                    if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
   2401                  #endif
   2402                      min_temp_error(e);
   \   00000228   0xB268             SXTBNE   R0,R5
   \   0000022A   0x.... 0x....      BLNE     _ZN11Temperature14min_temp_errorEa
   2403                }
   2404                #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   2405                  else
   2406                    consecutive_low_temperature_error[e] = 0;
   2407                #endif
   2408              }
   \                     ??TemperatureHandler_19: (+1)
   \   0000022E   0x9801             LDR      R0,[SP, #+4]
   \   00000230   0x1C6D             ADDS     R5,R5,#+1
   \   00000232   0x1CBF             ADDS     R7,R7,#+2
   \   00000234   0x1CB6             ADDS     R6,R6,#+2
   \   00000236   0x1C40             ADDS     R0,R0,#+1
   \   00000238   0xF10A 0x0A04      ADD      R10,R10,#+4
   \   0000023C   0xF109 0x0904      ADD      R9,R9,#+4
   \   00000240   0xF108 0x0804      ADD      R8,R8,#+4
   \   00000244   0x9001             STR      R0,[SP, #+4]
   \   00000246   0x2D02             CMP      R5,#+2
   \   00000248   0xD3AE             BCC.N    ??TemperatureHandler_15
   2409          
   2410              #if 1//HAS_TEMP_BED
   2411                #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
   2412                  #define GEBED <=
   2413                #else
   2414                  #define GEBED >=
   2415                #endif
   2416                //const 
   2417                bool bed_on;// = 0 <
   2418                /*
   2419                  #if ENABLED(PIDTEMPBED)
   2420                    soft_pwm_amount_bed
   2421                  #else
   2422                    target_temperature_bed
   2423                  #endif
   2424                ;
   2425                */
   2426                if(PIDTEMPBED)
   \   0000024A   0x.... 0x....      LDR.W    R5,??DataTable69_19
   \   0000024E   0x7868             LDRB     R0,[R5, #+1]
   \   00000250   0xB128             CBZ.N    R0,??TemperatureHandler_20
   2427                  bed_on = 0 < soft_pwm_amount_bed;
   \   00000252   0x78E0             LDRB     R0,[R4, #+3]
   \   00000254   0x1E46             SUBS     R6,R0,#+1
   \   00000256   0x41B6             SBCS     R6,R6,R6
   \   00000258   0x43F6             MVNS     R6,R6
   \   0000025A   0x0FF6             LSRS     R6,R6,#+31
   \   0000025C   0xE005             B.N      ??TemperatureHandler_21
   2428                else
   2429                  bed_on = 0 < target_temperature_bed;
   \                     ??TemperatureHandler_20: (+1)
   \   0000025E   0xF9B4 0x0024      LDRSH    R0,[R4, #+36]
   \   00000262   0x2801             CMP      R0,#+1
   \   00000264   0xBFAC             ITE      GE 
   \   00000266   0x2601             MOVGE    R6,#+1
   \   00000268   0x2600             MOVLT    R6,#+0
   2430                
   2431                //if (current_temperature_bed_raw GEBED bed_maxttemp_raw && bed_on) max_temp_error(-1);
   2432                if (current_temperature_bed_raw GEBED bed_maxttemp_raw && loop_start) max_temp_error(-1);
   \                     ??TemperatureHandler_21: (+1)
   \   0000026A   0xF9B4 0x002C      LDRSH    R0,[R4, #+44]
   \   0000026E   0x6D21             LDR      R1,[R4, #+80]
   \   00000270   0x4288             CMP      R0,R1
   \   00000272   0xDB4F             BLT.N    ??TemperatureHandler_22
   \   00000274   0x.... 0x....      LDR.W    R0,??DataTable69_17
   \   00000278   0x7800             LDRB     R0,[R0, #+0]
   \   0000027A   0x2800             CMP      R0,#+0
   \   0000027C   0xD04A             BEQ.N    ??TemperatureHandler_22
   \   0000027E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000280   0x2800             CMP      R0,#+0
   \   00000282   0xD03C             BEQ.N    ??TemperatureHandler_23
   \   00000284   0x.... 0x....      LDR.W    R7,??DataTable69_20
   \   00000288   0x7838             LDRB     R0,[R7, #+0]
   \   0000028A   0xB368             CBZ.N    R0,??TemperatureHandler_24
   \   0000028C   0x.... 0x....      LDR.W    R9,??DataTable69_12
   \   00000290   0x.... 0x....      LDR.W    R8,??DataTable67_6
   \   00000294   0xE003             B.N      ??TemperatureHandler_25
   \                     ??TemperatureHandler_26: (+1)
   \   00000296   0xB2C9             UXTB     R1,R1
   \   00000298   0x4640             MOV      R0,R8
   \   0000029A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??TemperatureHandler_25: (+1)
   \   0000029E   0xF919 0x1B01      LDRSB    R1,[R9], #+1
   \   000002A2   0x0008             MOVS     R0,R1
   \   000002A4   0xD1F7             BNE.N    ??TemperatureHandler_26
   \   000002A6   0x.... 0x....      ADR.W    R9,`?<Constant "MAXTEMP triggered">`
   \   000002AA   0xE003             B.N      ??TemperatureHandler_27
   \                     ??TemperatureHandler_28: (+1)
   \   000002AC   0xB2C9             UXTB     R1,R1
   \   000002AE   0x4640             MOV      R0,R8
   \   000002B0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??TemperatureHandler_27: (+1)
   \   000002B4   0xF919 0x1B01      LDRSB    R1,[R9], #+1
   \   000002B8   0x0008             MOVS     R0,R1
   \   000002BA   0xD1F7             BNE.N    ??TemperatureHandler_28
   \   000002BC   0x.... 0x....      ADR.W    R9,`?<Constant ", system stopped! Hea...">`
   \   000002C0   0xE003             B.N      ??TemperatureHandler_29
   \                     ??TemperatureHandler_30: (+1)
   \   000002C2   0xB2C9             UXTB     R1,R1
   \   000002C4   0x4640             MOV      R0,R8
   \   000002C6   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??TemperatureHandler_29: (+1)
   \   000002CA   0xF919 0x1B01      LDRSB    R1,[R9], #+1
   \   000002CE   0x0008             MOVS     R0,R1
   \   000002D0   0xD1F7             BNE.N    ??TemperatureHandler_30
   \   000002D2   0x.... 0x....      ADR.W    R9,`?<Constant "bed\\n">`
   \   000002D6   0xE003             B.N      ??TemperatureHandler_31
   \                     ??TemperatureHandler_32: (+1)
   \   000002D8   0xB2C9             UXTB     R1,R1
   \   000002DA   0x4640             MOV      R0,R8
   \   000002DC   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??TemperatureHandler_31: (+1)
   \   000002E0   0xF919 0x1B01      LDRSB    R1,[R9], #+1
   \   000002E4   0x0008             MOVS     R0,R1
   \   000002E6   0xD1F7             BNE.N    ??TemperatureHandler_32
   \                     ??TemperatureHandler_24: (+1)
   \   000002E8   0x7920             LDRB     R0,[R4, #+4]
   \   000002EA   0xB928             CBNZ.N   R0,??TemperatureHandler_33
   \   000002EC   0x7038             STRB     R0,[R7, #+0]
   \   000002EE   0x2001             MOVS     R0,#+1
   \   000002F0   0x7120             STRB     R0,[R4, #+4]
   \   000002F2   0x.... 0x....      BL       _Z17temper_error_killv
   \   000002F6   0xE00A             B.N      ??TemperatureHandler_34
   \                     ??TemperatureHandler_33: (+1)
   \   000002F8   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
   \   000002FC   0xE007             B.N      ??TemperatureHandler_34
   \                     ??TemperatureHandler_23: (+1)
   \   000002FE   0xF04F 0x30FF      MOV      R0,#-1
   \   00000302   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MAXTEMP">`
   \   00000306   0x.... 0x....      ADR.W    R1,`?<Constant "MAXTEMP triggered">`
   \   0000030A   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \                     ??TemperatureHandler_34: (+1)
   \   0000030E   0x....             LDR.N    R1,??DataTable69_18
   \   00000310   0x2001             MOVS     R0,#+1
   \   00000312   0x7008             STRB     R0,[R1, #+0]
   2433                if (bed_minttemp_raw GEBED current_temperature_bed_raw && bed_on) min_temp_error(-1);
   \                     ??TemperatureHandler_22: (+1)
   \   00000314   0x6D20             LDR      R0,[R4, #+80]
   \   00000316   0xF9B4 0x102A      LDRSH    R1,[R4, #+42]
   \   0000031A   0x4288             CMP      R0,R1
   \   0000031C   0xDB10             BLT.N    ??TemperatureHandler_13
   \   0000031E   0xB17E             CBZ.N    R6,??TemperatureHandler_13
   \   00000320   0x78A8             LDRB     R0,[R5, #+2]
   \   00000322   0x.... 0x....      ADR.W    R1,`?<Constant "MINTEMP triggered">`
   \   00000326   0x2800             CMP      R0,#+0
   \   00000328   0xBF14             ITE      NE 
   \   0000032A   0x.... 0x....      ADRNE.W  R2,`?<Constant "Err: MINTEMP BED">`
   \   0000032E   0x.... 0x....      ADREQ.W  R2,`?<Constant "Err: MINTEMP">`
   \   00000332   0xF04F 0x30FF      MOV      R0,#-1
   \   00000336   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   0000033A   0x....             LDR.N    R1,??DataTable69_18
   \   0000033C   0x2003             MOVS     R0,#+3
   \   0000033E   0x7008             STRB     R0,[R1, #+0]
   2434              #endif
   2435          
   2436            } // temp_count >= OVERSAMPLENR
   2437          
   2438            // Go to the next state, up to SensorsReady
   2439            adc_sensor_state = (ADCSensorState)(int(adc_sensor_state) + 1);
   \                     ??TemperatureHandler_13: (+1)
   \   00000340   0x79E0             LDRB     R0,[R4, #+7]
   \   00000342   0x1C40             ADDS     R0,R0,#+1
   2440            if (adc_sensor_state > SensorsReady) adc_sensor_state = (ADCSensorState)0;
   \   00000344   0xB240             SXTB     R0,R0
   \   00000346   0x2807             CMP      R0,#+7
   \   00000348   0xBFA8             IT       GE 
   \   0000034A   0x2000             MOVGE    R0,#+0
   \   0000034C   0x71E0             STRB     R0,[R4, #+7]
   2441          
   2442            #if ENABLED(BABYSTEPPING)
   2443              LOOP_XYZ(axis) {
   \   0000034E   0x2500             MOVS     R5,#+0
   \   00000350   0xF104 0x0664      ADD      R6,R4,#+100
   2444                const int curTodo = babystepsTodo[axis]; // get rid of volatile for performance
   \                     ??TemperatureHandler_35: (+1)
   \   00000354   0x6837             LDR      R7,[R6, #+0]
   2445                if (curTodo) {
   \   00000356   0xB167             CBZ.N    R7,??TemperatureHandler_36
   2446                  stepper.babystep((AxisEnum)axis, curTodo > 0);
   \   00000358   0x2F01             CMP      R7,#+1
   \   0000035A   0xBFAC             ITE      GE 
   \   0000035C   0x2101             MOVGE    R1,#+1
   \   0000035E   0x2100             MOVLT    R1,#+0
   \   00000360   0xB268             SXTB     R0,R5
   \   00000362   0x.... 0x....      BL       _ZN7Stepper8babystepE8AxisEnumb
   2447                  if (curTodo > 0) babystepsTodo[axis]--;
   \   00000366   0x6830             LDR      R0,[R6, #+0]
   \   00000368   0x2F01             CMP      R7,#+1
   \   0000036A   0xBFAC             ITE      GE 
   \   0000036C   0x1E40             SUBGE    R0,R0,#+1
   2448                              else babystepsTodo[axis]++;
   \   0000036E   0x1C40             ADDLT    R0,R0,#+1
   \   00000370   0x6030             STR      R0,[R6, #+0]
   2449                }
   2450              }
   \                     ??TemperatureHandler_36: (+1)
   \   00000372   0x1C6D             ADDS     R5,R5,#+1
   \   00000374   0x1D36             ADDS     R6,R6,#+4
   \   00000376   0x2D03             CMP      R5,#+3
   \   00000378   0xDBEC             BLT.N    ??TemperatureHandler_35
   2451            #endif // BABYSTEPPING
   2452          
   2453            #if ENABLED(PINS_DEBUGGING)
   2454              extern bool endstop_monitor_flag;
   2455              // run the endstop monitor at 15Hz
   2456              static uint8_t endstop_monitor_count = 16;  // offset this check from the others
   2457              if (endstop_monitor_flag) {
   2458                endstop_monitor_count += _BV(1);  //  15 Hz
   2459                endstop_monitor_count &= 0x7F;
   2460                if (!endstop_monitor_count) endstop_monitor();  // report changes in endstop status
   2461              }
   2462            #endif
   2463          
   2464            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   2465          
   2466              extern volatile uint8_t e_hit;
   2467          
   2468              if (e_hit && ENDSTOPS_ENABLED) {
   2469                endstops.update();  // call endstop update routine
   2470                e_hit--;
   2471              }
   2472            #endif
   2473          
   2474            //cli();
   2475            in_temp_isr = false;
   \   0000037A   0x2000             MOVS     R0,#+0
   \   0000037C   0x7160             STRB     R0,[R4, #+5]
   2476            //SBI(TIMSK0, OCIE0B); //re-enable Temperature ISR
   2477            HAL_TIM_Base_Start_IT(&htim4);
   \   0000037E   0x....             LDR.N    R0,??DataTable69_14
   \   00000380   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   2478          }
   \                     ??TemperatureHandler_0: (+1)
   \   00000384   0xB005             ADD      SP,SP,#+20
   \   00000386   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .data, align 4
   \                     _ZN11Temperature15soft_pwm_amountE:
   \   00000000   0x00 0x00          DC8 0, 0
   \                     _ZN11Temperature15temp_meas_readyE:
   \   00000002   0x00               DC8 0
   \                     _ZN11Temperature19soft_pwm_amount_bedE:
   \   00000003   0x00               DC8 0
   \   00000004   0x00               DC8 0
   \                     _ZN11Temperature11in_temp_isrE:
   \   00000005   0x00               DC8 0
   \   00000006   0xFF               DC8 -1
   \   00000007   0x07               DC8 7
   \   00000008   0x01               DC8 1
   \   00000009   0x00               DC8 0
   \   0000000A   0x00               DC8 0
   \   0000000B   0x00               DC8 0
   \   0000000C   0x00               DC8 0
   \   0000000D   0x00               DC8 0
   \   0000000E   0x00 0x00          DC8 0, 0
   \                     _ZN11Temperature14raw_temp_valueE:
   \   00000010   0x0000 0x0000      DC16 0, 0
   \                     _ZN11Temperature12minttemp_rawE:
   \   00000014   0x3FFF 0x3FFF      DC16 16383, 16383
   \                     _ZN11Temperature12maxttemp_rawE:
   \   00000018   0x0000 0x0000      DC16 0, 0
   \                     _ZN11Temperature8minttempE:
   \   0000001C   0x0000 0x0000      DC16 0, 0
   \                     _ZN11Temperature8maxttempE:
   \   00000020   0x3FFF 0x3FFF      DC16 16383, 16383
   \                     _ZN11Temperature22target_temperature_bedE:
   \   00000024   0x0000             DC16 0
   \                     _ZN11Temperature21watch_target_bed_tempE:
   \   00000026   0x0000             DC16 0
   \                     _ZN11Temperature18raw_temp_bed_valueE:
   \   00000028   0x0000             DC16 0
   \                     _ZN11Temperature16bed_minttemp_rawE:
   \   0000002A   0x3FFF             DC16 16383
   \                     _ZN11Temperature16bed_maxttemp_rawE:
   \   0000002C   0x0000             DC16 0
   \   0000002E   0x00 0x00          DC8 0, 0
   \                     _ZN11Temperature17watch_target_tempE:
   \   00000030   0x0000 0x0000      DC16 0, 0
   \                     _ZN11Temperature23current_temperature_rawE:
   \   00000034   0x00000000         DC32 0, 0
   \              0x00000000   
   \                     _ZN11Temperature18target_temperatureE:
   \   0000003C   0x00000000         DC32 0, 0
   \              0x00000000   
   \                     _ZN11Temperature19current_temperatureE:
   \   00000044   0x00000000         DC32 0H
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature23current_temperature_bedE:
   \   0000004C   0x00000000         DC32 0H
   \                     _ZN11Temperature27current_temperature_bed_rawE:
   \   00000050   0x00000000         DC32 0
   \                     _ZN11Temperature2KpE:
   \   00000054   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature2KiE:
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature2KdE:
   \   0000005C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature5bedKpE:
   \   00000060   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature13babystepsTodoE:
   \   00000064   0x00000000         DC32 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \                     _ZN11Temperature20watch_heater_next_msE:
   \   00000070   0x00000000         DC32 0, 0
   \              0x00000000   
   \                     _ZN11Temperature17watch_bed_next_msE:
   \   00000078   0x00000000         DC32 0
   \                     _ZN11Temperature17next_bed_check_msE:
   \   0000007C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000080   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature33thermal_runaway_bed_state_machineE:
   \   00000084   0x00               DC8 0
   \   00000085   0x00               DC8 0
   \                     _ZN11Temperature29thermal_runaway_state_machineE:
   \   00000086   0x00 0x00          DC8 0, 0
   \                     _ZN11Temperature21thermal_runaway_timerE:
   \   00000088   0x00000000         DC32 0, 0
   \              0x00000000   
   \                     _ZN11Temperature25thermal_runaway_bed_timerE:
   \   00000090   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     max6675_temp:
   \   00000000   0x000007D0         DC32 2000
   \   00000004   0x00000000         DC32 0
   2479          
   2480          #if 1//HAS_TEMP_HOTEND || HAS_TEMP_BED
   2481          

   \                                 In section .text, align 2, keep-with-next
   2482            void print_heater_state(const float &c, const float &t,
   2483              #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2484                const float r,
   2485              #endif
   2486              const int8_t e=-2
   2487            ) {
   \                     _Z18print_heater_stateRKfS0_a: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
   2488              //#if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
   2489              // UNUSED(e);
   2490              //#endif
   2491              if(!(HAS_TEMP_BED))
   2492              {
   2493                  #if !(HAS_TEMP_HOTEND) && HOTENDS <= 1
   2494                  UNUSED(e);
   2495                  #endif
   2496              }
   2497              
   2498              SERIAL_PROTOCOLCHAR(' ');
   \   00000006   0x....             LDR.N    R5,??DataTable67_6
   \   00000008   0xB083             SUB      SP,SP,#+12
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x2120             MOVS     R1,#+32
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2499              /*
   2500              SERIAL_PROTOCOLCHAR(
   2501                #if HAS_TEMP_BED && HAS_TEMP_HOTEND
   2502                  e == -1 ? 'B' : 'T'
   2503                #elif HAS_TEMP_HOTEND
   2504                  'T'
   2505                #else
   2506                  'B'
   2507                #endif
   2508                );
   2509                */
   2510                #if HAS_TEMP_HOTEND
   2511                    if(HAS_TEMP_BED)
   \   00000014   0x....             LDR.N    R0,??DataTable67_5
   \   00000016   0xF890 0x0038      LDRB     R0,[R0, #+56]
   \   0000001A   0xB128             CBZ.N    R0,??print_heater_state_0
   2512                      SERIAL_PROTOCOLCHAR(e == -1 ? 'B' : 'T');
   \   0000001C   0xF117 0x0F01      CMN      R7,#+1
   \   00000020   0xBF14             ITE      NE 
   \   00000022   0x2154             MOVNE    R1,#+84
   \   00000024   0x2142             MOVEQ    R1,#+66
   \   00000026   0xE000             B.N      ??print_heater_state_1
   2513                    else
   2514                    {
   2515                      SERIAL_PROTOCOLCHAR('T');
   \                     ??print_heater_state_0: (+1)
   \   00000028   0x2154             MOVS     R1,#+84
   \                     ??print_heater_state_1: (+1)
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2516                    }
   2517                #else
   2518                    SERIAL_PROTOCOLCHAR('B');
   2519                #endif
   2520              
   2521              #if HOTENDS > 1
   2522                if (e >= 0) SERIAL_PROTOCOLCHAR('0' + e);
   \   00000030   0x2F00             CMP      R7,#+0
   \   00000032   0xD405             BMI.N    ??print_heater_state_2
   \   00000034   0xF107 0x0130      ADD      R1,R7,#+48
   \   00000038   0xB2C9             UXTB     R1,R1
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2523              #endif
   2524              SERIAL_PROTOCOLCHAR(':');
   \                     ??print_heater_state_2: (+1)
   \   00000040   0x213A             MOVS     R1,#+58
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2525              SERIAL_PROTOCOL(c);
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0x6830             LDR      R0,[R6, #+0]
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x4602             MOV      R2,R0
   \   00000054   0x460B             MOV      R3,R1
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       _ZN5Print5printEdi
   2526              SERIAL_PROTOCOLPAIR(" /" , t);
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0xB003             ADD      SP,SP,#+12
   \   00000060   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000064   0x....             ADR.N    R0,??DataTable69_1  ;; 0x20, 0x2F, 0x00, 0x00
   \   00000066   0x.... 0x....      B.W      _Z17serial_echopair_PPKcf
   2527              #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2528                SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
   2529                SERIAL_PROTOCOLCHAR(')');
   2530              #endif
   2531            }
   2532          
   2533            extern uint8_t target_extruder;
   2534          

   \                                 In section .text, align 2, keep-with-next
   2535            void Temperature::print_heaterstates() {
   \                     _ZN11Temperature18print_heaterstatesEv: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x....             LDR.N    R0,??DataTable69_21
   \   00000006   0x....             LDR.N    R4,??DataTable69_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000000E   0xB082             SUB      SP,SP,#+8
   \   00000010   0x6C47             LDR      R7,[R0, #+68]
   2536              #if HAS_TEMP_HOTEND
   2537                print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
   2538                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2539                    , rawHotendTemp(target_extruder)
   2540                  #endif
   2541                );
   \   00000012   0x6BC0             LDR      R0,[R0, #+60]
   \   00000014   0x.... 0x....      BL       __aeabi_i2f
   \   00000018   0x.... 0x....      LDR.W    R9,??DataTable69_22
   \   0000001C   0x4606             MOV      R6,R0
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x4648             MOV      R0,R9
   \   00000022   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000026   0x.... 0x....      LDR.W    R8,??DataTable69_5
   \   0000002A   0x2154             MOVS     R1,#+84
   \   0000002C   0x4648             MOV      R0,R9
   \   0000002E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000032   0x213A             MOVS     R1,#+58
   \   00000034   0x4648             MOV      R0,R9
   \   00000036   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0x4638             MOV      R0,R7
   \   00000040   0x.... 0x....      BL       __aeabi_f2d
   \   00000044   0x4602             MOV      R2,R0
   \   00000046   0x460B             MOV      R3,R1
   \   00000048   0x4648             MOV      R0,R9
   \   0000004A   0x.... 0x....      BL       _ZN5Print5printEdi
   \   0000004E   0x....             ADR.N    R5,??DataTable69_1  ;; 0x20, 0x2F, 0x00, 0x00
   \   00000050   0x4631             MOV      R1,R6
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   2542              #endif
   2543              //#if HAS_TEMP_BED
   2544              if(HAS_TEMP_BED)
   \   00000058   0xF898 0x0038      LDRB     R0,[R8, #+56]
   \   0000005C   0xB320             CBZ.N    R0,??print_heaterstates_0
   2545              {
   2546                print_heater_state(degBed(), degTargetBed()
   2547                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2548                    , rawBedTemp()
   2549                  #endif
   2550                  , -1 // BED
   2551                );
   \   0000005E   0x6CE7             LDR      R7,[R4, #+76]
   \   00000060   0xF9B4 0x0024      LDRSH    R0,[R4, #+36]
   \   00000064   0x.... 0x....      BL       __aeabi_i2f
   \   00000068   0x4606             MOV      R6,R0
   \   0000006A   0x2120             MOVS     R1,#+32
   \   0000006C   0x4648             MOV      R0,R9
   \   0000006E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000072   0xF898 0x0038      LDRB     R0,[R8, #+56]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xBF14             ITE      NE 
   \   0000007A   0x2142             MOVNE    R1,#+66
   \   0000007C   0x2154             MOVEQ    R1,#+84
   \   0000007E   0x4648             MOV      R0,R9
   \   00000080   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000084   0x213A             MOVS     R1,#+58
   \   00000086   0x4648             MOV      R0,R9
   \   00000088   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000008C   0x2002             MOVS     R0,#+2
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x4638             MOV      R0,R7
   \   00000092   0x.... 0x....      BL       __aeabi_f2d
   \   00000096   0x4602             MOV      R2,R0
   \   00000098   0x460B             MOV      R3,R1
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0x.... 0x....      BL       _ZN5Print5printEdi
   \   000000A0   0x4631             MOV      R1,R6
   \   000000A2   0x4628             MOV      R0,R5
   \   000000A4   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   2552              }
   2553              //#endif
   2554              #if HOTENDS > 1
   2555                HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
   \                     ??print_heaterstates_0: (+1)
   \   000000A8   0x2600             MOVS     R6,#+0
   \   000000AA   0xE01E             B.N      ??print_heaterstates_1
   \                     ??print_heaterstates_2: (+1)
   \   000000AC   0x2154             MOVS     R1,#+84
   \                     ??print_heaterstates_3: (+1)
   \   000000AE   0x4648             MOV      R0,R9
   \   000000B0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000000B4   0x2E00             CMP      R6,#+0
   \   000000B6   0xD405             BMI.N    ??print_heaterstates_4
   \   000000B8   0xF106 0x0130      ADD      R1,R6,#+48
   \   000000BC   0xB2C9             UXTB     R1,R1
   \   000000BE   0x4648             MOV      R0,R9
   \   000000C0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??print_heaterstates_4: (+1)
   \   000000C4   0x213A             MOVS     R1,#+58
   \   000000C6   0x4648             MOV      R0,R9
   \   000000C8   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000000CC   0x2002             MOVS     R0,#+2
   \   000000CE   0x9000             STR      R0,[SP, #+0]
   \   000000D0   0x4650             MOV      R0,R10
   \   000000D2   0x.... 0x....      BL       __aeabi_f2d
   \   000000D6   0x4602             MOV      R2,R0
   \   000000D8   0x460B             MOV      R3,R1
   \   000000DA   0x4648             MOV      R0,R9
   \   000000DC   0x.... 0x....      BL       _ZN5Print5printEdi
   \   000000E0   0x4639             MOV      R1,R7
   \   000000E2   0x4628             MOV      R0,R5
   \   000000E4   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   2556                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2557                    , rawHotendTemp(e)
   2558                  #endif
   2559                  , e
   2560                );
   \   000000E8   0x1C76             ADDS     R6,R6,#+1
   \                     ??print_heaterstates_1: (+1)
   \   000000EA   0xF898 0x10F7      LDRB     R1,[R8, #+247]
   \   000000EE   0xB270             SXTB     R0,R6
   \   000000F0   0x4288             CMP      R0,R1
   \   000000F2   0xDA17             BGE.N    ??print_heaterstates_5
   \   000000F4   0xB2F0             UXTB     R0,R6
   \   000000F6   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000000FA   0xF8D0 0xA044      LDR      R10,[R0, #+68]
   \   000000FE   0x6BC0             LDR      R0,[R0, #+60]
   \   00000100   0x.... 0x....      BL       __aeabi_i2f
   \   00000104   0x4607             MOV      R7,R0
   \   00000106   0x2120             MOVS     R1,#+32
   \   00000108   0x4648             MOV      R0,R9
   \   0000010A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000010E   0xF898 0x0038      LDRB     R0,[R8, #+56]
   \   00000112   0xB276             SXTB     R6,R6
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD0C9             BEQ.N    ??print_heaterstates_2
   \   00000118   0xF116 0x0F01      CMN      R6,#+1
   \   0000011C   0xBF14             ITE      NE 
   \   0000011E   0x2154             MOVNE    R1,#+84
   \   00000120   0x2142             MOVEQ    R1,#+66
   \   00000122   0xE7C4             B.N      ??print_heaterstates_3
   2561              #endif
   2562              SERIAL_PROTOCOLPGM(" @:");
   \                     ??print_heaterstates_5: (+1)
   \   00000124   0x....             ADR.N    R6,??DataTable69_4  ;; " @:"
   \   00000126   0xE003             B.N      ??print_heaterstates_6
   \                     ??print_heaterstates_7: (+1)
   \   00000128   0xB2C9             UXTB     R1,R1
   \   0000012A   0x4648             MOV      R0,R9
   \   0000012C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??print_heaterstates_6: (+1)
   \   00000130   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   00000134   0x0008             MOVS     R0,R1
   \   00000136   0xD1F7             BNE.N    ??print_heaterstates_7
   2563              SERIAL_PROTOCOL(getHeaterPower(target_extruder));
   \   00000138   0x....             LDR.N    R0,??DataTable69_21
   \   0000013A   0x7800             LDRB     R0,[R0, #+0]
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xBF4C             ITE      MI 
   \   00000140   0x78E1             LDRBMI   R1,[R4, #+3]
   \   00000142   0x5D01             LDRBPL   R1,[R0, R4]
   \   00000144   0x220A             MOVS     R2,#+10
   \   00000146   0x4648             MOV      R0,R9
   \   00000148   0x.... 0x....      BL       _ZN5Print5printEii
   2564              //#if HAS_TEMP_BED
   2565              if(HAS_TEMP_BED)
   \   0000014C   0xF898 0x0038      LDRB     R0,[R8, #+56]
   \   00000150   0xB178             CBZ.N    R0,??print_heaterstates_8
   2566              {
   2567                SERIAL_PROTOCOLPGM(" B@:");
   \   00000152   0x.... 0x....      ADR.W    R6,`?<Constant " B@:">`
   \   00000156   0xE003             B.N      ??print_heaterstates_9
   \                     ??print_heaterstates_10: (+1)
   \   00000158   0xB2C9             UXTB     R1,R1
   \   0000015A   0x4648             MOV      R0,R9
   \   0000015C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??print_heaterstates_9: (+1)
   \   00000160   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   00000164   0x0008             MOVS     R0,R1
   \   00000166   0xD1F7             BNE.N    ??print_heaterstates_10
   2568                SERIAL_PROTOCOL(getHeaterPower(-1));
   2569              }
   \   00000168   0x78E1             LDRB     R1,[R4, #+3]
   \   0000016A   0x220A             MOVS     R2,#+10
   \   0000016C   0x4648             MOV      R0,R9
   \   0000016E   0x.... 0x....      BL       _ZN5Print5printEii
   2570              //#endif
   2571              #if HOTENDS > 1
   2572                HOTEND_LOOP() {
   \                     ??print_heaterstates_8: (+1)
   \   00000172   0x2600             MOVS     R6,#+0
   \   00000174   0x4627             MOV      R7,R4
   \   00000176   0x....             ADR.N    R5,??DataTable69_6  ;; 0x20, 0x40, 0x00, 0x00
   \   00000178   0xE006             B.N      ??print_heaterstates_11
   2573                  SERIAL_PROTOCOLPAIR(" @", e);
   2574                  SERIAL_PROTOCOLCHAR(':');
   2575                  SERIAL_PROTOCOL(getHeaterPower(e));
   \                     ??print_heaterstates_12: (+1)
   \   0000017A   0x220A             MOVS     R2,#+10
   \   0000017C   0x4648             MOV      R0,R9
   \   0000017E   0x.... 0x....      BL       _ZN5Print5printEii
   \   00000182   0x1C76             ADDS     R6,R6,#+1
   \   00000184   0xB276             SXTB     R6,R6
   \   00000186   0x1C7F             ADDS     R7,R7,#+1
   \                     ??print_heaterstates_11: (+1)
   \   00000188   0xF898 0x00F7      LDRB     R0,[R8, #+247]
   \   0000018C   0x4286             CMP      R6,R0
   \   0000018E   0xDA0C             BGE.N    ??print_heaterstates_13
   \   00000190   0x4631             MOV      R1,R6
   \   00000192   0x4628             MOV      R0,R5
   \   00000194   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   00000198   0x213A             MOVS     R1,#+58
   \   0000019A   0x4648             MOV      R0,R9
   \   0000019C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000001A0   0x2E00             CMP      R6,#+0
   \   000001A2   0xBF4C             ITE      MI 
   \   000001A4   0x78E1             LDRBMI   R1,[R4, #+3]
   \   000001A6   0x7839             LDRBPL   R1,[R7, #+0]
   \   000001A8   0xE7E7             B.N      ??print_heaterstates_12
   2576                }
   2577              #endif
   2578            }
   \                     ??print_heaterstates_13: (+1)
   \   000001AA   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   2579          
   2580            #if ENABLED(AUTO_REPORT_TEMPERATURES)
   2581          

   \                                 In section .bss, align 4
   2582              uint8_t Temperature::auto_report_temp_interval;
   \                     _ZN11Temperature25auto_report_temp_intervalE:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   2583              millis_t Temperature::next_temp_report_ms;
   \                     _ZN11Temperature19next_temp_report_msE:
   \   00000004                      DS8 4
   2584          

   \                                 In section .text, align 2, keep-with-next
   2585              void Temperature::auto_report_temperatures() {
   \                     _ZN11Temperature24auto_report_temperaturesEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2586                if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
   \   00000002   0x....             LDR.N    R4,??DataTable69_23
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xB1A0             CBZ.N    R0,??auto_report_temperatures_0
   \   00000008   0x.... 0x....      BL       HAL_GetTick
   \   0000000C   0x6861             LDR      R1,[R4, #+4]
   \   0000000E   0x1A40             SUBS     R0,R0,R1
   \   00000010   0xD40F             BMI.N    ??auto_report_temperatures_0
   2587                  next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x7821             LDRB     R1,[R4, #+0]
   \   00000018   0xF44F 0x727A      MOV      R2,#+1000
   \   0000001C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000020   0x6060             STR      R0,[R4, #+4]
   2588                  print_heaterstates();
   \   00000022   0x.... 0x....      BL       _ZN11Temperature18print_heaterstatesEv
   2589                  SERIAL_EOL();
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002C   0x....             LDR.N    R0,??DataTable69_22
   \   0000002E   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   2590                }
   2591              }
   \                     ??auto_report_temperatures_0: (+1)
   \   00000032   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " /">`:
   \   00000000   0x20 0x2F          DC8 " /"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "bed">`:
   \   00000000   0x62 0x65          DC8 "bed"
   \              0x64 0x00    

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant "">`:
   \   00000000   0x00               DC8 ""

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Kp ">`:
   \   00000000   0x4B 0x70          DC8 "Kp "
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Ki ">`:
   \   00000000   0x4B 0x69          DC8 "Ki "
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Kd ">`:
   \   00000000   0x4B 0x64          DC8 "Kd "
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " @:">`:
   \   00000000   0x20 0x40          DC8 " @:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " @">`:
   \   00000000   0x20 0x40          DC8 " @"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Temperature::subobject Temperature()
   \                     _ZN11TemperatureC2Ev: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable55
   \   00000006   0x6AC0             LDR      R0,[R0, #+44]
   \   00000008   0x.... 0x....      BL       __aeabi_f2iz
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable55_1
   \   00000010   0x8008             STRH     R0,[R1, #+0]
   \   00000012   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! Bad extruder number"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x42    
   \              0x61 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune start">`:
   \   00000000   0x50 0x49          DC8 "PID Autotune start"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " bias: ">`:
   \   00000000   0x20 0x62          DC8 " bias: "
   \              0x69 0x61    
   \              0x73 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " d: ">`:
   \   00000000   0x20 0x64          DC8 " d: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " min: ">`:
   \   00000000   0x20 0x6D          DC8 " min: "
   \              0x69 0x6E    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " max: ">`:
   \   00000000   0x20 0x6D          DC8 " max: "
   \              0x61 0x78    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Ku: ">`:
   \   00000000   0x20 0x4B          DC8 " Ku: "
   \              0x75 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Tu: ">`:
   \   00000000   0x20 0x54          DC8 " Tu: "
   \              0x75 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n Classic PID \\n">`:
   \   00000000   0x0A 0x20          DC8 "\012 Classic PID \012"
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x63 0x20    
   \              0x50 0x49    
   \              0x44 0x20    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Kp: ">`:
   \   00000000   0x20 0x4B          DC8 " Kp: "
   \              0x70 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Ki: ">`:
   \   00000000   0x20 0x4B          DC8 " Ki: "
   \              0x69 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Kd: ">`:
   \   00000000   0x20 0x4B          DC8 " Kd: "
   \              0x64 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">_1`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! Temperature too high\012"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x54    
   \              0x65 0x6D    
   \              0x70 0x65    
   \              0x72 0x61    
   \              0x74 0x75    
   \              0x72 0x65    
   \              0x20 0x74    
   \              0x6F 0x6F    
   \              0x20 0x68    
   \              0x69 0x67    
   \              0x68 0x0A    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">_2`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! timeout\012"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune finished...">`:
   \   00000000   0x50 0x49          DC8 50H, 49H, 44H, 20H, 41H, 75H, 74H, 6FH
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \   00000008   0x74 0x75          DC8 74H, 75H, 6EH, 65H, 20H, 66H, 69H, 6EH
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x69 0x6E    
   \   00000010   0x69 0x73          DC8 69H, 73H, 68H, 65H, 64H, 21H, 20H, 50H
   \              0x68 0x65    
   \              0x64 0x21    
   \              0x20 0x50    
   \   00000018   0x75 0x74          DC8 75H, 74H, 20H, 74H, 68H, 65H, 20H, 6CH
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x6C    
   \   00000020   0x61 0x73          DC8 61H, 73H, 74H, 20H, 4BH, 70H, 2CH, 20H
   \              0x74 0x20    
   \              0x4B 0x70    
   \              0x2C 0x20    
   \   00000028   0x4B 0x69          DC8 4BH, 69H, 20H, 61H, 6EH, 64H, 20H, 4BH
   \              0x20 0x61    
   \              0x6E 0x64    
   \              0x20 0x4B    
   \   00000030   0x64 0x20          DC8 64H, 20H, 63H, 6FH, 6EH, 73H, 74H, 61H
   \              0x63 0x6F    
   \              0x6E 0x73    
   \              0x74 0x61    
   \   00000038   0x6E 0x74          DC8 6EH, 74H, 73H, 20H, 66H, 72H, 6FH, 6DH
   \              0x73 0x20    
   \              0x66 0x72    
   \              0x6F 0x6D    
   \   00000040   0x20 0x62          DC8 20H, 62H, 65H, 6CH, 6FH, 77H, 20H, 69H
   \              0x65 0x6C    
   \              0x6F 0x77    
   \              0x20 0x69    
   \   00000048   0x6E 0x74          DC8 6EH, 74H, 6FH, 20H, 43H, 6FH, 6EH, 66H
   \              0x6F 0x20    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \   00000050   0x69 0x67          DC8 69H, 67H, 75H, 72H, 61H, 74H, 69H, 6FH
   \              0x75 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \   00000058   0x6E 0x2E          DC8 6EH, 2EH, 68H, 0AH, 0
   \              0x68 0x0A    
   \              0x00         
   \   0000005D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_"
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Kp ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Kp "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x70 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Ki ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Ki "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x69 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Kd ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Kd "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x64 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_bedKp ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_bedKp "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x62    
   \              0x65 0x64    
   \              0x4B 0x70    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_bedKi ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_bedKi "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x62    
   \              0x65 0x64    
   \              0x4B 0x69    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_bedKd ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_bedKd "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x62    
   \              0x65 0x64    
   \              0x4B 0x64    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51:
   \   00000000   0x62 0x65          DC8      "bed"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_1:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_2:
   \   00000000   0x4B 0x70          DC8      "Kp "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_3:
   \   00000000   0x4B 0x69          DC8      "Ki "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_4:
   \   00000000   0x4B 0x64          DC8      "Kd "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MAXTEMP BED">`:
   \   00000000   0x45 0x72          DC8 "Err: MAXTEMP BED"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x41 0x58    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x20 0x42    
   \              0x45 0x44    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_1:
   \   00000000   0x........         DC32     _ZN11Temperature16extrude_min_tempE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_2:
   \   00000000   0x........         DC32     mksCfg+0xE4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_3:
   \   00000000   0x461C4000         DC32     0x461c4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_4:
   \   00000000   0x........         DC32     mksCfg+0x36

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_5:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_6:
   \   00000000   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_7:
   \   00000000   0x........         DC32     wait_for_heatup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_8:
   \   00000000   0xC1A00000         DC32     0xc1a00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_9:
   \   00000000   0x41A00000         DC32     0x41a00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_10:
   \   00000000   0x........         DC32     _ZN11Temperature15soft_pwm_amountE+0x44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_11:
   \   00000000   0xFFFFEC78         DC32     0xffffec78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_12:
   \   00000000   0x40100000         DC32     0x40100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_13:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_14:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_15:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_16:
   \   00000000   0xD2F1A9FC         DC32     0xd2f1a9fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_17:
   \   00000000   0x3F50624D         DC32     0x3f50624d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_18:
   \   00000000   0x3FE33333         DC32     0x3fe33333

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Heating failed">`:
   \   00000000   0x48 0x65          DC8 "Heating failed"
   \              0x61 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56:
   \   00000000   0x........         DC32     `?<Constant "THERMAL RUNAWAY">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_1:
   \   00000000   0x........         DC32     `?<Constant "Thermal Runaway">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_2:
   \   00000000   0x00124F81         DC32     0x124f81

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " - Invalid extruder n...">`:
   \   00000000   0x20 0x2D          DC8 " - Invalid extruder number !\012"
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x21    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "KILLED. ">`:
   \   00000000   0x4B 0x49          DC8 "KILLED. "
   \              0x4C 0x4C    
   \              0x45 0x44    
   \              0x2E 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57:
   \   00000000   0x88E368F1         DC32     0x88e368f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_1:
   \   00000000   0x3FC4F8B5         DC32     0x3fc4f8b5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58:
   \   00000000   0x........         DC32     _ZN11Temperature5bedKiE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61:
   \   00000000   0x........         DC32     Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_1:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_2:
   \   00000000   0x........         DC32     `?<Constant ", system stopped! Hea...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_3:
   \   00000000   0x........         DC32     `?<Constant "bed\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62:
   \   00000000   0x........         DC32     `?<Constant "Err: MAXTEMP">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_1:
   \   00000000   0x........         DC32     `?<Constant "MAXTEMP triggered">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_2:
   \   00000000   0x........         DC32     `?<Constant "Err: MINTEMP BED">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_3:
   \   00000000   0x........         DC32     `?<Constant "Err: MINTEMP">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_4:
   \   00000000   0x........         DC32     `?<Constant "MINTEMP triggered">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_5:
   \   00000000   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63:
   \   00000000   0x........         DC32     temper_error_type

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63_1:
   \   00000000   0x........         DC32     _ZN11Temperature9pid_resetE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63_2:
   \   00000000   0x999999A0         DC32     0x999999a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63_3:
   \   00000000   0x3FA99999         DC32     0x3fa99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63_4:
   \   00000000   0x3FEE6666         DC32     0x3fee6666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63_5:
   \   00000000   0x42200001         DC32     0x42200001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63_6:
   \   00000000   0x437F0000         DC32     0x437f0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63_7:
   \   00000000   0xC2200000         DC32     0xc2200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63_8:
   \   00000000   0x437F0001         DC32     0x437f0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65:
   \   00000000   0x........         DC32     mksCfg+0xE0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_1:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_2:
   \   00000000   0x409C1C00         DC32     0x409c1c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_3:
   \   00000000   0x........         DC32     mksCfg+0x30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_4:
   \   00000000   0x44E10000         DC32     0x44e10000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_5:
   \   00000000   0x0A3D70A4         DC32     0xa3d70a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_6:
   \   00000000   0xC070DFD7         DC32     0xc070dfd7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67:
   \   00000000   0x........         DC32     mksTmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_1:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_2:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_3:
   \   00000000   0x3FD00000         DC32     0x3fd00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_4:
   \   00000000   0x........         DC32     heater_ttbllen_map

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_5:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_6:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69:
   \   00000000   0x3F9F4000         DC32     0x3f9f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_1:
   \   00000000   0x20 0x2F          DC8      0x20, 0x2F, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_2:
   \   00000000   0xC1C80000         DC32     0xc1c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_3:
   \   00000000   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_4:
   \   00000000   0x20 0x40          DC8      " @:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_5:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_6:
   \   00000000   0x20 0x40          DC8      0x20, 0x40, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_7:
   \   00000000   0x........         DC32     ??tr_target_temperature

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_8:
   \   00000000   0x........         DC32     _ZN7Planner16autotemp_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_9:
   \   00000000   0x........         DC32     print_job_timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_10:
   \   00000000   0x........         DC32     max6675_temp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_11:
   \   00000000   0x42230194         DC32     0x42230194

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_12:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_13:
   \   00000000   0xFFFFC000         DC32     0xffffc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_14:
   \   00000000   0x........         DC32     htim4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_15:
   \   00000000   0x........         DC32     uhADCxConvertedValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_16:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_17:
   \   00000000   0x........         DC32     loop_start

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_18:
   \   00000000   0x........         DC32     temper_error_type

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_19:
   \   00000000   0x........         DC32     mksCfg+0x36

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_20:
   \   00000000   0x........         DC32     Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_21:
   \   00000000   0x........         DC32     target_extruder

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_22:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_23:
   \   00000000   0x........         DC32     _ZN11Temperature25auto_report_temp_intervalE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Thermal Runaway">`:
   \   00000000   0x54 0x68          DC8 "Thermal Runaway"
   \              0x65 0x72    
   \              0x6D 0x61    
   \              0x6C 0x20    
   \              0x52 0x75    
   \              0x6E 0x61    
   \              0x77 0x61    
   \              0x79 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "THERMAL RUNAWAY">`:
   \   00000000   0x54 0x48          DC8 "THERMAL RUNAWAY"
   \              0x45 0x52    
   \              0x4D 0x41    
   \              0x4C 0x20    
   \              0x52 0x55    
   \              0x4E 0x41    
   \              0x57 0x41    
   \              0x59 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " B@:">`:
   \   00000000   0x20 0x42          DC8 " B@:"
   \              0x40 0x3A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Temp measurement error! ">`:
   \   00000000   0x54 0x65          DC8 "Temp measurement error! "
   \              0x6D 0x70    
   \              0x20 0x6D    
   \              0x65 0x61    
   \              0x73 0x75    
   \              0x72 0x65    
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x21 0x20    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MAX31855 ">`:
   \   00000000   0x4D 0x41          DC8 "MAX31855 "
   \              0x58 0x33    
   \              0x31 0x38    
   \              0x35 0x35    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Open Circuit\\n">`:
   \   00000000   0x4F 0x70          DC8 "Open Circuit\012"
   \              0x65 0x6E    
   \              0x20 0x43    
   \              0x69 0x72    
   \              0x63 0x75    
   \              0x69 0x74    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Short to GND\\n">`:
   \   00000000   0x53 0x68          DC8 "Short to GND\012"
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x74 0x6F    
   \              0x20 0x47    
   \              0x4E 0x44    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Short to VCC\\n">`:
   \   00000000   0x53 0x68          DC8 "Short to VCC\012"
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x74 0x6F    
   \              0x20 0x56    
   \              0x43 0x43    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ", system stopped! Hea...">`:
   \   00000000   0x2C 0x20          DC8 ", system stopped! Heater_ID: "
   \              0x73 0x79    
   \              0x73 0x74    
   \              0x65 0x6D    
   \              0x20 0x73    
   \              0x74 0x6F    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x21 0x20    
   \              0x48 0x65    
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x5F 0x49    
   \              0x44 0x3A    
   \              0x20 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "bed\\n">`:
   \   00000000   0x62 0x65          DC8 "bed\012"
   \              0x64 0x0A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MINTEMP triggered">`:
   \   00000000   0x4D 0x49          DC8 "MINTEMP triggered"
   \              0x4E 0x54    
   \              0x45 0x4D    
   \              0x50 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MINTEMP">`:
   \   00000000   0x45 0x72          DC8 "Err: MINTEMP"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x49 0x4E    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MINTEMP BED">`:
   \   00000000   0x45 0x72          DC8 "Err: MINTEMP BED"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x49 0x4E    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x20 0x42    
   \              0x45 0x44    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MAXTEMP triggered">`:
   \   00000000   0x4D 0x41          DC8 "MAXTEMP triggered"
   \              0x58 0x54    
   \              0x45 0x4D    
   \              0x50 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MAXTEMP">`:
   \   00000000   0x45 0x72          DC8 "Err: MAXTEMP"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x41 0x58    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   2592          
   2593            #endif // AUTO_REPORT_TEMPERATURES
   2594          
   2595          #endif // HAS_TEMP_HOTEND || HAS_TEMP_BED

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   IsrTemperatureHandler
         0   -> Temperature::TemperatureHandler()
     136   Temperature::PID_autotune(float, int8_t, int8_t, bool)
       136   -> HAL_GetTick
       136   -> Print::print(char const *)
       136   -> Temperature::_temp_error(int8_t, char const *, char const *)
         0   -> Temperature::disable_all_heaters()
       136   -> Temperature::disable_all_heaters()
       136   -> Temperature::print_heaterstates()
       136   -> Temperature::updateTemperaturesFromRawValues()
         0   -> USARTClass::write(uint8_t)
       136   -> USARTClass::write(uint8_t)
       136   -> __aeabi_cfcmple
       136   -> __aeabi_d2f
       136   -> __aeabi_ddiv
       136   -> __aeabi_dmul
       136   -> __aeabi_f2d
       136   -> __aeabi_fadd
       136   -> __aeabi_fdiv
       136   -> __aeabi_fmul
       136   -> __aeabi_fsub
       136   -> __aeabi_i2d
       136   -> __aeabi_i2f
       136   -> serial_echopair_P(char const *, char const *)
       136   -> serial_echopair_P(char const *, float)
       136   -> serial_echopair_P(char const *, long)
       0   Temperature::Temperature()
      56   Temperature::TemperatureHandler()
        56   -> HAL_GPIO_WritePin
        56   -> HAL_TIM_Base_Start_IT
        56   -> HAL_TIM_Base_Stop_IT
        56   -> Stepper::babystep(AxisEnum, bool)
        56   -> Temperature::_temp_error(int8_t, char const *, char const *)
        56   -> Temperature::disable_all_heaters()
        56   -> Temperature::min_temp_error(int8_t)
        56   -> Temperature::set_current_temp_raw()
        56   -> USARTClass::write(uint8_t)
        56   -> temper_error_kill()
      24   Temperature::_temp_error(int8_t, char const *, char const *)
        24   -> Print::print(int, int)
        24   -> Temperature::disable_all_heaters()
        24   -> USARTClass::write(uint8_t)
         0   -> temper_error_kill()
      40   Temperature::analog2temp(int, uint8_t)
        40   -> Print::print(int, int)
        40   -> USARTClass::write(uint8_t)
         0   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_i2d
         0   -> __aeabi_i2f
        40   -> __aeabi_i2f
        40   -> kill(char const *)
      32   Temperature::analog2tempBed(int)
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_i2f
       8   Temperature::auto_report_temperatures()
         8   -> HAL_GetTick
         8   -> Temperature::print_heaterstates()
         0   -> USARTClass::write(uint8_t)
      24   Temperature::disable_all_heaters()
         0   -> HAL_GPIO_WritePin
        24   -> HAL_GPIO_WritePin
        24   -> Stopwatch::stop()
        24   -> Temperature::start_watching_bed()
        24   -> Temperature::start_watching_heater(uint8_t)
       0   Temperature::getHeaterPower(int)
      48   Temperature::get_pid_output(int8_t)
        48   -> __aeabi_cfcmple
        48   -> __aeabi_cfrcmple
        48   -> __aeabi_d2f
        48   -> __aeabi_dadd
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_fadd
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> __aeabi_i2f
      40   Temperature::get_pid_output_bed()
        40   -> __aeabi_cfcmple
        40   -> __aeabi_cfrcmple
        40   -> __aeabi_d2f
        40   -> __aeabi_dadd
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
      24   Temperature::init()
        24   -> Temperature::analog2temp(int, uint8_t)
        24   -> Temperature::analog2tempBed(int)
        24   -> __aeabi_cfcmple
        24   -> __aeabi_i2f
      72   Temperature::manage_heater()
         0   -> HAL_GPIO_WritePin
        72   -> HAL_GetTick
        72   -> Temperature::_temp_error(int8_t, char const *, char const *)
        72   -> Temperature::disable_all_heaters()
        72   -> Temperature::get_pid_output(int8_t)
        72   -> Temperature::get_pid_output_bed()
        72   -> Temperature::start_watching_bed()
        72   -> Temperature::start_watching_heater(uint8_t)
        72   -> Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
        72   -> Temperature::updateTemperaturesFromRawValues()
        72   -> USARTClass::write(uint8_t)
        72   -> __aeabi_cdcmple
        72   -> __aeabi_cfcmpeq
        72   -> __aeabi_cfcmple
        72   -> __aeabi_cfrcmple
        72   -> __aeabi_f2d
        72   -> __aeabi_f2iz
        72   -> __aeabi_i2d
        72   -> __aeabi_i2f
        72   -> __aeabi_ui2f
        72   -> temper_error_kill()
       8   Temperature::max_temp_error(int8_t)
         8   -> Temperature::_temp_error(int8_t, char const *, char const *)
       8   Temperature::min_temp_error(int8_t)
         8   -> Temperature::_temp_error(int8_t, char const *, char const *)
      40   Temperature::print_heaterstates()
        40   -> Print::print(double, int)
        40   -> Print::print(int, int)
        40   -> USARTClass::write(uint8_t)
        40   -> __aeabi_f2d
        40   -> __aeabi_i2f
        40   -> serial_echopair_P(char const *, float)
        40   -> serial_echopair_P(char const *, int)
      16   Temperature::read_max6675()
        16   -> HAL_GetTick
        16   -> SPI2_ReadWriteByte
        16   -> USARTClass::write(uint8_t)
       0   Temperature::set_current_temp_raw()
      24   Temperature::start_watching_bed()
        24   -> HAL_GetTick
        24   -> __aeabi_cfcmple
        24   -> __aeabi_f2iz
        24   -> __aeabi_fadd
        24   -> __aeabi_fsub
        24   -> __aeabi_i2f
        24   -> __aeabi_ui2f
      32   Temperature::start_watching_heater(uint8_t)
        32   -> HAL_GetTick
        32   -> __aeabi_cfcmple
        32   -> __aeabi_f2iz
        32   -> __aeabi_fadd
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32   -> __aeabi_ui2f
       0   Temperature::subobject Temperature()
      32   Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
        32   -> HAL_GetTick
        32   -> Temperature::_temp_error(int8_t, char const *, char const *)
        32   -> __aeabi_cfcmpeq
        32   -> __aeabi_cfcmple
        32   -> __aeabi_cfrcmple
        32   -> __aeabi_fsub
        32   -> __aeabi_ui2f
      24   Temperature::updateTemperaturesFromRawValues()
        24   -> Temperature::analog2temp(int, uint8_t)
        24   -> Temperature::analog2tempBed(int)
        24   -> Temperature::read_max6675()
       8   __sti__routine()
         8   -> __aeabi_f2iz
      32   print_heater_state(float const &, float const &, int8_t)
        32   -> Print::print(double, int)
        32   -> USARTClass::write(uint8_t)
        32   -> __aeabi_f2d
         0   -> serial_echopair_P(char const *, float)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant " - Invalid extruder n...">
       4  ?<Constant " /">
       4  ?<Constant " @">
       4  ?<Constant " @:">
       8  ?<Constant " B@:">
       8  ?<Constant " Kd: ">
       8  ?<Constant " Ki: ">
       8  ?<Constant " Kp: ">
       8  ?<Constant " Ku: ">
       8  ?<Constant " Tu: ">
       8  ?<Constant " bias: ">
       8  ?<Constant " d: ">
       8  ?<Constant " max: ">
       8  ?<Constant " min: ">
       1  ?<Constant "">
      20  ?<Constant "#define  DEFAULT_">
      24  ?<Constant "#define  DEFAULT_Kd ">
      24  ?<Constant "#define  DEFAULT_Ki ">
      24  ?<Constant "#define  DEFAULT_Kp ">
      24  ?<Constant "#define  DEFAULT_bedKd ">
      24  ?<Constant "#define  DEFAULT_bedKi ">
      24  ?<Constant "#define  DEFAULT_bedKp ">
      32  ?<Constant ", system stopped! Hea...">
      20  ?<Constant "Err: MAXTEMP BED">
      16  ?<Constant "Err: MAXTEMP">
      20  ?<Constant "Err: MINTEMP BED">
      16  ?<Constant "Err: MINTEMP">
      16  ?<Constant "Heating failed">
      12  ?<Constant "KILLED. ">
       4  ?<Constant "Kd ">
       4  ?<Constant "Ki ">
       4  ?<Constant "Kp ">
      12  ?<Constant "MAX31855 ">
      20  ?<Constant "MAXTEMP triggered">
      20  ?<Constant "MINTEMP triggered">
      16  ?<Constant "Open Circuit\n">
      44  ?<Constant "PID Autotune failed! ...">
      44  ?<Constant "PID Autotune failed! ...">_1
      32  ?<Constant "PID Autotune failed! ...">_2
      96  ?<Constant "PID Autotune finished...">
      20  ?<Constant "PID Autotune start">
      16  ?<Constant "Short to GND\n">
      16  ?<Constant "Short to VCC\n">
      16  ?<Constant "THERMAL RUNAWAY">
      28  ?<Constant "Temp measurement error! ">
      16  ?<Constant "Thermal Runaway">
      16  ?<Constant "\n Classic PID \n">
       4  ?<Constant "bed">
       8  ?<Constant "bed\n">
       4  ??DataTable51
       4  ??DataTable51_1
       4  ??DataTable51_2
       4  ??DataTable51_3
       4  ??DataTable51_4
       4  ??DataTable55
       4  ??DataTable55_1
       4  ??DataTable55_10
       4  ??DataTable55_11
       4  ??DataTable55_12
       4  ??DataTable55_13
       4  ??DataTable55_14
       4  ??DataTable55_15
       4  ??DataTable55_16
       4  ??DataTable55_17
       4  ??DataTable55_18
       4  ??DataTable55_2
       4  ??DataTable55_3
       4  ??DataTable55_4
       4  ??DataTable55_5
       4  ??DataTable55_6
       4  ??DataTable55_7
       4  ??DataTable55_8
       4  ??DataTable55_9
       4  ??DataTable56
       4  ??DataTable56_1
       4  ??DataTable56_2
       4  ??DataTable57
       4  ??DataTable57_1
       4  ??DataTable58
       4  ??DataTable61
       4  ??DataTable61_1
       4  ??DataTable61_2
       4  ??DataTable61_3
       4  ??DataTable62
       4  ??DataTable62_1
       4  ??DataTable62_2
       4  ??DataTable62_3
       4  ??DataTable62_4
       4  ??DataTable62_5
       4  ??DataTable63
       4  ??DataTable63_1
       4  ??DataTable63_2
       4  ??DataTable63_3
       4  ??DataTable63_4
       4  ??DataTable63_5
       4  ??DataTable63_6
       4  ??DataTable63_7
       4  ??DataTable63_8
       4  ??DataTable65
       4  ??DataTable65_1
       4  ??DataTable65_2
       4  ??DataTable65_3
       4  ??DataTable65_4
       4  ??DataTable65_5
       4  ??DataTable65_6
       4  ??DataTable66
       4  ??DataTable67
       4  ??DataTable67_1
       4  ??DataTable67_2
       4  ??DataTable67_3
       4  ??DataTable67_4
       4  ??DataTable67_5
       4  ??DataTable67_6
       4  ??DataTable69
       4  ??DataTable69_1
       4  ??DataTable69_10
       4  ??DataTable69_11
       4  ??DataTable69_12
       4  ??DataTable69_13
       4  ??DataTable69_14
       4  ??DataTable69_15
       4  ??DataTable69_16
       4  ??DataTable69_17
       4  ??DataTable69_18
       4  ??DataTable69_19
       4  ??DataTable69_2
       4  ??DataTable69_20
       4  ??DataTable69_21
       4  ??DataTable69_22
       4  ??DataTable69_23
       4  ??DataTable69_3
       4  ??DataTable69_4
       4  ??DataTable69_5
       4  ??DataTable69_6
       4  ??DataTable69_7
       4  ??DataTable69_8
       4  ??DataTable69_9
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
       2  IsrTemperatureHandler
    1586  Temperature::PID_autotune(float, int8_t, int8_t, bool)
       2  Temperature::Temperature()
     906  Temperature::TemperatureHandler()
     156  Temperature::_temp_error(int8_t, char const *, char const *)
       1  Temperature::allow_cold_extrude
     278  Temperature::analog2temp(int, uint8_t)
     150  Temperature::analog2tempBed(int)
       8  Temperature::auto_report_temp_interval
          Temperature::next_temp_report_ms
      52  Temperature::auto_report_temperatures()
      32  Temperature::bedKi
          Temperature::bedKd
          Temperature::temp_iState_bed
          Temperature::temp_dState_bed
          Temperature::pTerm_bed
          Temperature::iTerm_bed
          Temperature::dTerm_bed
          Temperature::pid_error_bed
     172  Temperature::disable_all_heaters()
       2  Temperature::extrude_min_temp
      16  Temperature::getHeaterPower(int)
     326  Temperature::get_pid_output(int8_t)
     238  Temperature::get_pid_output_bed()
     302  Temperature::init()
     872  Temperature::manage_heater()
      54  Temperature::max_temp_error(int8_t)
      54  Temperature::min_temp_error(int8_t)
      52  Temperature::pid_reset
          Temperature::temp_iState
          Temperature::temp_dState
          Temperature::pTerm
          Temperature::iTerm
          Temperature::dTerm
          Temperature::pid_error
     430  Temperature::print_heaterstates()
     248  Temperature::read_max6675()
      34  Temperature::set_current_temp_raw()
     148  Temperature::soft_pwm_amount
          Temperature::temp_meas_ready
          Temperature::soft_pwm_amount_bed
          killed
          Temperature::in_temp_isr
          temp_count
          adc_sensor_state
          pwm_count
          soft_pwm_count_0
          soft_pwm_count_1
          soft_pwm_count_BED
          do_buttons
          delay_count
          Temperature::raw_temp_value
          Temperature::minttemp_raw
          Temperature::maxttemp_raw
          Temperature::minttemp
          Temperature::maxttemp
          Temperature::target_temperature_bed
          Temperature::watch_target_bed_temp
          Temperature::raw_temp_bed_value
          Temperature::bed_minttemp_raw
          Temperature::bed_maxttemp_raw
          Temperature::watch_target_temp
          Temperature::current_temperature_raw
          Temperature::target_temperature
          Temperature::current_temperature
          Temperature::current_temperature_bed
          Temperature::current_temperature_bed_raw
          Temperature::Kp
          Temperature::Ki
          Temperature::Kd
          Temperature::bedKp
          Temperature::babystepsTodo
          Temperature::watch_heater_next_ms
          Temperature::watch_bed_next_ms
          Temperature::next_bed_check_ms
          current_temper_bak
          Temperature::thermal_runaway_bed_state_machine
          Temperature::thermal_runaway_state_machine
          Temperature::thermal_runaway_timer
          Temperature::thermal_runaway_bed_timer
      94  Temperature::start_watching_bed()
     106  Temperature::start_watching_heater(uint8_t)
       2  Temperature::subobject Temperature()
     178  Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
      92  Temperature::updateTemperaturesFromRawValues()
      20  __sti__routine()
      12  heater_ttbllen_map
          heater_ttbl_map
       8  max6675_temp
          next_max6675_ms
     106  print_heater_state(float const &, float const &, int8_t)
     256  temptable_1
       4  thermalManager
      12  tr_target_temperature
       5  -- Other

 
   111 bytes in section .bss
   168 bytes in section .data
     4 bytes in section .init_array
    30 bytes in section .rodata
 7 936 bytes in section .text
 
 7 940 bytes of CODE  memory
    29 bytes of CONST memory (+ 1 byte shared)
   279 bytes of DATA  memory

Errors: none
Warnings: 14
