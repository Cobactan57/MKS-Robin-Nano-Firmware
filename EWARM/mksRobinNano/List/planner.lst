###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        13/Apr/2020  09:25:13
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.cpp
#    Command line =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        -lA
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/Multi_language\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/QRENCODE\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\..\Middlewares\GUI\
#        -Oh --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\planner.lst
#    Object file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\planner.o
#
###############################################################################

D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * planner.cpp
     25           *
     26           * Buffer movement commands and manage the acceleration profile plan
     27           *
     28           * Derived from Grbl
     29           * Copyright (c) 2009-2011 Simen Svale Skogsrud
     30           *
     31           * The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis.
     32           *
     33           *
     34           * Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
     35           *
     36           * s == speed, a == acceleration, t == time, d == distance
     37           *
     38           * Basic definitions:
     39           *   Speed[s_, a_, t_] := s + (a*t)
     40           *   Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
     41           *
     42           * Distance to reach a specific speed with a constant acceleration:
     43           *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
     44           *   d -> (m^2 - s^2)/(2 a) --> estimate_acceleration_distance()
     45           *
     46           * Speed after a given distance of travel with constant acceleration:
     47           *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
     48           *   m -> Sqrt[2 a d + s^2]
     49           *
     50           * DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
     51           *
     52           * When to start braking (di) to reach a specified destination speed (s2) after accelerating
     53           * from initial speed s1 without ever stopping at a plateau:
     54           *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
     55           *   di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
     56           *
     57           * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
     58           *
     59           */
     60          #include "Marlin.h"

  #define UNUSED(x) ((void)(x))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Inc\mks_cfg.h",626  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

    }
    ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
     61          
     62          #include "MarlinConfig.h"
     63          #include "planner.h"

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.h",627  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.h",628  Warning[Pe815]: 
          type qualifier on return type is meaningless
     64          #include "stepper.h"
     65          #include "temperature.h"

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\temperature.h",406  Warning[Pa093]: 
          implicit conversion from floating point to integer

          target_temperature_bed =
                                 ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\temperature.h",414  Warning[Pa093]: 
          implicit conversion from floating point to integer
     66          #include "ultralcd.h"
     67          #include "language.h"
     68          #include "ubl.h"

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t unified_bed_leveling::get_cell_index_x(float const &)
   \                     _ZN20unified_bed_leveling16get_cell_index_xERKf: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4E41             LDR.N    R6,??get_cell_index_x_0
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4680             MOV      R8,R0
   \   00000012   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000016   0xF240 0x3202      MOVW     R2,#+770
   \   0000001A   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD013             BEQ.N    ??get_cell_index_x_1

          	cx = (x - (MESH_MIN_X_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
          	   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\ubl.h",182  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0x4F3B             LDR.N    R7,??get_cell_index_x_0+0x4
   \   00000024   0x6838             LDR      R0,[R7, #+0]
   \   00000026   0x4641             MOV      R1,R8
   \   00000028   0x.... 0x....      BL       __aeabi_fadd
   \   0000002C   0x4681             MOV      R9,R0
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x4649             MOV      R1,R9
   \   00000032   0x.... 0x....      BL       __aeabi_fsub
   \   00000036   0x.... 0x....      BL       __aeabi_f2d
   \   0000003A   0x4604             MOV      R4,R0
   \   0000003C   0x460D             MOV      R5,R1
   \   0000003E   0x6878             LDR      R0,[R7, #+4]
   \   00000040   0x4641             MOV      R1,R8
   \   00000042   0x.... 0x....      BL       __aeabi_fsub
   \   00000046   0x4649             MOV      R1,R9
   \   00000048   0xE037             B.N      ??get_cell_index_x_2

  					cx = (x - (MESH_MIN_X_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  					   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\ubl.h",184  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??get_cell_index_x_1: (+1)
   \   0000004A   0x68C5             LDR      R5,[R0, #+12]
   \   0000004C   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x.... 0x....      BL       __aeabi_fmul
   \   00000056   0x4682             MOV      R10,R0
   \   00000058   0x4651             MOV      R1,R10
   \   0000005A   0x.... 0x....      BL       __aeabi_fsub
   \   0000005E   0x4641             MOV      R1,R8
   \   00000060   0x.... 0x....      BL       __aeabi_fadd
   \   00000064   0x4607             MOV      R7,R0
   \   00000066   0xF106 0x0060      ADD      R0,R6,#+96
   \   0000006A   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \   0000006E   0x68B0             LDR      R0,[R6, #+8]
   \   00000070   0x4649             MOV      R1,R9
   \   00000072   0x.... 0x....      BL       __aeabi_fadd
   \   00000076   0x4639             MOV      R1,R7
   \   00000078   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000007C   0xBF28             IT       CS 
   \   0000007E   0x4607             MOVCS    R7,R0
   \   00000080   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000084   0x4651             MOV      R1,R10
   \   00000086   0x.... 0x....      BL       __aeabi_fmul
   \   0000008A   0x4641             MOV      R1,R8
   \   0000008C   0x.... 0x....      BL       __aeabi_fsub
   \   00000090   0x4680             MOV      R8,R0
   \   00000092   0x4628             MOV      R0,R5
   \   00000094   0x4649             MOV      R1,R9
   \   00000096   0x.... 0x....      BL       __aeabi_fadd
   \   0000009A   0x4601             MOV      R1,R0
   \   0000009C   0x4640             MOV      R0,R8
   \   0000009E   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000A2   0xBF28             IT       CS 
   \   000000A4   0x4688             MOVCS    R8,R1
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x4639             MOV      R1,R7
   \   000000AA   0x.... 0x....      BL       __aeabi_fsub
   \   000000AE   0x.... 0x....      BL       __aeabi_f2d
   \   000000B2   0x4604             MOV      R4,R0
   \   000000B4   0x460D             MOV      R5,R1
   \   000000B6   0x4640             MOV      R0,R8
   \   000000B8   0x4639             MOV      R1,R7
   \                     ??get_cell_index_x_2: (+1)
   \   000000BA   0x.... 0x....      BL       __aeabi_fsub
   \   000000BE   0x4607             MOV      R7,R0
   \   000000C0   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   000000C4   0x1E40             SUBS     R0,R0,#+1
   \   000000C6   0x.... 0x....      BL       __aeabi_i2f
   \   000000CA   0x4601             MOV      R1,R0
   \   000000CC   0x4638             MOV      R0,R7
   \   000000CE   0x.... 0x....      BL       __aeabi_fdiv
   \   000000D2   0x.... 0x....      BL       __aeabi_f2d
   \   000000D6   0x4602             MOV      R2,R0
   \   000000D8   0x460B             MOV      R3,R1
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x490D             LDR.N    R1,??get_cell_index_x_0+0x8  ;; 0x3ff00000
   \   000000DE   0x.... 0x....      BL       __aeabi_ddiv
   \   000000E2   0x4622             MOV      R2,R4
   \   000000E4   0x462B             MOV      R3,R5
   \   000000E6   0x.... 0x....      BL       __aeabi_dmul
   \   000000EA   0x.... 0x....      BL       __aeabi_d2iz
   \   000000EE   0xB240             SXTB     R0,R0
   \   000000F0   0x0001             MOVS     R1,R0
   \   000000F2   0xBF48             IT       MI 
   \   000000F4   0x2000             MOVMI    R0,#+0
   \   000000F6   0xD405             BMI.N    ??get_cell_index_x_3
   \   000000F8   0xF896 0x2060      LDRB     R2,[R6, #+96]
   \   000000FC   0x1E53             SUBS     R3,R2,#+1
   \   000000FE   0x4283             CMP      R3,R0
   \   00000100   0xBFB8             IT       LT 
   \   00000102   0x1E50             SUBLT    R0,R2,#+1
   \                     ??get_cell_index_x_3: (+1)
   \   00000104   0xB240             SXTB     R0,R0
   \   00000106   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \   0000010A   0xBF00             Nop      
   \                     ??get_cell_index_x_0:
   \   0000010C   0x........         DC32     mksCfg
   \   00000110   0x........         DC32     mksTmp
   \   00000114   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t unified_bed_leveling::get_cell_index_y(float const &)
   \                     _ZN20unified_bed_leveling16get_cell_index_yERKf: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4E40             LDR.N    R6,??get_cell_index_y_0
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4680             MOV      R8,R0
   \   00000012   0xF106 0x000C      ADD      R0,R6,#+12
   \   00000016   0xF240 0x3202      MOVW     R2,#+770
   \   0000001A   0xF8B0 0x104C      LDRH     R1,[R0, #+76]
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD013             BEQ.N    ??get_cell_index_y_1

  					cy = (y - (MESH_MIN_Y_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  					   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\ubl.h",195  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0x4F3A             LDR.N    R7,??get_cell_index_y_0+0x4
   \   00000024   0x68B8             LDR      R0,[R7, #+8]
   \   00000026   0x4641             MOV      R1,R8
   \   00000028   0x.... 0x....      BL       __aeabi_fadd
   \   0000002C   0x4681             MOV      R9,R0
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x4649             MOV      R1,R9
   \   00000032   0x.... 0x....      BL       __aeabi_fsub
   \   00000036   0x.... 0x....      BL       __aeabi_f2d
   \   0000003A   0x4604             MOV      R4,R0
   \   0000003C   0x460D             MOV      R5,R1
   \   0000003E   0x68F8             LDR      R0,[R7, #+12]
   \   00000040   0x4641             MOV      R1,R8
   \   00000042   0x.... 0x....      BL       __aeabi_fsub
   \   00000046   0x4649             MOV      R1,R9
   \   00000048   0xE035             B.N      ??get_cell_index_y_2

  					cy = (y - (MESH_MIN_Y_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  					   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\ubl.h",197  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??get_cell_index_y_1: (+1)
   \   0000004A   0x68C5             LDR      R5,[R0, #+12]
   \   0000004C   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x.... 0x....      BL       __aeabi_fmul
   \   00000056   0x4682             MOV      R10,R0
   \   00000058   0x4651             MOV      R1,R10
   \   0000005A   0x.... 0x....      BL       __aeabi_fsub
   \   0000005E   0x4641             MOV      R1,R8
   \   00000060   0x.... 0x....      BL       __aeabi_fadd
   \   00000064   0x4607             MOV      R7,R0
   \   00000066   0xF8D6 0x9070      LDR      R9,[R6, #+112]
   \   0000006A   0x68F0             LDR      R0,[R6, #+12]
   \   0000006C   0x4649             MOV      R1,R9
   \   0000006E   0x.... 0x....      BL       __aeabi_fadd
   \   00000072   0x4639             MOV      R1,R7
   \   00000074   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000078   0xBF28             IT       CS 
   \   0000007A   0x4607             MOVCS    R7,R0
   \   0000007C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000080   0x4651             MOV      R1,R10
   \   00000082   0x.... 0x....      BL       __aeabi_fmul
   \   00000086   0x4641             MOV      R1,R8
   \   00000088   0x.... 0x....      BL       __aeabi_fsub
   \   0000008C   0x4680             MOV      R8,R0
   \   0000008E   0x4628             MOV      R0,R5
   \   00000090   0x4649             MOV      R1,R9
   \   00000092   0x.... 0x....      BL       __aeabi_fadd
   \   00000096   0x4601             MOV      R1,R0
   \   00000098   0x4640             MOV      R0,R8
   \   0000009A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000009E   0xBF28             IT       CS 
   \   000000A0   0x4688             MOVCS    R8,R1
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x4639             MOV      R1,R7
   \   000000A6   0x.... 0x....      BL       __aeabi_fsub
   \   000000AA   0x.... 0x....      BL       __aeabi_f2d
   \   000000AE   0x4604             MOV      R4,R0
   \   000000B0   0x460D             MOV      R5,R1
   \   000000B2   0x4640             MOV      R0,R8
   \   000000B4   0x4639             MOV      R1,R7
   \                     ??get_cell_index_y_2: (+1)
   \   000000B6   0x.... 0x....      BL       __aeabi_fsub
   \   000000BA   0x4607             MOV      R7,R0
   \   000000BC   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   000000C0   0x1E40             SUBS     R0,R0,#+1
   \   000000C2   0x.... 0x....      BL       __aeabi_i2f
   \   000000C6   0x4601             MOV      R1,R0
   \   000000C8   0x4638             MOV      R0,R7
   \   000000CA   0x.... 0x....      BL       __aeabi_fdiv
   \   000000CE   0x.... 0x....      BL       __aeabi_f2d
   \   000000D2   0x4602             MOV      R2,R0
   \   000000D4   0x460B             MOV      R3,R1
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x490D             LDR.N    R1,??get_cell_index_y_0+0x8  ;; 0x3ff00000
   \   000000DA   0x.... 0x....      BL       __aeabi_ddiv
   \   000000DE   0x4622             MOV      R2,R4
   \   000000E0   0x462B             MOV      R3,R5
   \   000000E2   0x.... 0x....      BL       __aeabi_dmul
   \   000000E6   0x.... 0x....      BL       __aeabi_d2iz
   \   000000EA   0xB240             SXTB     R0,R0
   \   000000EC   0x0001             MOVS     R1,R0
   \   000000EE   0xBF48             IT       MI 
   \   000000F0   0x2000             MOVMI    R0,#+0
   \   000000F2   0xD405             BMI.N    ??get_cell_index_y_3
   \   000000F4   0xF896 0x2061      LDRB     R2,[R6, #+97]
   \   000000F8   0x1E53             SUBS     R3,R2,#+1
   \   000000FA   0x4283             CMP      R3,R0
   \   000000FC   0xBFB8             IT       LT 
   \   000000FE   0x1E50             SUBLT    R0,R2,#+1
   \                     ??get_cell_index_y_3: (+1)
   \   00000100   0xB240             SXTB     R0,R0
   \   00000102   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \   00000106   0xBF00             Nop      
   \                     ??get_cell_index_y_0:
   \   00000108   0x........         DC32     mksCfg
   \   0000010C   0x........         DC32     mksTmp
   \   00000110   0x3FF00000         DC32     0x3ff00000

  					px= (x - (MESH_MIN_X_IS_KINEMATIC) + (MESH_X_DIST_IS_KINEMATIC) * 0.5) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  					  ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\ubl.h",208  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					px= (x - (MESH_MIN_X_IS_Cartesian) + (MESH_X_DIST_IS_Cartesian) * 0.5) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  					  ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\ubl.h",210  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					py = (y - (MESH_MIN_Y_IS_KINEMATIC) + (MESH_Y_DIST_IS_KINEMATIC) * 0.5) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  					   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\ubl.h",219  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					py = (y - (MESH_MIN_Y_IS_Cartesian) + (MESH_Y_DIST_IS_Cartesian) * 0.5) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  					   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\ubl.h",221  Warning[Pa093]: 
          implicit conversion from floating point to integer

   \                                 In section .text, align 4
   \   __interwork __softfp float unified_bed_leveling::get_z_correction(float const &, float const &)
   \                     _ZN20unified_bed_leveling16get_z_correctionERKfS1_: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x.... 0x....      BL       _ZN20unified_bed_leveling16get_cell_index_xERKf
   \   0000000C   0x4605             MOV      R5,R0
   \   0000000E   0x9804             LDR      R0,[SP, #+16]
   \   00000010   0x.... 0x....      BL       _ZN20unified_bed_leveling16get_cell_index_yERKf
   \   00000014   0x4606             MOV      R6,R0
   \   00000016   0xB2E8             UXTB     R0,R5
   \   00000018   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
   \   0000001C   0x4680             MOV      R8,R0
   \   0000001E   0x1C68             ADDS     R0,R5,#+1
   \   00000020   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000024   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000028   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
   \   0000002C   0x4F4A             LDR.N    R7,??get_z_correction_0
   \   0000002E   0x9003             STR      R0,[SP, #+12]
   \   00000030   0x46A9             MOV      R9,R5
   \   00000032   0xF897 0x0060      LDRB     R0,[R7, #+96]
   \   00000036   0x1E80             SUBS     R0,R0,#+2
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xBFC8             IT       GT 
   \   0000003C   0x4681             MOVGT    R9,R0
   \   0000003E   0xF8DF 0xA11C      LDR.W    R10,??get_z_correction_0+0x4
   \   00000042   0xEB05 0x0045      ADD      R0,R5,R5, LSL #+1
   \   00000046   0xEB0A 0x1000      ADD      R0,R10,R0, LSL #+4
   \   0000004A   0x9002             STR      R0,[SP, #+8]
   \   0000004C   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   00000050   0xF8D0 0xB000      LDR      R11,[R0, #+0]
   \   00000054   0xEB09 0x0049      ADD      R0,R9,R9, LSL #+1
   \   00000058   0xEB0A 0x1000      ADD      R0,R10,R0, LSL #+4
   \   0000005C   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   00000060   0x4659             MOV      R1,R11
   \   00000062   0x6B00             LDR      R0,[R0, #+48]
   \   00000064   0x.... 0x....      BL       __aeabi_fsub
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x4641             MOV      R1,R8
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x.... 0x....      BL       __aeabi_fsub
   \   00000072   0x9900             LDR      R1,[SP, #+0]
   \   00000074   0x.... 0x....      BL       __aeabi_fmul
   \   00000078   0x9000             STR      R0,[SP, #+0]
   \   0000007A   0x4641             MOV      R1,R8
   \   0000007C   0x9803             LDR      R0,[SP, #+12]
   \   0000007E   0x.... 0x....      BL       __aeabi_fsub
   \   00000082   0x4601             MOV      R1,R0
   \   00000084   0x9800             LDR      R0,[SP, #+0]
   \   00000086   0x.... 0x....      BL       __aeabi_fdiv
   \   0000008A   0x4659             MOV      R1,R11
   \   0000008C   0x.... 0x....      BL       __aeabi_fadd
   \   00000090   0x4680             MOV      R8,R0
   \   00000092   0xB2E8             UXTB     R0,R5
   \   00000094   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
   \   00000098   0x4605             MOV      R5,R0
   \   0000009A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000009E   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
   \   000000A2   0x4683             MOV      R11,R0
   \   000000A4   0xF107 0x0060      ADD      R0,R7,#+96
   \   000000A8   0x7840             LDRB     R0,[R0, #+1]
   \   000000AA   0x1E80             SUBS     R0,R0,#+2
   \   000000AC   0x4286             CMP      R6,R0
   \   000000AE   0xBFBA             ITTE     LT 
   \   000000B0   0x4630             MOVLT    R0,R6
   \   000000B2   0x4631             MOVLT    R1,R6
   \   000000B4   0x4601             MOVGE    R1,R0
   \   000000B6   0x9A02             LDR      R2,[SP, #+8]
   \   000000B8   0xEB02 0x0181      ADD      R1,R2,R1, LSL #+2
   \   000000BC   0xF851 0x7F04      LDR      R7,[R1, #+4]!
   \   000000C0   0xEB09 0x0149      ADD      R1,R9,R9, LSL #+1
   \   000000C4   0xEB0A 0x1101      ADD      R1,R10,R1, LSL #+4
   \   000000C8   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   000000CC   0x4639             MOV      R1,R7
   \   000000CE   0x6B40             LDR      R0,[R0, #+52]
   \   000000D0   0x.... 0x....      BL       __aeabi_fsub
   \   000000D4   0x4681             MOV      R9,R0
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x4629             MOV      R1,R5
   \   000000DA   0x.... 0x....      BL       __aeabi_fsub
   \   000000DE   0x4649             MOV      R1,R9
   \   000000E0   0x.... 0x....      BL       __aeabi_fmul
   \   000000E4   0x4604             MOV      R4,R0
   \   000000E6   0x4658             MOV      R0,R11
   \   000000E8   0x4629             MOV      R1,R5
   \   000000EA   0x.... 0x....      BL       __aeabi_fsub
   \   000000EE   0x4601             MOV      R1,R0
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       __aeabi_fdiv
   \   000000F6   0x4639             MOV      R1,R7
   \   000000F8   0x.... 0x....      BL       __aeabi_fadd
   \   000000FC   0x4604             MOV      R4,R0
   \   000000FE   0xB2F0             UXTB     R0,R6
   \   00000100   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_yposEh
   \   00000104   0x4605             MOV      R5,R0
   \   00000106   0x1C70             ADDS     R0,R6,#+1
   \   00000108   0xB2C0             UXTB     R0,R0
   \   0000010A   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_yposEh
   \   0000010E   0x4606             MOV      R6,R0
   \   00000110   0x4620             MOV      R0,R4
   \   00000112   0x4641             MOV      R1,R8
   \   00000114   0x.... 0x....      BL       __aeabi_fsub
   \   00000118   0x4604             MOV      R4,R0
   \   0000011A   0x9804             LDR      R0,[SP, #+16]
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x4629             MOV      R1,R5
   \   00000120   0x.... 0x....      BL       __aeabi_fsub
   \   00000124   0x4621             MOV      R1,R4
   \   00000126   0x.... 0x....      BL       __aeabi_fmul
   \   0000012A   0x4604             MOV      R4,R0
   \   0000012C   0x4630             MOV      R0,R6
   \   0000012E   0x4629             MOV      R1,R5
   \   00000130   0x.... 0x....      BL       __aeabi_fsub
   \   00000134   0x4601             MOV      R1,R0
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0x.... 0x....      BL       __aeabi_fdiv
   \   0000013C   0x4641             MOV      R1,R8
   \   0000013E   0x.... 0x....      BL       __aeabi_fadd
   \   00000142   0x4604             MOV      R4,R0
   \   00000144   0x.... 0x....      BL       __iar_FDtest
   \   00000148   0x2802             CMP      R0,#+2
   \   0000014A   0xBF08             IT       EQ 
   \   0000014C   0x2400             MOVEQ    R4,#+0
   \   0000014E   0x4620             MOV      R0,R4
   \   00000150   0xB005             ADD      SP,SP,#+20
   \   00000152   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \   00000156   0xBF00             Nop      
   \                     ??get_z_correction_0:
   \   00000158   0x........         DC32     mksCfg
   \   0000015C   0x........         DC32     _ZN20unified_bed_leveling8z_valuesE

   \                                 In section .text, align 4
   \   __interwork __softfp float unified_bed_leveling::mesh_index_to_xpos(uint8_t)
   \                     _ZN20unified_bed_leveling18mesh_index_to_xposEh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4E40             LDR.N    R6,??mesh_index_to_xpos_0
   \   00000008   0xF896 0x7060      LDRB     R7,[R6, #+96]
   \   0000000C   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000010   0xF240 0x3202      MOVW     R2,#+770
   \   00000014   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   00000018   0x4211             TST      R1,R2
   \   0000001A   0xD021             BEQ.N    ??mesh_index_to_xpos_1
   \   0000001C   0x45B8             CMP      R8,R7
   \   0000001E   0xD321             BCC.N    ??mesh_index_to_xpos_2
   \   00000020   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   00000024   0x.... 0x....      BL       __aeabi_ui2f
   \   00000028   0x4C38             LDR.N    R4,??mesh_index_to_xpos_0+0x4
   \   0000002A   0x4605             MOV      R5,R0
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x.... 0x....      BL       __aeabi_fadd
   \   00000034   0x4606             MOV      R6,R0
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       __aeabi_ui2f
   \   0000003C   0x4680             MOV      R8,R0
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0x4629             MOV      R1,R5
   \   00000042   0x.... 0x....      BL       __aeabi_fsub
   \   00000046   0x4631             MOV      R1,R6
   \   00000048   0x.... 0x....      BL       __aeabi_fsub
   \   0000004C   0x4604             MOV      R4,R0
   \   0000004E   0x1E78             SUBS     R0,R7,#+1
   \   00000050   0x.... 0x....      BL       __aeabi_i2f
   \   00000054   0x4601             MOV      R1,R0
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       __aeabi_fdiv
   \   0000005C   0x4641             MOV      R1,R8
   \   0000005E   0xE04C             B.N      ??mesh_index_to_xpos_3
   \                     ??mesh_index_to_xpos_1: (+1)
   \   00000060   0x45B8             CMP      R8,R7
   \   00000062   0xD204             BCS.N    ??mesh_index_to_xpos_4
   \                     ??mesh_index_to_xpos_2: (+1)
   \   00000064   0x482A             LDR.N    R0,??mesh_index_to_xpos_0+0x8
   \   00000066   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   0000006A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   \                     ??mesh_index_to_xpos_4: (+1)
   \   0000006E   0x68C5             LDR      R5,[R0, #+12]
   \   00000070   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000074   0x4629             MOV      R1,R5
   \   00000076   0x.... 0x....      BL       __aeabi_fmul
   \   0000007A   0x4681             MOV      R9,R0
   \   0000007C   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   00000080   0x.... 0x....      BL       __aeabi_ui2f
   \   00000084   0x4682             MOV      R10,R0
   \   00000086   0x4648             MOV      R0,R9
   \   00000088   0x4649             MOV      R1,R9
   \   0000008A   0x.... 0x....      BL       __aeabi_fsub
   \   0000008E   0x4651             MOV      R1,R10
   \   00000090   0x.... 0x....      BL       __aeabi_fadd
   \   00000094   0x4604             MOV      R4,R0
   \   00000096   0xF106 0x0060      ADD      R0,R6,#+96
   \   0000009A   0xF8D0 0xB00C      LDR      R11,[R0, #+12]
   \   0000009E   0x68B0             LDR      R0,[R6, #+8]
   \   000000A0   0x4659             MOV      R1,R11
   \   000000A2   0x.... 0x....      BL       __aeabi_fadd
   \   000000A6   0x4621             MOV      R1,R4
   \   000000A8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000AC   0x4606             MOV      R6,R0
   \   000000AE   0xBF38             IT       CC 
   \   000000B0   0x4626             MOVCC    R6,R4
   \   000000B2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000B6   0x4649             MOV      R1,R9
   \   000000B8   0x.... 0x....      BL       __aeabi_fmul
   \   000000BC   0x4651             MOV      R1,R10
   \   000000BE   0x.... 0x....      BL       __aeabi_fsub
   \   000000C2   0x4604             MOV      R4,R0
   \   000000C4   0x4628             MOV      R0,R5
   \   000000C6   0x4659             MOV      R1,R11
   \   000000C8   0x.... 0x....      BL       __aeabi_fadd
   \   000000CC   0x4601             MOV      R1,R0
   \   000000CE   0x4620             MOV      R0,R4
   \   000000D0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D4   0xBF28             IT       CS 
   \   000000D6   0x460C             MOVCS    R4,R1
   \   000000D8   0x4640             MOV      R0,R8
   \   000000DA   0x.... 0x....      BL       __aeabi_ui2f
   \   000000DE   0x4605             MOV      R5,R0
   \   000000E0   0x4620             MOV      R0,R4
   \   000000E2   0x4631             MOV      R1,R6
   \   000000E4   0x.... 0x....      BL       __aeabi_fsub
   \   000000E8   0x4604             MOV      R4,R0
   \   000000EA   0x1E78             SUBS     R0,R7,#+1
   \   000000EC   0x.... 0x....      BL       __aeabi_i2f
   \   000000F0   0x4601             MOV      R1,R0
   \   000000F2   0x4620             MOV      R0,R4
   \   000000F4   0x.... 0x....      BL       __aeabi_fdiv
   \   000000F8   0x4629             MOV      R1,R5
   \                     ??mesh_index_to_xpos_3: (+1)
   \   000000FA   0x.... 0x....      BL       __aeabi_fmul
   \   000000FE   0x4631             MOV      R1,R6
   \   00000100   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000104   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_xpos_0:
   \   00000108   0x........         DC32     mksCfg
   \   0000010C   0x........         DC32     mksTmp
   \   00000110   0x........         DC32     _ZN20unified_bed_leveling19_mesh_index_to_xposE

   \                                 In section .text, align 4
   \   __interwork __softfp float unified_bed_leveling::mesh_index_to_ypos(uint8_t)
   \                     _ZN20unified_bed_leveling18mesh_index_to_yposEh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4E3F             LDR.N    R6,??mesh_index_to_ypos_0
   \   00000008   0xF896 0x7061      LDRB     R7,[R6, #+97]
   \   0000000C   0xF106 0x000C      ADD      R0,R6,#+12
   \   00000010   0xF240 0x3202      MOVW     R2,#+770
   \   00000014   0xF8B0 0x104C      LDRH     R1,[R0, #+76]
   \   00000018   0x4211             TST      R1,R2
   \   0000001A   0xD021             BEQ.N    ??mesh_index_to_ypos_1
   \   0000001C   0x45B8             CMP      R8,R7
   \   0000001E   0xD321             BCC.N    ??mesh_index_to_ypos_2
   \   00000020   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   00000024   0x.... 0x....      BL       __aeabi_ui2f
   \   00000028   0x4C37             LDR.N    R4,??mesh_index_to_ypos_0+0x4
   \   0000002A   0x4605             MOV      R5,R0
   \   0000002C   0x68A0             LDR      R0,[R4, #+8]
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x.... 0x....      BL       __aeabi_fadd
   \   00000034   0x4606             MOV      R6,R0
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       __aeabi_ui2f
   \   0000003C   0x4680             MOV      R8,R0
   \   0000003E   0x68E0             LDR      R0,[R4, #+12]
   \   00000040   0x4629             MOV      R1,R5
   \   00000042   0x.... 0x....      BL       __aeabi_fsub
   \   00000046   0x4631             MOV      R1,R6
   \   00000048   0x.... 0x....      BL       __aeabi_fsub
   \   0000004C   0x4604             MOV      R4,R0
   \   0000004E   0x1E78             SUBS     R0,R7,#+1
   \   00000050   0x.... 0x....      BL       __aeabi_i2f
   \   00000054   0x4601             MOV      R1,R0
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       __aeabi_fdiv
   \   0000005C   0x4641             MOV      R1,R8
   \   0000005E   0xE04A             B.N      ??mesh_index_to_ypos_3
   \                     ??mesh_index_to_ypos_1: (+1)
   \   00000060   0x45B8             CMP      R8,R7
   \   00000062   0xD204             BCS.N    ??mesh_index_to_ypos_4
   \                     ??mesh_index_to_ypos_2: (+1)
   \   00000064   0x4829             LDR.N    R0,??mesh_index_to_ypos_0+0x8
   \   00000066   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   0000006A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   \                     ??mesh_index_to_ypos_4: (+1)
   \   0000006E   0x68C5             LDR      R5,[R0, #+12]
   \   00000070   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000074   0x4629             MOV      R1,R5
   \   00000076   0x.... 0x....      BL       __aeabi_fmul
   \   0000007A   0x4681             MOV      R9,R0
   \   0000007C   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   00000080   0x.... 0x....      BL       __aeabi_ui2f
   \   00000084   0x4682             MOV      R10,R0
   \   00000086   0x4648             MOV      R0,R9
   \   00000088   0x4649             MOV      R1,R9
   \   0000008A   0x.... 0x....      BL       __aeabi_fsub
   \   0000008E   0x4651             MOV      R1,R10
   \   00000090   0x.... 0x....      BL       __aeabi_fadd
   \   00000094   0x4604             MOV      R4,R0
   \   00000096   0xF8D6 0xB070      LDR      R11,[R6, #+112]
   \   0000009A   0x68F0             LDR      R0,[R6, #+12]
   \   0000009C   0x4659             MOV      R1,R11
   \   0000009E   0x.... 0x....      BL       __aeabi_fadd
   \   000000A2   0x4621             MOV      R1,R4
   \   000000A4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000A8   0x4606             MOV      R6,R0
   \   000000AA   0xBF38             IT       CC 
   \   000000AC   0x4626             MOVCC    R6,R4
   \   000000AE   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000B2   0x4649             MOV      R1,R9
   \   000000B4   0x.... 0x....      BL       __aeabi_fmul
   \   000000B8   0x4651             MOV      R1,R10
   \   000000BA   0x.... 0x....      BL       __aeabi_fsub
   \   000000BE   0x4604             MOV      R4,R0
   \   000000C0   0x4628             MOV      R0,R5
   \   000000C2   0x4659             MOV      R1,R11
   \   000000C4   0x.... 0x....      BL       __aeabi_fadd
   \   000000C8   0x4601             MOV      R1,R0
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D0   0xBF28             IT       CS 
   \   000000D2   0x460C             MOVCS    R4,R1
   \   000000D4   0x4640             MOV      R0,R8
   \   000000D6   0x.... 0x....      BL       __aeabi_ui2f
   \   000000DA   0x4605             MOV      R5,R0
   \   000000DC   0x4620             MOV      R0,R4
   \   000000DE   0x4631             MOV      R1,R6
   \   000000E0   0x.... 0x....      BL       __aeabi_fsub
   \   000000E4   0x4604             MOV      R4,R0
   \   000000E6   0x1E78             SUBS     R0,R7,#+1
   \   000000E8   0x.... 0x....      BL       __aeabi_i2f
   \   000000EC   0x4601             MOV      R1,R0
   \   000000EE   0x4620             MOV      R0,R4
   \   000000F0   0x.... 0x....      BL       __aeabi_fdiv
   \   000000F4   0x4629             MOV      R1,R5
   \                     ??mesh_index_to_ypos_3: (+1)
   \   000000F6   0x.... 0x....      BL       __aeabi_fmul
   \   000000FA   0x4631             MOV      R1,R6
   \   000000FC   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000100   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_ypos_0:
   \   00000104   0x........         DC32     mksCfg
   \   00000108   0x........         DC32     mksTmp
   \   0000010C   0x........         DC32     _ZN20unified_bed_leveling19_mesh_index_to_yposE
     69          #include "gcode.h"

   \                                 In section .text, align 4
   \   __interwork __softfp float GCodeParser::value_float()
   \                     _ZN11GCodeParser11value_floatEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4B11             LDR.N    R3,??value_float_0
   \   00000004   0x6818             LDR      R0,[R3, #+0]
   \   00000006   0xB1E8             CBZ.N    R0,??value_float_1
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0xE000             B.N      ??value_float_2
   \                     ??value_float_3: (+1)
   \   0000000C   0x1C64             ADDS     R4,R4,#+1
   \                     ??value_float_2: (+1)
   \   0000000E   0xF994 0x5000      LDRSB    R5,[R4, #+0]
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2D20             CMPNE    R5,#+32
   \   00000018   0xD104             BNE.N    ??value_float_4
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x.... 0x....      BL       __iar_Stod
   \   00000022   0xE00B             B.N      ??value_float_5
   \                     ??value_float_4: (+1)
   \   00000024   0x2D45             CMP      R5,#+69
   \   00000026   0xBF18             IT       NE 
   \   00000028   0x2D65             CMPNE    R5,#+101
   \   0000002A   0xD1EF             BNE.N    ??value_float_3
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7020             STRB     R0,[R4, #+0]
   \   00000030   0x4601             MOV      R1,R0
   \   00000032   0x6818             LDR      R0,[R3, #+0]
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x.... 0x....      BL       __iar_Stod
   \   0000003A   0x7025             STRB     R5,[R4, #+0]
   \                     ??value_float_5: (+1)
   \   0000003C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000040   0x.... 0x....      B.W      __aeabi_d2f
   \                     ??value_float_1: (+1)
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \   00000046   0xBF00             Nop      
   \                     ??value_float_0:
   \   00000048   0x........         DC32     _ZN11GCodeParser9value_ptrE

    FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
                                                                      ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\gcode.h",207  Warning[Pa093]: 
          implicit conversion from floating point to integer
     70          
     71          
     72          
     73          #if 1//ENABLED(MESH_BED_LEVELING)
     74            #include "mesh_bed_leveling.h"

  	#define MESH_X_DIST_IS_KINEMATIC ((MESH_MAX_X_IS_KINEMATIC - (MESH_MIN_X_IS_KINEMATIC)) / (GRID_MAX_POINTS_X - 1))
  	        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",41  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_X_DIST_IS_KINEMATIC"
          (declared at line 74 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\ubl.h")

  	#define MESH_Y_DIST_IS_KINEMATIC ((MESH_MAX_Y_IS_KINEMATIC - (MESH_MIN_Y_IS_KINEMATIC)) / (GRID_MAX_POINTS_Y - 1))
  	        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",42  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_Y_DIST_IS_KINEMATIC"
          (declared at line 75 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\ubl.h")

  	#define MESH_X_DIST_IS_Cartesian ((MESH_MAX_X_IS_Cartesian - (MESH_MIN_X_IS_Cartesian)) / (GRID_MAX_POINTS_X - 1))
  	        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",43  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_X_DIST_IS_Cartesian"
          (declared at line 76 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\ubl.h")

  	#define MESH_Y_DIST_IS_Cartesian ((MESH_MAX_Y_IS_Cartesian - (MESH_MIN_Y_IS_Cartesian)) / (GRID_MAX_POINTS_Y - 1))
  	        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",44  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_Y_DIST_IS_Cartesian"
          (declared at line 77 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\ubl.h")

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_x(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_xERKf: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4E41             LDR.N    R6,??cell_index_x_0
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4680             MOV      R8,R0
   \   00000012   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000016   0xF240 0x3202      MOVW     R2,#+770
   \   0000001A   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD013             BEQ.N    ??cell_index_x_1

  				cx= (x - (MESH_MIN_X_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  				  ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",83  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0x4F3B             LDR.N    R7,??cell_index_x_0+0x4
   \   00000024   0x6838             LDR      R0,[R7, #+0]
   \   00000026   0x4641             MOV      R1,R8
   \   00000028   0x.... 0x....      BL       __aeabi_fadd
   \   0000002C   0x4681             MOV      R9,R0
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x4649             MOV      R1,R9
   \   00000032   0x.... 0x....      BL       __aeabi_fsub
   \   00000036   0x.... 0x....      BL       __aeabi_f2d
   \   0000003A   0x4604             MOV      R4,R0
   \   0000003C   0x460D             MOV      R5,R1
   \   0000003E   0x6878             LDR      R0,[R7, #+4]
   \   00000040   0x4641             MOV      R1,R8
   \   00000042   0x.... 0x....      BL       __aeabi_fsub
   \   00000046   0x4649             MOV      R1,R9
   \   00000048   0xE037             B.N      ??cell_index_x_2

  				cx= (x - (MESH_MIN_X_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  				  ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",87  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??cell_index_x_1: (+1)
   \   0000004A   0x68C5             LDR      R5,[R0, #+12]
   \   0000004C   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x.... 0x....      BL       __aeabi_fmul
   \   00000056   0x4682             MOV      R10,R0
   \   00000058   0x4651             MOV      R1,R10
   \   0000005A   0x.... 0x....      BL       __aeabi_fsub
   \   0000005E   0x4641             MOV      R1,R8
   \   00000060   0x.... 0x....      BL       __aeabi_fadd
   \   00000064   0x4607             MOV      R7,R0
   \   00000066   0xF106 0x0060      ADD      R0,R6,#+96
   \   0000006A   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \   0000006E   0x68B0             LDR      R0,[R6, #+8]
   \   00000070   0x4649             MOV      R1,R9
   \   00000072   0x.... 0x....      BL       __aeabi_fadd
   \   00000076   0x4639             MOV      R1,R7
   \   00000078   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000007C   0xBF28             IT       CS 
   \   0000007E   0x4607             MOVCS    R7,R0
   \   00000080   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000084   0x4651             MOV      R1,R10
   \   00000086   0x.... 0x....      BL       __aeabi_fmul
   \   0000008A   0x4641             MOV      R1,R8
   \   0000008C   0x.... 0x....      BL       __aeabi_fsub
   \   00000090   0x4680             MOV      R8,R0
   \   00000092   0x4628             MOV      R0,R5
   \   00000094   0x4649             MOV      R1,R9
   \   00000096   0x.... 0x....      BL       __aeabi_fadd
   \   0000009A   0x4601             MOV      R1,R0
   \   0000009C   0x4640             MOV      R0,R8
   \   0000009E   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000A2   0xBF28             IT       CS 
   \   000000A4   0x4688             MOVCS    R8,R1
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x4639             MOV      R1,R7
   \   000000AA   0x.... 0x....      BL       __aeabi_fsub
   \   000000AE   0x.... 0x....      BL       __aeabi_f2d
   \   000000B2   0x4604             MOV      R4,R0
   \   000000B4   0x460D             MOV      R5,R1
   \   000000B6   0x4640             MOV      R0,R8
   \   000000B8   0x4639             MOV      R1,R7
   \                     ??cell_index_x_2: (+1)
   \   000000BA   0x.... 0x....      BL       __aeabi_fsub
   \   000000BE   0x4607             MOV      R7,R0
   \   000000C0   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   000000C4   0x1E40             SUBS     R0,R0,#+1
   \   000000C6   0x.... 0x....      BL       __aeabi_i2f
   \   000000CA   0x4601             MOV      R1,R0
   \   000000CC   0x4638             MOV      R0,R7
   \   000000CE   0x.... 0x....      BL       __aeabi_fdiv
   \   000000D2   0x.... 0x....      BL       __aeabi_f2d
   \   000000D6   0x4602             MOV      R2,R0
   \   000000D8   0x460B             MOV      R3,R1
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x490D             LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
   \   000000DE   0x.... 0x....      BL       __aeabi_ddiv
   \   000000E2   0x4622             MOV      R2,R4
   \   000000E4   0x462B             MOV      R3,R5
   \   000000E6   0x.... 0x....      BL       __aeabi_dmul
   \   000000EA   0x.... 0x....      BL       __aeabi_d2iz
   \   000000EE   0xB240             SXTB     R0,R0
   \   000000F0   0x0001             MOVS     R1,R0
   \   000000F2   0xBF48             IT       MI 
   \   000000F4   0x2000             MOVMI    R0,#+0
   \   000000F6   0xD405             BMI.N    ??cell_index_x_3
   \   000000F8   0xF896 0x2060      LDRB     R2,[R6, #+96]
   \   000000FC   0x1E93             SUBS     R3,R2,#+2
   \   000000FE   0x4283             CMP      R3,R0
   \   00000100   0xBFB8             IT       LT 
   \   00000102   0x1E90             SUBLT    R0,R2,#+2
   \                     ??cell_index_x_3: (+1)
   \   00000104   0xB240             SXTB     R0,R0
   \   00000106   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \   0000010A   0xBF00             Nop      
   \                     ??cell_index_x_0:
   \   0000010C   0x........         DC32     mksCfg
   \   00000110   0x........         DC32     mksTmp
   \   00000114   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_y(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_yERKf: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4E40             LDR.N    R6,??cell_index_y_0
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4680             MOV      R8,R0
   \   00000012   0xF106 0x000C      ADD      R0,R6,#+12
   \   00000016   0xF240 0x3202      MOVW     R2,#+770
   \   0000001A   0xF8B0 0x104C      LDRH     R1,[R0, #+76]
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD013             BEQ.N    ??cell_index_y_1

  				cy= (y - (MESH_MIN_Y_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  				  ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",95  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0x4F3A             LDR.N    R7,??cell_index_y_0+0x4
   \   00000024   0x68B8             LDR      R0,[R7, #+8]
   \   00000026   0x4641             MOV      R1,R8
   \   00000028   0x.... 0x....      BL       __aeabi_fadd
   \   0000002C   0x4681             MOV      R9,R0
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x4649             MOV      R1,R9
   \   00000032   0x.... 0x....      BL       __aeabi_fsub
   \   00000036   0x.... 0x....      BL       __aeabi_f2d
   \   0000003A   0x4604             MOV      R4,R0
   \   0000003C   0x460D             MOV      R5,R1
   \   0000003E   0x68F8             LDR      R0,[R7, #+12]
   \   00000040   0x4641             MOV      R1,R8
   \   00000042   0x.... 0x....      BL       __aeabi_fsub
   \   00000046   0x4649             MOV      R1,R9
   \   00000048   0xE035             B.N      ??cell_index_y_2

  				cy= (y - (MESH_MIN_Y_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  				  ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",97  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??cell_index_y_1: (+1)
   \   0000004A   0x68C5             LDR      R5,[R0, #+12]
   \   0000004C   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x.... 0x....      BL       __aeabi_fmul
   \   00000056   0x4682             MOV      R10,R0
   \   00000058   0x4651             MOV      R1,R10
   \   0000005A   0x.... 0x....      BL       __aeabi_fsub
   \   0000005E   0x4641             MOV      R1,R8
   \   00000060   0x.... 0x....      BL       __aeabi_fadd
   \   00000064   0x4607             MOV      R7,R0
   \   00000066   0xF8D6 0x9070      LDR      R9,[R6, #+112]
   \   0000006A   0x68F0             LDR      R0,[R6, #+12]
   \   0000006C   0x4649             MOV      R1,R9
   \   0000006E   0x.... 0x....      BL       __aeabi_fadd
   \   00000072   0x4639             MOV      R1,R7
   \   00000074   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000078   0xBF28             IT       CS 
   \   0000007A   0x4607             MOVCS    R7,R0
   \   0000007C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000080   0x4651             MOV      R1,R10
   \   00000082   0x.... 0x....      BL       __aeabi_fmul
   \   00000086   0x4641             MOV      R1,R8
   \   00000088   0x.... 0x....      BL       __aeabi_fsub
   \   0000008C   0x4680             MOV      R8,R0
   \   0000008E   0x4628             MOV      R0,R5
   \   00000090   0x4649             MOV      R1,R9
   \   00000092   0x.... 0x....      BL       __aeabi_fadd
   \   00000096   0x4601             MOV      R1,R0
   \   00000098   0x4640             MOV      R0,R8
   \   0000009A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000009E   0xBF28             IT       CS 
   \   000000A0   0x4688             MOVCS    R8,R1
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x4639             MOV      R1,R7
   \   000000A6   0x.... 0x....      BL       __aeabi_fsub
   \   000000AA   0x.... 0x....      BL       __aeabi_f2d
   \   000000AE   0x4604             MOV      R4,R0
   \   000000B0   0x460D             MOV      R5,R1
   \   000000B2   0x4640             MOV      R0,R8
   \   000000B4   0x4639             MOV      R1,R7
   \                     ??cell_index_y_2: (+1)
   \   000000B6   0x.... 0x....      BL       __aeabi_fsub
   \   000000BA   0x4607             MOV      R7,R0
   \   000000BC   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   000000C0   0x1E40             SUBS     R0,R0,#+1
   \   000000C2   0x.... 0x....      BL       __aeabi_i2f
   \   000000C6   0x4601             MOV      R1,R0
   \   000000C8   0x4638             MOV      R0,R7
   \   000000CA   0x.... 0x....      BL       __aeabi_fdiv
   \   000000CE   0x.... 0x....      BL       __aeabi_f2d
   \   000000D2   0x4602             MOV      R2,R0
   \   000000D4   0x460B             MOV      R3,R1
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x490D             LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
   \   000000DA   0x.... 0x....      BL       __aeabi_ddiv
   \   000000DE   0x4622             MOV      R2,R4
   \   000000E0   0x462B             MOV      R3,R5
   \   000000E2   0x.... 0x....      BL       __aeabi_dmul
   \   000000E6   0x.... 0x....      BL       __aeabi_d2iz
   \   000000EA   0xB240             SXTB     R0,R0
   \   000000EC   0x0001             MOVS     R1,R0
   \   000000EE   0xBF48             IT       MI 
   \   000000F0   0x2000             MOVMI    R0,#+0
   \   000000F2   0xD405             BMI.N    ??cell_index_y_3
   \   000000F4   0xF896 0x2061      LDRB     R2,[R6, #+97]
   \   000000F8   0x1E93             SUBS     R3,R2,#+2
   \   000000FA   0x4283             CMP      R3,R0
   \   000000FC   0xBFB8             IT       LT 
   \   000000FE   0x1E90             SUBLT    R0,R2,#+2
   \                     ??cell_index_y_3: (+1)
   \   00000100   0xB240             SXTB     R0,R0
   \   00000102   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \   00000106   0xBF00             Nop      
   \                     ??cell_index_y_0:
   \   00000108   0x........         DC32     mksCfg
   \   0000010C   0x........         DC32     mksTmp
   \   00000110   0x3FF00000         DC32     0x3ff00000

  				px = (x - (MESH_MIN_X_IS_KINEMATIC) + 0.5 * (MESH_X_DIST_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  				   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",105  Warning[Pa093]: 
          implicit conversion from floating point to integer

  				px = (x - (MESH_MIN_X_IS_Cartesian) + 0.5 * (MESH_X_DIST_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  				   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",107  Warning[Pa093]: 
          implicit conversion from floating point to integer

        	py = (y - (MESH_MIN_Y_IS_KINEMATIC) + 0.5 * (MESH_Y_DIST_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
        	   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",115  Warning[Pa093]: 
          implicit conversion from floating point to integer

  				py = (y - (MESH_MIN_Y_IS_Cartesian) + 0.5 * (MESH_Y_DIST_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  				   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",117  Warning[Pa093]: 
          implicit conversion from floating point to integer

   \                                 In section .text, align 4
   \   __interwork __softfp float mesh_bed_leveling::get_z(float const &, float const &, float const &)
   \                     _ZN17mesh_bed_leveling5get_zERKfS1_S1_: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4691             MOV      R9,R2
   \   0000000C   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_xERKf
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_yERKf
   \   00000018   0x4606             MOV      R6,R0
   \   0000001A   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   0000001E   0x4938             LDR.N    R1,??get_z_0
   \   00000020   0x4A38             LDR.N    R2,??get_z_0+0x4
   \   00000022   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000026   0xEB00 0x0186      ADD      R1,R0,R6, LSL #+2
   \   0000002A   0xEB02 0x0787      ADD      R7,R2,R7, LSL #+2
   \   0000002E   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   00000032   0x9102             STR      R1,[SP, #+8]
   \   00000034   0x9001             STR      R0,[SP, #+4]
   \   00000036   0xF8D1 0x8000      LDR      R8,[R1, #+0]
   \   0000003A   0x683D             LDR      R5,[R7, #+0]
   \   0000003C   0xF8DA 0xB000      LDR      R11,[R10, #+0]
   \   00000040   0x4658             MOV      R0,R11
   \   00000042   0x4629             MOV      R1,R5
   \   00000044   0x.... 0x....      BL       __aeabi_fsub
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0x4641             MOV      R1,R8
   \   0000004C   0x9801             LDR      R0,[SP, #+4]
   \   0000004E   0x6B00             LDR      R0,[R0, #+48]
   \   00000050   0x.... 0x....      BL       __aeabi_fsub
   \   00000054   0x4682             MOV      R10,R0
   \   00000056   0x6878             LDR      R0,[R7, #+4]
   \   00000058   0x4629             MOV      R1,R5
   \   0000005A   0x.... 0x....      BL       __aeabi_fsub
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x4650             MOV      R0,R10
   \   00000062   0x.... 0x....      BL       __aeabi_fdiv
   \   00000066   0x9900             LDR      R1,[SP, #+0]
   \   00000068   0x.... 0x....      BL       __aeabi_fmul
   \   0000006C   0x4641             MOV      R1,R8
   \   0000006E   0x.... 0x....      BL       __aeabi_fadd
   \   00000072   0x4680             MOV      R8,R0
   \   00000074   0x9802             LDR      R0,[SP, #+8]
   \   00000076   0xF8D7 0xA000      LDR      R10,[R7, #+0]
   \   0000007A   0xF850 0x5F04      LDR      R5,[R0, #+4]!
   \   0000007E   0x4658             MOV      R0,R11
   \   00000080   0x4651             MOV      R1,R10
   \   00000082   0x.... 0x....      BL       __aeabi_fsub
   \   00000086   0x9000             STR      R0,[SP, #+0]
   \   00000088   0x4629             MOV      R1,R5
   \   0000008A   0x9801             LDR      R0,[SP, #+4]
   \   0000008C   0x6B40             LDR      R0,[R0, #+52]
   \   0000008E   0x.... 0x....      BL       __aeabi_fsub
   \   00000092   0x4683             MOV      R11,R0
   \   00000094   0x6878             LDR      R0,[R7, #+4]
   \   00000096   0x4651             MOV      R1,R10
   \   00000098   0x.... 0x....      BL       __aeabi_fsub
   \   0000009C   0x4601             MOV      R1,R0
   \   0000009E   0x4658             MOV      R0,R11
   \   000000A0   0x.... 0x....      BL       __aeabi_fdiv
   \   000000A4   0x9900             LDR      R1,[SP, #+0]
   \   000000A6   0x.... 0x....      BL       __aeabi_fmul
   \   000000AA   0x4629             MOV      R1,R5
   \   000000AC   0x.... 0x....      BL       __aeabi_fadd
   \   000000B0   0x4607             MOV      R7,R0
   \   000000B2   0x4815             LDR.N    R0,??get_z_0+0x8
   \   000000B4   0xEB00 0x0686      ADD      R6,R0,R6, LSL #+2
   \   000000B8   0x6835             LDR      R5,[R6, #+0]
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x4629             MOV      R1,R5
   \   000000BE   0x.... 0x....      BL       __aeabi_fsub
   \   000000C2   0x4604             MOV      R4,R0
   \   000000C4   0x4638             MOV      R0,R7
   \   000000C6   0x4641             MOV      R1,R8
   \   000000C8   0x.... 0x....      BL       __aeabi_fsub
   \   000000CC   0x4607             MOV      R7,R0
   \   000000CE   0x6870             LDR      R0,[R6, #+4]
   \   000000D0   0x4629             MOV      R1,R5
   \   000000D2   0x.... 0x....      BL       __aeabi_fsub
   \   000000D6   0x4601             MOV      R1,R0
   \   000000D8   0x4638             MOV      R0,R7
   \   000000DA   0x.... 0x....      BL       __aeabi_fdiv
   \   000000DE   0x4621             MOV      R1,R4
   \   000000E0   0x.... 0x....      BL       __aeabi_fmul
   \   000000E4   0x4641             MOV      R1,R8
   \   000000E6   0x.... 0x....      BL       __aeabi_fadd
   \   000000EA   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   000000EE   0x.... 0x....      BL       __aeabi_fmul
   \   000000F2   0xB003             ADD      SP,SP,#+12
   \   000000F4   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000000F8   0x4904             LDR.N    R1,??get_z_0+0xC
   \   000000FA   0x6809             LDR      R1,[R1, #+0]
   \   000000FC   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??get_z_0:
   \   00000100   0x........         DC32     _ZN17mesh_bed_leveling8z_valuesE
   \   00000104   0x........         DC32     _ZN17mesh_bed_leveling13index_to_xposE
   \   00000108   0x........         DC32     _ZN17mesh_bed_leveling13index_to_yposE
   \   0000010C   0x........         DC32     _ZN17mesh_bed_leveling8z_offsetE
     75          #endif
     76          

   \                                 In section .bss, align 4
     77          Planner planner;
     78          
     79            // public:
     80          
     81          /**
     82           * A ring buffer of moves described in steps
     83           */
     84          block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
     85          volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next block to be pushed
     86                           Planner::block_buffer_tail = 0;
     87          
     88          float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
     89                Planner::axis_steps_per_mm[XYZE_N],
     90                Planner::steps_to_mm[XYZE_N];
     91          
     92          #if ENABLED(DISTINCT_E_FACTORS)
     93            uint8_t Planner::last_extruder = 0;     // Respond to extruder change
     94          #endif
     95          
     96          int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
     97          
     98          float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0); // The flow percentage and volumetric multiplier combine to scale E movement
     99          
    100          #if DISABLED(NO_VOLUMETRICS)
    101            float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
    102                  Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
   \                     _ZN7Planner23volumetric_area_nominalE:
   \   00000000                      DS8 4
   \                     planner:
   \   00000004                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner12block_bufferE:
   \   00000000                      DS8 1344
    103                  Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
    104          #endif
    105          
    106          unsigned long Planner::max_acceleration_steps_per_s2[XYZE_N],
    107                   Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
    108          
    109          uint32_t Planner::min_segment_time_us;
    110          
    111          // Initialized by settings.load()
    112          float Planner::min_feedrate_mm_s,
    113                Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
    114                Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
    115                Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
    116                Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
    117                Planner::min_travel_feedrate_mm_s;
    118          
    119          #if 1//HAS_LEVELING
    120            bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
    121            #if 1//ABL_PLANAR
    122              matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
    123            #endif
    124            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    125              float Planner::z_fade_height,      // Initialized by settings.load()
    126                    Planner::inverse_z_fade_height,
    127                    Planner::last_fade_z;
    128            #endif
    129          #else
    130            constexpr bool Planner::leveling_active;
    131          #endif
    132          
    133          #if ENABLED(SKEW_CORRECTION)
    134            #if ENABLED(SKEW_CORRECTION_GCODE)
    135              float Planner::xy_skew_factor;
    136            #else
    137              constexpr float Planner::xy_skew_factor;
    138            #endif
    139            #if ENABLED(SKEW_CORRECTION_FOR_Z) && ENABLED(SKEW_CORRECTION_GCODE)
    140              float Planner::xz_skew_factor, Planner::yz_skew_factor;
    141            #else
    142              constexpr float Planner::xz_skew_factor, Planner::yz_skew_factor;
    143            #endif
    144          #endif
    145          
    146          #if ENABLED(AUTOTEMP)
    147            float Planner::autotemp_max = 250,
    148                  Planner::autotemp_min = 210,
    149                  Planner::autotemp_factor = 0.1;
    150            bool Planner::autotemp_enabled = false;
    151          #endif
    152          
    153          // private:
    154          
    155          int32_t Planner::position[NUM_AXIS] = { 0 };
    156          
    157          uint32_t Planner::cutoff_long;
    158          
    159          float Planner::previous_speed[NUM_AXIS],
    160                Planner::previous_nominal_speed;
    161          
    162          #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
    163            uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
    164          #endif
    165          
    166          #ifdef XY_FREQUENCY_LIMIT
    167            // Old direction bits. Used for speed calculations
    168            unsigned char Planner::old_direction_bits = 0;
    169            // Segment times (in µs). Used for speed calculations
    170            uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
    171          #endif
    172          
    173          #if ENABLED(LIN_ADVANCE)
    174            float Planner::extruder_advance_k, // Initialized by settings.load()
    175                  Planner::advance_ed_ratio,   // Initialized by settings.load()
    176                  Planner::position_float[XYZE], // Needed for accurate maths. Steps cannot be used!
    177                  Planner::lin_dist_xy,
    178                  Planner::lin_dist_e;
    179          #endif
    180          
    181          #if ENABLED(ULTRA_LCD)
    182            volatile uint32_t Planner::block_buffer_runtime_us = 0;
    183          #endif
    184          
    185          /**
    186           * Class and Instance Methods
    187           */
    188          

   \                                 In section .text, align 2, keep-with-next
    189          Planner::Planner() { init(); }
   \                     _ZN7PlannerC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x.... 0x....      BL       _ZN7Planner4initEv
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0xBD10             POP      {R4,PC}          ;; return
    190          

   \                                 In section .text, align 2, keep-with-next
    191          void Planner::init() {
   \                     _ZN7Planner4initEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    192            block_buffer_head = block_buffer_tail = 0;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable10_5
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7060             STRB     R0,[R4, #+1]
   \   0000000A   0x7020             STRB     R0,[R4, #+0]
    193            ZERO(position);
   \   0000000C   0x2510             MOVS     R5,#+16
   \   0000000E   0x4602             MOV      R2,R0
   \   00000010   0x2600             MOVS     R6,#+0
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0xF104 0x0040      ADD      R0,R4,#+64
   \   00000018   0x.... 0x....      BL       __aeabi_memset4
    194            #if ENABLED(LIN_ADVANCE)
    195              ZERO(position_float);
    196            #endif
    197            ZERO(previous_speed);
   \   0000001C   0x4632             MOV      R2,R6
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0xF104 0x0068      ADD      R0,R4,#+104
   \   00000024   0x.... 0x....      BL       __aeabi_memset4
    198            previous_nominal_speed = 0.0;
   \   00000028   0x67A6             STR      R6,[R4, #+120]
    199            #if 1//ABL_PLANAR
    200              bed_level_matrix.set_to_identity();
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   0000002E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000032   0x.... 0x....      B.W      _ZN10matrix_3x315set_to_identityEv
    201            #endif
    202          }
    203          
    204          #define MINIMAL_STEP_RATE 120
    205          
    206          /**
    207           * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
    208           * by the provided factors.
    209           */

   \                                 In section .text, align 4, keep-with-next
    210          void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
   \                     _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB085             SUB      SP,SP,#+20
    211            uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
                                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000008   0x6BE0             LDR      R0,[R4, #+60]
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0x4616             MOV      R6,R2
   \   0000000E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000012   0x6829             LDR      R1,[R5, #+0]
   \   00000014   0x.... 0x....      BL       __aeabi_fmul
   \   00000018   0x.... 0x....      BL       ceilf
   \   0000001C   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000020   0x4605             MOV      R5,R0
    212                     final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000022   0x6BE0             LDR      R0,[R4, #+60]
   \   00000024   0x.... 0x....      BL       __aeabi_ui2f
   \   00000028   0x6831             LDR      R1,[R6, #+0]
   \   0000002A   0x.... 0x....      BL       __aeabi_fmul
   \   0000002E   0x.... 0x....      BL       ceilf
   \   00000032   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000036   0x4681             MOV      R9,R0
    213          
    214            // Limit minimal step rate (Otherwise the timer will overflow.)
    215            NOLESS(initial_rate, MINIMAL_STEP_RATE);
   \   00000038   0x2D78             CMP      R5,#+120
   \   0000003A   0xBF38             IT       CC 
   \   0000003C   0x2578             MOVCC    R5,#+120
    216            NOLESS(final_rate, MINIMAL_STEP_RATE);
   \   0000003E   0xF1B9 0x0F78      CMP      R9,#+120
   \   00000042   0xBF38             IT       CC 
   \   00000044   0xF04F 0x0978      MOVCC    R9,#+120
    217          
    218            const int32_t accel = block->acceleration_steps_per_s2;
   \   00000048   0x6CA0             LDR      R0,[R4, #+72]
   \   0000004A   0x9004             STR      R0,[SP, #+16]
    219          
    220                    // Steps required for acceleration, deceleration to/from nominal rate
    221            int32_t accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000052   0x9003             STR      R0,[SP, #+12]
   \   00000054   0x9000             STR      R0,[SP, #+0]
   \   00000056   0x9804             LDR      R0,[SP, #+16]
   \   00000058   0x.... 0x....      BL       __aeabi_i2f
   \   0000005C   0x9002             STR      R0,[SP, #+8]
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000064   0x4682             MOV      R10,R0
   \   00000066   0xBF08             IT       EQ 
   \   00000068   0x2000             MOVEQ    R0,#+0
   \   0000006A   0xD035             BEQ.N    ??calculate_trapezoid_for_block_0
   \   0000006C   0x6BE0             LDR      R0,[R4, #+60]
   \   0000006E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000072   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \   00000076   0x4607             MOV      R7,R0
   \   00000078   0x2602             MOVS     R6,#+2
   \   0000007A   0x46D8             MOV      R8,R11
   \   0000007C   0xE004             B.N      ??calculate_trapezoid_for_block_1
   \                     ??calculate_trapezoid_for_block_2: (+1)
   \   0000007E   0x4638             MOV      R0,R7
   \   00000080   0x4639             MOV      R1,R7
   \   00000082   0x.... 0x....      BL       __aeabi_fmul
   \   00000086   0x4607             MOV      R7,R0
   \                     ??calculate_trapezoid_for_block_1: (+1)
   \   00000088   0x07F0             LSLS     R0,R6,#+31
   \   0000008A   0xD504             BPL.N    ??calculate_trapezoid_for_block_3
   \   0000008C   0x4640             MOV      R0,R8
   \   0000008E   0x4639             MOV      R1,R7
   \   00000090   0x.... 0x....      BL       __aeabi_fmul
   \   00000094   0x4680             MOV      R8,R0
   \                     ??calculate_trapezoid_for_block_3: (+1)
   \   00000096   0x0876             LSRS     R6,R6,#+1
   \   00000098   0xD1F1             BNE.N    ??calculate_trapezoid_for_block_2
   \   0000009A   0x9E00             LDR      R6,[SP, #+0]
   \   0000009C   0x2702             MOVS     R7,#+2
   \   0000009E   0xE004             B.N      ??calculate_trapezoid_for_block_4
   \                     ??calculate_trapezoid_for_block_5: (+1)
   \   000000A0   0x4630             MOV      R0,R6
   \   000000A2   0x4631             MOV      R1,R6
   \   000000A4   0x.... 0x....      BL       __aeabi_fmul
   \   000000A8   0x4606             MOV      R6,R0
   \                     ??calculate_trapezoid_for_block_4: (+1)
   \   000000AA   0x07F8             LSLS     R0,R7,#+31
   \   000000AC   0xD504             BPL.N    ??calculate_trapezoid_for_block_6
   \   000000AE   0x4658             MOV      R0,R11
   \   000000B0   0x4631             MOV      R1,R6
   \   000000B2   0x.... 0x....      BL       __aeabi_fmul
   \   000000B6   0x4683             MOV      R11,R0
   \                     ??calculate_trapezoid_for_block_6: (+1)
   \   000000B8   0x087F             LSRS     R7,R7,#+1
   \   000000BA   0xD1F1             BNE.N    ??calculate_trapezoid_for_block_5
   \   000000BC   0x4640             MOV      R0,R8
   \   000000BE   0x4659             MOV      R1,R11
   \   000000C0   0x.... 0x....      BL       __aeabi_fsub
   \   000000C4   0x4606             MOV      R6,R0
   \   000000C6   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000CA   0x4651             MOV      R1,R10
   \   000000CC   0x.... 0x....      BL       __aeabi_fmul
   \   000000D0   0x4601             MOV      R1,R0
   \   000000D2   0x4630             MOV      R0,R6
   \   000000D4   0x.... 0x....      BL       __aeabi_fdiv
   \                     ??calculate_trapezoid_for_block_0: (+1)
   \   000000D8   0x.... 0x....      BL       ceilf
   \   000000DC   0x.... 0x....      BL       __aeabi_f2iz
   \   000000E0   0x4682             MOV      R10,R0
    222                    decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel)),
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000000E2   0x6BE0             LDR      R0,[R4, #+60]
   \   000000E4   0x.... 0x....      BL       __aeabi_ui2f
   \   000000E8   0x9000             STR      R0,[SP, #+0]
   \   000000EA   0x9804             LDR      R0,[SP, #+16]
   \   000000EC   0x4240             RSBS     R0,R0,#+0
   \   000000EE   0x.... 0x....      BL       __aeabi_i2f
   \   000000F2   0x2100             MOVS     R1,#+0
   \   000000F4   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000000F8   0x9001             STR      R0,[SP, #+4]
   \   000000FA   0xBF08             IT       EQ 
   \   000000FC   0x2000             MOVEQ    R0,#+0
   \   000000FE   0xD035             BEQ.N    ??calculate_trapezoid_for_block_7
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0x.... 0x....      BL       __aeabi_ui2f
   \   00000106   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \   0000010A   0x4607             MOV      R7,R0
   \   0000010C   0x2602             MOVS     R6,#+2
   \   0000010E   0x46D8             MOV      R8,R11
   \   00000110   0xE004             B.N      ??calculate_trapezoid_for_block_8
   \                     ??calculate_trapezoid_for_block_9: (+1)
   \   00000112   0x4638             MOV      R0,R7
   \   00000114   0x4639             MOV      R1,R7
   \   00000116   0x.... 0x....      BL       __aeabi_fmul
   \   0000011A   0x4607             MOV      R7,R0
   \                     ??calculate_trapezoid_for_block_8: (+1)
   \   0000011C   0x07F0             LSLS     R0,R6,#+31
   \   0000011E   0xD504             BPL.N    ??calculate_trapezoid_for_block_10
   \   00000120   0x4640             MOV      R0,R8
   \   00000122   0x4639             MOV      R1,R7
   \   00000124   0x.... 0x....      BL       __aeabi_fmul
   \   00000128   0x4680             MOV      R8,R0
   \                     ??calculate_trapezoid_for_block_10: (+1)
   \   0000012A   0x0876             LSRS     R6,R6,#+1
   \   0000012C   0xD1F1             BNE.N    ??calculate_trapezoid_for_block_9
   \   0000012E   0x9E00             LDR      R6,[SP, #+0]
   \   00000130   0x2702             MOVS     R7,#+2
   \   00000132   0xE004             B.N      ??calculate_trapezoid_for_block_11
   \                     ??calculate_trapezoid_for_block_12: (+1)
   \   00000134   0x4630             MOV      R0,R6
   \   00000136   0x4631             MOV      R1,R6
   \   00000138   0x.... 0x....      BL       __aeabi_fmul
   \   0000013C   0x4606             MOV      R6,R0
   \                     ??calculate_trapezoid_for_block_11: (+1)
   \   0000013E   0x07F8             LSLS     R0,R7,#+31
   \   00000140   0xD504             BPL.N    ??calculate_trapezoid_for_block_13
   \   00000142   0x4658             MOV      R0,R11
   \   00000144   0x4631             MOV      R1,R6
   \   00000146   0x.... 0x....      BL       __aeabi_fmul
   \   0000014A   0x4683             MOV      R11,R0
   \                     ??calculate_trapezoid_for_block_13: (+1)
   \   0000014C   0x087F             LSRS     R7,R7,#+1
   \   0000014E   0xD1F1             BNE.N    ??calculate_trapezoid_for_block_12
   \   00000150   0x4640             MOV      R0,R8
   \   00000152   0x4659             MOV      R1,R11
   \   00000154   0x.... 0x....      BL       __aeabi_fsub
   \   00000158   0x4606             MOV      R6,R0
   \   0000015A   0x9901             LDR      R1,[SP, #+4]
   \   0000015C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000160   0x.... 0x....      BL       __aeabi_fmul
   \   00000164   0x4601             MOV      R1,R0
   \   00000166   0x4630             MOV      R0,R6
   \   00000168   0x.... 0x....      BL       __aeabi_fdiv
   \                     ??calculate_trapezoid_for_block_7: (+1)
   \   0000016C   0x.... 0x....      BL       floorf
    223                    // Steps between acceleration and deceleration, if any
    224                    plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
   \   00000170   0x6967             LDR      R7,[R4, #+20]
   \   00000172   0xEBA7 0x060A      SUB      R6,R7,R10
   \   00000176   0x.... 0x....      BL       __aeabi_f2iz
   \   0000017A   0x1A30             SUBS     R0,R6,R0
    225          
    226            // Does accelerate_steps + decelerate_steps exceed step_event_count?
    227            // Then we can't possibly reach the nominal rate, there will be no cruising.
    228            // Use intersection_distance() to calculate accel / braking time in order to
    229            // reach the final_rate exactly at the end of this block.
    230            if (plateau_steps < 0) {
   \   0000017C   0xD55A             BPL.N    ??calculate_trapezoid_for_block_14
    231              accelerate_steps = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
                                      ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000017E   0x4648             MOV      R0,R9
   \   00000180   0x.... 0x....      BL       __aeabi_ui2f
   \   00000184   0x4682             MOV      R10,R0
   \   00000186   0x9802             LDR      R0,[SP, #+8]
   \   00000188   0x9000             STR      R0,[SP, #+0]
   \   0000018A   0x4638             MOV      R0,R7
   \   0000018C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000190   0x9001             STR      R0,[SP, #+4]
   \   00000192   0x2100             MOVS     R1,#+0
   \   00000194   0x9800             LDR      R0,[SP, #+0]
   \   00000196   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000019A   0xBF08             IT       EQ 
   \   0000019C   0x2000             MOVEQ    R0,#+0
   \   0000019E   0xD03B             BEQ.N    ??calculate_trapezoid_for_block_15
   \   000001A0   0x9F03             LDR      R7,[SP, #+12]
   \   000001A2   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \   000001A6   0x2602             MOVS     R6,#+2
   \   000001A8   0x46D8             MOV      R8,R11
   \   000001AA   0xE004             B.N      ??calculate_trapezoid_for_block_16
   \                     ??calculate_trapezoid_for_block_17: (+1)
   \   000001AC   0x4638             MOV      R0,R7
   \   000001AE   0x4639             MOV      R1,R7
   \   000001B0   0x.... 0x....      BL       __aeabi_fmul
   \   000001B4   0x4607             MOV      R7,R0
   \                     ??calculate_trapezoid_for_block_16: (+1)
   \   000001B6   0x07F0             LSLS     R0,R6,#+31
   \   000001B8   0xD504             BPL.N    ??calculate_trapezoid_for_block_18
   \   000001BA   0x4640             MOV      R0,R8
   \   000001BC   0x4639             MOV      R1,R7
   \   000001BE   0x.... 0x....      BL       __aeabi_fmul
   \   000001C2   0x4680             MOV      R8,R0
   \                     ??calculate_trapezoid_for_block_18: (+1)
   \   000001C4   0x0876             LSRS     R6,R6,#+1
   \   000001C6   0xD1F1             BNE.N    ??calculate_trapezoid_for_block_17
   \   000001C8   0x2602             MOVS     R6,#+2
   \   000001CA   0xE004             B.N      ??calculate_trapezoid_for_block_19
   \                     ??calculate_trapezoid_for_block_20: (+1)
   \   000001CC   0x4650             MOV      R0,R10
   \   000001CE   0x4651             MOV      R1,R10
   \   000001D0   0x.... 0x....      BL       __aeabi_fmul
   \   000001D4   0x4682             MOV      R10,R0
   \                     ??calculate_trapezoid_for_block_19: (+1)
   \   000001D6   0x07F0             LSLS     R0,R6,#+31
   \   000001D8   0xD504             BPL.N    ??calculate_trapezoid_for_block_21
   \   000001DA   0x4658             MOV      R0,R11
   \   000001DC   0x4651             MOV      R1,R10
   \   000001DE   0x.... 0x....      BL       __aeabi_fmul
   \   000001E2   0x4683             MOV      R11,R0
   \                     ??calculate_trapezoid_for_block_21: (+1)
   \   000001E4   0x0876             LSRS     R6,R6,#+1
   \   000001E6   0xD1F1             BNE.N    ??calculate_trapezoid_for_block_20
   \   000001E8   0x9900             LDR      R1,[SP, #+0]
   \   000001EA   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000001EE   0x.... 0x....      BL       __aeabi_fmul
   \   000001F2   0x9901             LDR      R1,[SP, #+4]
   \   000001F4   0x.... 0x....      BL       __aeabi_fmul
   \   000001F8   0x4641             MOV      R1,R8
   \   000001FA   0x.... 0x....      BL       __aeabi_fsub
   \   000001FE   0x4659             MOV      R1,R11
   \   00000200   0x.... 0x....      BL       __aeabi_fadd
   \   00000204   0x4606             MOV      R6,R0
   \   00000206   0x9900             LDR      R1,[SP, #+0]
   \   00000208   0xF04F 0x4081      MOV      R0,#+1082130432
   \   0000020C   0x.... 0x....      BL       __aeabi_fmul
   \   00000210   0x4601             MOV      R1,R0
   \   00000212   0x4630             MOV      R0,R6
   \   00000214   0x.... 0x....      BL       __aeabi_fdiv
   \                     ??calculate_trapezoid_for_block_15: (+1)
   \   00000218   0x.... 0x....      BL       ceilf
   \   0000021C   0x.... 0x....      BL       __aeabi_f2iz
   \   00000220   0xEA5F 0x0A00      MOVS     R10,R0
    232              NOLESS(accelerate_steps, 0); // Check limits due to numerical round-off
   \   00000224   0xBF48             IT       MI 
   \   00000226   0xF04F 0x0A00      MOVMI    R10,#+0
    233              accelerate_steps = min((uint32_t)accelerate_steps, block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
   \   0000022A   0x6960             LDR      R0,[R4, #+20]
   \   0000022C   0x4582             CMP      R10,R0
   \   0000022E   0xBF28             IT       CS 
   \   00000230   0x4682             MOVCS    R10,R0
    234              plateau_steps = 0;
   \   00000232   0x2000             MOVS     R0,#+0
    235            }
    236          
    237            // block->accelerate_until = accelerate_steps;
    238            // block->decelerate_after = accelerate_steps+plateau_steps;
    239          
    240            CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
   \                     ??calculate_trapezoid_for_block_14: (+1)
   \   00000234   0xB672             cpsid i
    241            if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
   \   00000236   0x7821             LDRB     R1,[R4, #+0]
   \   00000238   0x0709             LSLS     R1,R1,#+28
   \   0000023A   0xD406             BMI.N    ??calculate_trapezoid_for_block_22
    242              block->accelerate_until = accelerate_steps;
   \   0000023C   0xF8C4 0xA018      STR      R10,[R4, #+24]
    243              block->decelerate_after = accelerate_steps + plateau_steps;
   \   00000240   0x4450             ADD      R0,R0,R10
   \   00000242   0x61E0             STR      R0,[R4, #+28]
    244              block->initial_rate = initial_rate;
   \   00000244   0x6425             STR      R5,[R4, #+64]
    245              block->final_rate = final_rate;
   \   00000246   0xF8C4 0x9044      STR      R9,[R4, #+68]
    246            }
    247            CRITICAL_SECTION_END;
   \                     ??calculate_trapezoid_for_block_22: (+1)
   \   0000024A   0xB662             cpsie i
    248          }
   \   0000024C   0x....             B.N      ?Subroutine1

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xB005             ADD      SP,SP,#+20
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    249          
    250          // "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
    251          // This method will calculate the junction jerk as the euclidean distance between the nominal
    252          // velocities of the respective blocks.
    253          //inline float junction_jerk(block_t *before, block_t *after) {
    254          //  return SQRT(
    255          //    POW((before->speed_x-after->speed_x), 2)+POW((before->speed_y-after->speed_y), 2));
    256          //}
    257          
    258          
    259          // The kernel called by recalculate() when scanning the plan from last to first entry.

   \                                 In section .text, align 2, keep-with-next
    260          void Planner::reverse_pass_kernel(block_t* const current, const block_t * const next) {
   \                     _ZN7Planner19reverse_pass_kernelEP7block_tPKS0_: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x460E             MOV      R6,R1
    261            if (!current || !next) return;
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2E00             CMPNE    R6,#+0
   \   0000000C   0xD068             BEQ.N    ??reverse_pass_kernel_0
    262            // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
    263            // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
    264            // check for maximum allowable speed reductions to ensure maximum possible planned speed.
    265            float max_entry_speed = current->max_entry_speed;
   \   0000000E   0x6B2F             LDR      R7,[R5, #+48]
    266            if (current->entry_speed != max_entry_speed) {
   \   00000010   0x6AE8             LDR      R0,[R5, #+44]
   \   00000012   0x4639             MOV      R1,R7
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000018   0xD062             BEQ.N    ??reverse_pass_kernel_0
    267              // If nominal length true, max junction speed is guaranteed to be reached. Only compute
    268              // for max allowable speed if block is decelerating and nominal length is false.
    269              current->entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
    270                ? max_entry_speed
    271                : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
   \   0000001A   0x7828             LDRB     R0,[R5, #+0]
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD45A             BMI.N    ??reverse_pass_kernel_1
   \   00000020   0x6AF4             LDR      R4,[R6, #+44]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000028   0xD955             BLS.N    ??reverse_pass_kernel_1
   \   0000002A   0x6BA8             LDR      R0,[R5, #+56]
   \   0000002C   0xF080 0x4800      EOR      R8,R0,#0x80000000
   \   00000030   0xF105 0x0034      ADD      R0,R5,#+52
   \   00000034   0xF04F 0x597E      MOV      R9,#+1065353216
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0xF04F 0x0A02      MOV      R10,#+2
   \   0000003E   0x46CB             MOV      R11,R9
   \   00000040   0xE004             B.N      ??reverse_pass_kernel_2
   \                     ??reverse_pass_kernel_3: (+1)
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x4621             MOV      R1,R4
   \   00000046   0x.... 0x....      BL       __aeabi_fmul
   \   0000004A   0x4604             MOV      R4,R0
   \                     ??reverse_pass_kernel_2: (+1)
   \   0000004C   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000050   0xD504             BPL.N    ??reverse_pass_kernel_4
   \   00000052   0x4658             MOV      R0,R11
   \   00000054   0x4621             MOV      R1,R4
   \   00000056   0x.... 0x....      BL       __aeabi_fmul
   \   0000005A   0x4683             MOV      R11,R0
   \                     ??reverse_pass_kernel_4: (+1)
   \   0000005C   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000060   0xD1EF             BNE.N    ??reverse_pass_kernel_3
   \   00000062   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000066   0x4641             MOV      R1,R8
   \   00000068   0x.... 0x....      BL       __aeabi_fmul
   \   0000006C   0x9900             LDR      R1,[SP, #+0]
   \   0000006E   0x6809             LDR      R1,[R1, #+0]
   \   00000070   0x.... 0x....      BL       __aeabi_fmul
   \   00000074   0x4601             MOV      R1,R0
   \   00000076   0x4658             MOV      R0,R11
   \   00000078   0x.... 0x....      BL       __aeabi_fsub
   \   0000007C   0x.... 0x....      BL       sqrtf
   \   00000080   0x4601             MOV      R1,R0
   \   00000082   0x4638             MOV      R0,R7
   \   00000084   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000088   0xD325             BCC.N    ??reverse_pass_kernel_1
   \   0000008A   0x6BAF             LDR      R7,[R5, #+56]
   \   0000008C   0x6AF6             LDR      R6,[R6, #+44]
   \   0000008E   0xF087 0x4700      EOR      R7,R7,#0x80000000
   \   00000092   0xF105 0x0834      ADD      R8,R5,#+52
   \   00000096   0x2402             MOVS     R4,#+2
   \   00000098   0xE004             B.N      ??reverse_pass_kernel_5
   \                     ??reverse_pass_kernel_6: (+1)
   \   0000009A   0x4630             MOV      R0,R6
   \   0000009C   0x4631             MOV      R1,R6
   \   0000009E   0x.... 0x....      BL       __aeabi_fmul
   \   000000A2   0x4606             MOV      R6,R0
   \                     ??reverse_pass_kernel_5: (+1)
   \   000000A4   0x07E0             LSLS     R0,R4,#+31
   \   000000A6   0xD504             BPL.N    ??reverse_pass_kernel_7
   \   000000A8   0x4648             MOV      R0,R9
   \   000000AA   0x4631             MOV      R1,R6
   \   000000AC   0x.... 0x....      BL       __aeabi_fmul
   \   000000B0   0x4681             MOV      R9,R0
   \                     ??reverse_pass_kernel_7: (+1)
   \   000000B2   0x0864             LSRS     R4,R4,#+1
   \   000000B4   0xD1F1             BNE.N    ??reverse_pass_kernel_6
   \   000000B6   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000BA   0x4639             MOV      R1,R7
   \   000000BC   0x.... 0x....      BL       __aeabi_fmul
   \   000000C0   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   000000C4   0x.... 0x....      BL       __aeabi_fmul
   \   000000C8   0x4601             MOV      R1,R0
   \   000000CA   0x4648             MOV      R0,R9
   \   000000CC   0x.... 0x....      BL       __aeabi_fsub
   \   000000D0   0x.... 0x....      BL       sqrtf
   \   000000D4   0x4607             MOV      R7,R0
   \                     ??reverse_pass_kernel_1: (+1)
   \   000000D6   0x62EF             STR      R7,[R5, #+44]
    272              SBI(current->flag, BLOCK_BIT_RECALCULATE);
   \   000000D8   0x7828             LDRB     R0,[R5, #+0]
   \   000000DA   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000DE   0x7028             STRB     R0,[R5, #+0]
    273            }
    274          }
   \                     ??reverse_pass_kernel_0: (+1)
   \   000000E0   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    275          
    276          /**
    277           * recalculate() needs to go over the current plan twice.
    278           * Once in reverse and once forward. This implements the reverse pass.
    279           */

   \                                 In section .text, align 2, keep-with-next
    280          void Planner::reverse_pass() {
    281            if (movesplanned() > 3) {
   \                     _ZN7Planner12reverse_passEv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0x7842             LDRB     R2,[R0, #+1]
   \   00000008   0x1A89             SUBS     R1,R1,R2
   \   0000000A   0xF001 0x010F      AND      R1,R1,#0xF
   \   0000000E   0x2904             CMP      R1,#+4
   \   00000010   0xDA00             BGE.N    ??reverse_pass_0
   \   00000012   0x4770             BX       LR
    282              const uint8_t endnr = BLOCK_MOD(block_buffer_tail + 2); // tail is running. tail+1 shouldn't be altered because it's connected to the running block.
   \                     ??reverse_pass_0: (+1)
   \   00000014   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000018   0x7841             LDRB     R1,[R0, #+1]
    283                                                                      // tail+2 because the index is not yet advanced when checked
    284              uint8_t blocknr = prev_block_index(block_buffer_head);
   \   0000001A   0xF990 0x0000      LDRSB    R0,[R0, #+0]
    285              block_t* current = &block_buffer[blocknr];
   \   0000001E   0x.... 0x....      LDR.W    R8,??DataTable10_7
   \   00000022   0x1E40             SUBS     R0,R0,#+1
   \   00000024   0x1C89             ADDS     R1,R1,#+2
   \   00000026   0xF000 0x070F      AND      R7,R0,#0xF
   \   0000002A   0x2554             MOVS     R5,#+84
   \   0000002C   0xF001 0x040F      AND      R4,R1,#0xF
   \   00000030   0xFB05 0x8607      MLA      R6,R5,R7,R8
    286          
    287              do {
    288                const block_t * const next = current;
    289                blocknr = prev_block_index(blocknr);
   \                     ??reverse_pass_1: (+1)
   \   00000034   0x1E78             SUBS     R0,R7,#+1
   \   00000036   0x4631             MOV      R1,R6
   \   00000038   0xF000 0x070F      AND      R7,R0,#0xF
    290                current = &block_buffer[blocknr];
   \   0000003C   0xFB05 0x8607      MLA      R6,R5,R7,R8
    291                if (TEST(current->flag, BLOCK_BIT_START_FROM_FULL_HALT)) // Up to this every block is already optimized.
   \   00000040   0x7830             LDRB     R0,[R6, #+0]
   \   00000042   0x0740             LSLS     R0,R0,#+29
   \   00000044   0xD404             BMI.N    ??reverse_pass_2
    292                  break;
    293                reverse_pass_kernel(current, next);
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0x.... 0x....      BL       _ZN7Planner19reverse_pass_kernelEP7block_tPKS0_
    294              } while (blocknr != endnr);
   \   0000004C   0x42A7             CMP      R7,R4
   \   0000004E   0xD1F1             BNE.N    ??reverse_pass_1
    295            }
    296          }
   \                     ??reverse_pass_2: (+1)
   \   00000050   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    297          
    298          // The kernel called by recalculate() when scanning the plan from first to last entry.

   \                                 In section .text, align 2, keep-with-next
    299          void Planner::forward_pass_kernel(const block_t * const previous, block_t* const current) {
   \                     _ZN7Planner19forward_pass_kernelEPK7block_tPS0_: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x460D             MOV      R5,R1
    300            if (!previous) return;
   \   00000008   0xD065             BEQ.N    ??forward_pass_kernel_0
    301          
    302            // If the previous block is an acceleration block, but it is not long enough to complete the
    303            // full speed change within the block, we need to adjust the entry speed accordingly. Entry
    304            // speeds have already been reset, maximized, and reverse planned by reverse planner.
    305            // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
    306            if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
   \   0000000A   0x7830             LDRB     R0,[R6, #+0]
   \   0000000C   0x0780             LSLS     R0,R0,#+30
   \   0000000E   0xD462             BMI.N    ??forward_pass_kernel_0
    307              if (previous->entry_speed < current->entry_speed) {
   \   00000010   0xF8D6 0xA02C      LDR      R10,[R6, #+44]
   \   00000014   0x6AE9             LDR      R1,[R5, #+44]
   \   00000016   0x4650             MOV      R0,R10
   \   00000018   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000001C   0xD25B             BCS.N    ??forward_pass_kernel_0
    308                float entry_speed = min(current->entry_speed,
    309                                         max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
   \   0000001E   0x6BB0             LDR      R0,[R6, #+56]
   \   00000020   0xF04F 0x597E      MOV      R9,#+1065353216
   \   00000024   0xF080 0x4800      EOR      R8,R0,#0x80000000
   \   00000028   0xF106 0x0434      ADD      R4,R6,#+52
   \   0000002C   0x2702             MOVS     R7,#+2
   \   0000002E   0x46CB             MOV      R11,R9
   \   00000030   0xE004             B.N      ??forward_pass_kernel_1
   \                     ??forward_pass_kernel_2: (+1)
   \   00000032   0x4650             MOV      R0,R10
   \   00000034   0x4651             MOV      R1,R10
   \   00000036   0x.... 0x....      BL       __aeabi_fmul
   \   0000003A   0x4682             MOV      R10,R0
   \                     ??forward_pass_kernel_1: (+1)
   \   0000003C   0x07F8             LSLS     R0,R7,#+31
   \   0000003E   0xD504             BPL.N    ??forward_pass_kernel_3
   \   00000040   0x4658             MOV      R0,R11
   \   00000042   0x4651             MOV      R1,R10
   \   00000044   0x.... 0x....      BL       __aeabi_fmul
   \   00000048   0x4683             MOV      R11,R0
   \                     ??forward_pass_kernel_3: (+1)
   \   0000004A   0x087F             LSRS     R7,R7,#+1
   \   0000004C   0xD1F1             BNE.N    ??forward_pass_kernel_2
   \   0000004E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000052   0x4641             MOV      R1,R8
   \   00000054   0x.... 0x....      BL       __aeabi_fmul
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x.... 0x....      BL       __aeabi_fmul
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x4658             MOV      R0,R11
   \   00000062   0x.... 0x....      BL       __aeabi_fsub
   \   00000066   0x.... 0x....      BL       sqrtf
   \   0000006A   0x6AEA             LDR      R2,[R5, #+44]
   \   0000006C   0x4601             MOV      R1,R0
   \   0000006E   0x4610             MOV      R0,R2
   \   00000070   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000074   0xD325             BCC.N    ??forward_pass_kernel_4
   \   00000076   0x6BB0             LDR      R0,[R6, #+56]
   \   00000078   0xF106 0x0834      ADD      R8,R6,#+52
   \   0000007C   0x6AF6             LDR      R6,[R6, #+44]
   \   0000007E   0xF080 0x4700      EOR      R7,R0,#0x80000000
   \   00000082   0x2402             MOVS     R4,#+2
   \   00000084   0xE004             B.N      ??forward_pass_kernel_5
   \                     ??forward_pass_kernel_6: (+1)
   \   00000086   0x4630             MOV      R0,R6
   \   00000088   0x4631             MOV      R1,R6
   \   0000008A   0x.... 0x....      BL       __aeabi_fmul
   \   0000008E   0x4606             MOV      R6,R0
   \                     ??forward_pass_kernel_5: (+1)
   \   00000090   0x07E0             LSLS     R0,R4,#+31
   \   00000092   0xD504             BPL.N    ??forward_pass_kernel_7
   \   00000094   0x4648             MOV      R0,R9
   \   00000096   0x4631             MOV      R1,R6
   \   00000098   0x.... 0x....      BL       __aeabi_fmul
   \   0000009C   0x4681             MOV      R9,R0
   \                     ??forward_pass_kernel_7: (+1)
   \   0000009E   0x0864             LSRS     R4,R4,#+1
   \   000000A0   0xD1F1             BNE.N    ??forward_pass_kernel_6
   \   000000A2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000A6   0x4639             MOV      R1,R7
   \   000000A8   0x.... 0x....      BL       __aeabi_fmul
   \   000000AC   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   000000B0   0x.... 0x....      BL       __aeabi_fmul
   \   000000B4   0x4601             MOV      R1,R0
   \   000000B6   0x4648             MOV      R0,R9
   \   000000B8   0x.... 0x....      BL       __aeabi_fsub
   \   000000BC   0x.... 0x....      BL       sqrtf
   \   000000C0   0x4602             MOV      R2,R0
    310                // Check for junction speed change
    311                if (current->entry_speed != entry_speed) {
   \                     ??forward_pass_kernel_4: (+1)
   \   000000C2   0x6AE8             LDR      R0,[R5, #+44]
   \   000000C4   0x4611             MOV      R1,R2
   \   000000C6   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000000CA   0xD004             BEQ.N    ??forward_pass_kernel_0
    312                  current->entry_speed = entry_speed;
   \   000000CC   0x62EA             STR      R2,[R5, #+44]
    313                  SBI(current->flag, BLOCK_BIT_RECALCULATE);
   \   000000CE   0x7828             LDRB     R0,[R5, #+0]
   \   000000D0   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000D4   0x7028             STRB     R0,[R5, #+0]
    314                }
    315              }
    316            }
    317          }
   \                     ??forward_pass_kernel_0: (+1)
   \   000000D6   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    318          
    319          /**
    320           * recalculate() needs to go over the current plan twice.
    321           * Once in reverse and once forward. This implements the forward pass.
    322           */

   \                                 In section .text, align 2, keep-with-next
    323          void Planner::forward_pass() {
   \                     _ZN7Planner12forward_passEv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    324            block_t* block[3] = { NULL, NULL, NULL };
    325          
    326            for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable10_5
   \   00000008   0x.... 0x....      LDR.W    R9,??DataTable10_7
   \   0000000C   0x7877             LDRB     R7,[R6, #+1]
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0x46A0             MOV      R8,R4
   \   00000012   0x2554             MOVS     R5,#+84
   \   00000014   0xE009             B.N      ??forward_pass_0
    327              block[0] = block[1];
   \                     ??forward_pass_1: (+1)
   \   00000016   0x4620             MOV      R0,R4
    328              block[1] = block[2];
   \   00000018   0x4644             MOV      R4,R8
    329              block[2] = &block_buffer[b];
   \   0000001A   0xFB05 0x9807      MLA      R8,R5,R7,R9
    330              forward_pass_kernel(block[0], block[1]);
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x.... 0x....      BL       _ZN7Planner19forward_pass_kernelEPK7block_tPS0_
    331            }
   \   00000024   0x1C78             ADDS     R0,R7,#+1
   \   00000026   0xF000 0x070F      AND      R7,R0,#0xF
   \                     ??forward_pass_0: (+1)
   \   0000002A   0x7830             LDRB     R0,[R6, #+0]
   \   0000002C   0x4287             CMP      R7,R0
   \   0000002E   0xD1F2             BNE.N    ??forward_pass_1
    332            forward_pass_kernel(block[1], block[2]);
   \   00000030   0x4641             MOV      R1,R8
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   00000038   0x....             B.N      _ZN7Planner19forward_pass_kernelEPK7block_tPS0_
    333          }
    334          
    335          /**
    336           * Recalculate the trapezoid speed profiles for all blocks in the plan
    337           * according to the entry_factor for each junction. Must be called by
    338           * recalculate() after updating the blocks.
    339           */

   \                                 In section .text, align 2, keep-with-next
    340          void Planner::recalculate_trapezoids() {
   \                     _ZN7Planner22recalculate_trapezoidsEv: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
    341            int8_t block_index = block_buffer_tail;
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable10_5
    342            block_t *current, *next = NULL;
   \   00000008   0x.... 0x....      LDR.W    R8,??DataTable10_7
   \   0000000C   0xF995 0x6001      LDRSB    R6,[R5, #+1]
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xF04F 0x0954      MOV      R9,#+84
   \   00000016   0xE025             B.N      ??recalculate_trapezoids_0
    343          
    344            while (block_index != block_buffer_head) {
    345              current = next;
   \                     ??recalculate_trapezoids_1: (+1)
   \   00000018   0x0027             MOVS     R7,R4
    346              next = &block_buffer[block_index];
   \   0000001A   0xFB09 0x8406      MLA      R4,R9,R6,R8
    347              if (current) {
   \   0000001E   0xD01E             BEQ.N    ??recalculate_trapezoids_2
    348                // Recalculate if current block entry or exit junction speed has changed.
    349                if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
   \   00000020   0x7838             LDRB     R0,[R7, #+0]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD402             BMI.N    ??recalculate_trapezoids_3
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD518             BPL.N    ??recalculate_trapezoids_2
    350                  // NOTE: Entry and exit factors always > 0 by all previous logic operations.
    351                  const float nomr = 1.0 / current->nominal_speed;
   \                     ??recalculate_trapezoids_3: (+1)
   \   0000002C   0x6AB9             LDR      R1,[R7, #+40]
   \   0000002E   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000032   0x.... 0x....      BL       __aeabi_fdiv
   \   00000036   0x4682             MOV      R10,R0
    352                  calculate_trapezoid_for_block(current, current->entry_speed * nomr, next->entry_speed * nomr);
   \   00000038   0x6AF8             LDR      R0,[R7, #+44]
   \   0000003A   0x4651             MOV      R1,R10
   \   0000003C   0x.... 0x....      BL       __aeabi_fmul
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x4651             MOV      R1,R10
   \   00000044   0x6AE0             LDR      R0,[R4, #+44]
   \   00000046   0x.... 0x....      BL       __aeabi_fmul
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0xA901             ADD      R1,SP,#+4
   \   00000050   0x4638             MOV      R0,R7
   \   00000052   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
    353                  CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
   \   00000056   0x7838             LDRB     R0,[R7, #+0]
   \   00000058   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   0000005C   0x7038             STRB     R0,[R7, #+0]
    354                }
    355              }
    356              block_index = next_block_index(block_index);
    357            }
   \                     ??recalculate_trapezoids_2: (+1)
   \   0000005E   0x1C70             ADDS     R0,R6,#+1
   \   00000060   0xF000 0x060F      AND      R6,R0,#0xF
   \                     ??recalculate_trapezoids_0: (+1)
   \   00000064   0x7829             LDRB     R1,[R5, #+0]
   \   00000066   0x428E             CMP      R6,R1
   \   00000068   0xD1D6             BNE.N    ??recalculate_trapezoids_1
    358            // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
    359            if (next) {
   \   0000006A   0xB1FC             CBZ.N    R4,??recalculate_trapezoids_4
    360              const float nomr = 1.0 / next->nominal_speed;
   \   0000006C   0x6AA1             LDR      R1,[R4, #+40]
   \   0000006E   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000072   0x.... 0x....      BL       __aeabi_fdiv
   \   00000076   0x4605             MOV      R5,R0
    361              calculate_trapezoid_for_block(next, next->entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
   \   00000078   0x6AE0             LDR      R0,[R4, #+44]
   \   0000007A   0x4629             MOV      R1,R5
   \   0000007C   0x.... 0x....      BL       __aeabi_fmul
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       __aeabi_f2d
   \   00000088   0x.... 0x....      LDR.W    R2,??DataTable10_8  ;; 0x9999999a
   \   0000008C   0x.... 0x....      LDR.W    R3,??DataTable10_9  ;; 0x3fa99999
   \   00000090   0x.... 0x....      BL       __aeabi_dmul
   \   00000094   0x.... 0x....      BL       __aeabi_d2f
   \   00000098   0x9001             STR      R0,[SP, #+4]
   \   0000009A   0xAA01             ADD      R2,SP,#+4
   \   0000009C   0xA900             ADD      R1,SP,#+0
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
    362              CBI(next->flag, BLOCK_BIT_RECALCULATE);
   \   000000A4   0x7820             LDRB     R0,[R4, #+0]
   \   000000A6   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   000000AA   0x7020             STRB     R0,[R4, #+0]
    363            }
    364          }
   \                     ??recalculate_trapezoids_4: (+1)
   \   000000AC   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    365          
    366          /*
    367           * Recalculate the motion plan according to the following algorithm:
    368           *
    369           *   1. Go over every block in reverse order...
    370           *
    371           *      Calculate a junction speed reduction (block_t.entry_factor) so:
    372           *
    373           *      a. The junction jerk is within the set limit, and
    374           *
    375           *      b. No speed reduction within one block requires faster
    376           *         deceleration than the one, true constant acceleration.
    377           *
    378           *   2. Go over every block in chronological order...
    379           *
    380           *      Dial down junction speed reduction values if:
    381           *      a. The speed increase within one block would require faster
    382           *         acceleration than the one, true constant acceleration.
    383           *
    384           * After that, all blocks will have an entry_factor allowing all speed changes to
    385           * be performed using only the one, true constant acceleration, and where no junction
    386           * jerk is jerkier than the set limit, Jerky. Finally it will:
    387           *
    388           *   3. Recalculate "trapezoids" for all blocks.
    389           */

   \                                 In section .text, align 2, keep-with-next
    390          void Planner::recalculate() {
   \                     _ZN7Planner11recalculateEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    391            reverse_pass();
   \   00000002   0x.... 0x....      BL       _ZN7Planner12reverse_passEv
    392            forward_pass();
   \   00000006   0x.... 0x....      BL       _ZN7Planner12forward_passEv
    393            recalculate_trapezoids();
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x....             B.N      _ZN7Planner22recalculate_trapezoidsEv
    394          }
    395          
    396          
    397          #if ENABLED(AUTOTEMP)
    398          

   \                                 In section .text, align 2, keep-with-next
    399            void Planner::getHighESpeed() {
   \                     _ZN7Planner13getHighESpeedEv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    400              static float oldt = 0;
    401          
    402              if (!autotemp_enabled) return;
   \   00000004   0x....             LDR.N    R6,??DataTable10_5
   \   00000006   0x78F0             LDRB     R0,[R6, #+3]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD074             BEQ.N    ??getHighESpeed_0
    403              if (thermalManager.degTargetHotend(0) + 2 < autotemp_min) return; // probably temperature set to zero.
   \   0000000C   0x.... 0x....      LDR.W    R7,??DataTable10_10
   \   00000010   0xF8D6 0x805C      LDR      R8,[R6, #+92]
   \   00000014   0x6838             LDR      R0,[R7, #+0]
   \   00000016   0x.... 0x....      BL       __aeabi_i2f
   \   0000001A   0xF04F 0x4180      MOV      R1,#+1073741824
   \   0000001E   0x.... 0x....      BL       __aeabi_fadd
   \   00000022   0x4641             MOV      R1,R8
   \   00000024   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000028   0xD365             BCC.N    ??getHighESpeed_0
    404          
    405              float high = 0.0;
    406              for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \   0000002A   0x7874             LDRB     R4,[R6, #+1]
   \   0000002C   0x.... 0x....      LDR.W    R10,??DataTable10_7
   \   00000030   0xF04F 0x0B00      MOV      R11,#+0
   \   00000034   0xF04F 0x0954      MOV      R9,#+84
   \   00000038   0xE020             B.N      ??getHighESpeed_1
    407                block_t* block = &block_buffer[b];
   \                     ??getHighESpeed_2: (+1)
   \   0000003A   0xFB09 0xA504      MLA      R5,R9,R4,R10
    408                if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS]) {
   \   0000003E   0x6868             LDR      R0,[R5, #+4]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xBF04             ITT      EQ 
   \   00000044   0x68A8             LDREQ    R0,[R5, #+8]
   \   00000046   0x2800             CMPEQ    R0,#+0
   \   00000048   0xD101             BNE.N    ??getHighESpeed_3
   \   0000004A   0x68E8             LDR      R0,[R5, #+12]
   \   0000004C   0xB198             CBZ.N    R0,??getHighESpeed_4
    409                  float se = (float)block->steps[E_AXIS] / block->step_event_count * block->nominal_speed; // mm/sec;
   \                     ??getHighESpeed_3: (+1)
   \   0000004E   0x6928             LDR      R0,[R5, #+16]
   \   00000050   0x.... 0x....      BL       __aeabi_i2f
   \   00000054   0x9000             STR      R0,[SP, #+0]
   \   00000056   0x6968             LDR      R0,[R5, #+20]
   \   00000058   0x.... 0x....      BL       __aeabi_ui2f
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   \   00000060   0x.... 0x....      BL       __aeabi_fdiv
   \   00000064   0x6AA9             LDR      R1,[R5, #+40]
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x4601             MOV      R1,R0
    410                  NOLESS(high, se);
   \   0000006C   0x4658             MOV      R0,R11
   \   0000006E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000072   0xBF38             IT       CC 
   \   00000074   0x468B             MOVCC    R11,R1
    411                }
    412              }
   \                     ??getHighESpeed_4: (+1)
   \   00000076   0x1C60             ADDS     R0,R4,#+1
   \   00000078   0xF000 0x040F      AND      R4,R0,#0xF
   \                     ??getHighESpeed_1: (+1)
   \   0000007C   0x7830             LDRB     R0,[R6, #+0]
   \   0000007E   0x4284             CMP      R4,R0
   \   00000080   0xD1DB             BNE.N    ??getHighESpeed_2
    413          
    414              float t = autotemp_min + high * autotemp_factor;
   \   00000082   0x6E30             LDR      R0,[R6, #+96]
   \   00000084   0x4659             MOV      R1,R11
   \   00000086   0x.... 0x....      BL       __aeabi_fmul
   \   0000008A   0x4641             MOV      R1,R8
   \   0000008C   0x.... 0x....      BL       __aeabi_fadd
    415              t = constrain(t, autotemp_min, autotemp_max);
   \   00000090   0x4641             MOV      R1,R8
   \   00000092   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000096   0x4602             MOV      R2,R0
   \   00000098   0xBF38             IT       CC 
   \   0000009A   0x4642             MOVCC    R2,R8
   \   0000009C   0xD305             BCC.N    ??getHighESpeed_5
   \   0000009E   0x6DB0             LDR      R0,[R6, #+88]
   \   000000A0   0x4611             MOV      R1,R2
   \   000000A2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000A6   0xBF38             IT       CC 
   \   000000A8   0x4602             MOVCC    R2,R0
    416              if (t < oldt) t = t * (1 - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
   \                     ??getHighESpeed_5: (+1)
   \   000000AA   0x6FF4             LDR      R4,[R6, #+124]
   \   000000AC   0x4610             MOV      R0,R2
   \   000000AE   0x4621             MOV      R1,R4
   \   000000B0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B4   0xD215             BCS.N    ??getHighESpeed_6
   \   000000B6   0x.... 0x....      BL       __aeabi_f2d
   \   000000BA   0x....             LDR.N    R2,??DataTable10_11  ;; 0x47ae1480
   \   000000BC   0x....             LDR.N    R3,??DataTable10_12  ;; 0x3f947ae1
   \   000000BE   0x.... 0x....      BL       __aeabi_dmul
   \   000000C2   0x4605             MOV      R5,R0
   \   000000C4   0x468B             MOV      R11,R1
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0x.... 0x....      BL       __aeabi_f2d
   \   000000CC   0x....             LDR.N    R2,??DataTable10_13  ;; 0xf5c28f5c
   \   000000CE   0x....             LDR.N    R3,??DataTable10_14  ;; 0x3fef5c28
   \   000000D0   0x.... 0x....      BL       __aeabi_dmul
   \   000000D4   0x462A             MOV      R2,R5
   \   000000D6   0x465B             MOV      R3,R11
   \   000000D8   0x.... 0x....      BL       __aeabi_dadd
   \   000000DC   0x.... 0x....      BL       __aeabi_d2f
   \   000000E0   0x4602             MOV      R2,R0
    417              oldt = t;
   \                     ??getHighESpeed_6: (+1)
   \   000000E2   0x67F2             STR      R2,[R6, #+124]
    418              thermalManager.setTargetHotend(t, 0);
   \   000000E4   0x4610             MOV      R0,R2
   \   000000E6   0x.... 0x....      BL       __aeabi_f2iz
   \   000000EA   0x6038             STR      R0,[R7, #+0]
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xE8BD 0x4FF2      POP      {R1,R4-R11,LR}
   \   000000F2   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??getHighESpeed_0: (+1)
   \   000000F6   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    419            }

   \                                 In section .data, align 4
   \                     _ZN7Planner17block_buffer_headE:
   \   00000000   0x00               DC8 0
   \                     _ZN7Planner17block_buffer_tailE:
   \   00000001   0x00               DC8 0
   \                     _ZN7Planner13last_extruderE:
   \   00000002   0x00               DC8 0
   \                     _ZN7Planner16autotemp_enabledE:
   \   00000003   0x00               DC8 0
   \                     _ZN7Planner17axis_steps_per_mmE:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner11steps_to_mmE:
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner29max_acceleration_steps_per_s2E:
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner8positionE:
   \   00000040   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \                     _ZN7Planner8e_factorE:
   \   00000050   0x3F800000         DC32 3F800000H, 3F800000H
   \              0x3F800000   
   \                     _ZN7Planner12autotemp_maxE:
   \   00000058   0x437A0000         DC32 437A0000H
   \                     _ZN7Planner12autotemp_minE:
   \   0000005C   0x43520000         DC32 43520000H
   \                     _ZN7Planner15autotemp_factorE:
   \   00000060   0x3DCCCCCD         DC32 3DCCCCCDH
   \                     _ZN7Planner11cutoff_longE:
   \   00000064   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN7Planner14previous_speedE:
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner22previous_nominal_speedE:
   \   00000078   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000007C   0x00000000         DC32 0H

   \                                 In section .data, align 4
   \                     _ZN7Planner15flow_percentageE:
   \   00000000   0x0064 0x0064      DC16 100, 100
   \                     _ZN7Planner21volumetric_multiplierE:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner13filament_sizeE:
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    420          
    421          #endif // AUTOTEMP
    422          
    423          /**
    424           * Maintain fans, paste extruder pressure,
    425           */

   \                                 In section .text, align 2, keep-with-next
    426          void Planner::check_axes_activity() {
    427            unsigned char axis_active[NUM_AXIS] = { 0 },
    428                          tail_fan_speed[FAN_COUNT];
                                 ^
Warning[Pe550]: variable "tail_fan_speed" was set but never used
    429          
    430            #if ENABLED(BARICUDA)
    431              #if HAS_HEATER_1
    432                uint8_t tail_valve_pressure;
    433              #endif
    434              #if HAS_HEATER_2
    435                uint8_t tail_e_to_p_pressure;
    436              #endif
    437            #endif
    438          
    439            if (blocks_queued()) {
   \                     _ZN7Planner19check_axes_activityEv: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_5
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x7842             LDRB     R2,[R0, #+1]
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD008             BEQ.N    ??check_axes_activity_0
    440          
    441              #if FAN_COUNT > 0
    442                for (uint8_t i = 0; i < FAN_COUNT; i++)
    443                  tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
   \   0000000A   0x7841             LDRB     R1,[R0, #+1]
    444              #endif
    445          
    446              block_t* block;
    447          
    448              #if ENABLED(BARICUDA)
    449                block = &block_buffer[block_buffer_tail];
    450                #if HAS_HEATER_1
    451                  tail_valve_pressure = block->valve_pressure;
    452                #endif
    453                #if HAS_HEATER_2
    454                  tail_e_to_p_pressure = block->e_to_p_pressure;
    455                #endif
    456              #endif
    457          
    458              for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \   0000000C   0x7841             LDRB     R1,[R0, #+1]
   \   0000000E   0xE002             B.N      ??check_axes_activity_1
    459                block = &block_buffer[b];
    460                LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
   \                     ??check_axes_activity_2: (+1)
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \   00000012   0xF001 0x010F      AND      R1,R1,#0xF
   \                     ??check_axes_activity_1: (+1)
   \   00000016   0x7802             LDRB     R2,[R0, #+0]
   \   00000018   0x4291             CMP      R1,R2
   \   0000001A   0xD1F9             BNE.N    ??check_axes_activity_2
    461              }
    462            }
    463            else {
    464              #if FAN_COUNT > 0
    465                for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
    466              #endif
    467          
    468              #if ENABLED(BARICUDA)
    469                #if HAS_HEATER_1
    470                  tail_valve_pressure = baricuda_valve_pressure;
    471                #endif
    472                #if HAS_HEATER_2
    473                  tail_e_to_p_pressure = baricuda_e_to_p_pressure;
    474                #endif
    475              #endif
    476            }
    477          
    478            #if ENABLED(DISABLE_X)
    479              if (!axis_active[X_AXIS]) disable_X();
    480            #endif
    481            #if ENABLED(DISABLE_Y)
    482              if (!axis_active[Y_AXIS]) disable_Y();
    483            #endif
    484            #if ENABLED(DISABLE_Z)
    485              if (!axis_active[Z_AXIS]) disable_Z();
    486            #endif
    487            #if ENABLED(DISABLE_E)
    488              if (!axis_active[E_AXIS]) disable_e_steppers();
    489            #endif
    490          
    491            #if FAN_COUNT > 0
    492          
    493              #if FAN_KICKSTART_TIME > 0
    494          
    495                static millis_t fan_kick_end[FAN_COUNT] = { 0 };
    496          
    497                #define KICKSTART_FAN(f) \
    498                  if (tail_fan_speed[f]) { \
    499                    millis_t ms = millis(); \
    500                    if (fan_kick_end[f] == 0) { \
    501                      fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
    502                      tail_fan_speed[f] = 255; \
    503                    } else if (PENDING(ms, fan_kick_end[f])) \
    504                      tail_fan_speed[f] = 255; \
    505                  } else fan_kick_end[f] = 0
    506          
    507                #if HAS_FAN0
    508                  KICKSTART_FAN(0);
    509                #endif
    510                #if HAS_FAN1
    511                  KICKSTART_FAN(1);
    512                #endif
    513                #if HAS_FAN2
    514                  KICKSTART_FAN(2);
    515                #endif
    516          
    517              #endif // FAN_KICKSTART_TIME > 0
    518          
    519              #ifdef FAN_MIN_PWM
    520                #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? ( FAN_MIN_PWM + (tail_fan_speed[f] * (255 - FAN_MIN_PWM)) / 255 ) : 0)
    521              #else
    522                #define CALC_FAN_SPEED(f) tail_fan_speed[f]
    523              #endif
    524          
    525              #if ENABLED(FAN_SOFT_PWM)
    526                #if HAS_FAN0
    527                  thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
    528                #endif
    529                #if HAS_FAN1
    530                  thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
    531                #endif
    532                #if HAS_FAN2
    533                  thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
    534                #endif
    535              #else
    536                #if HAS_FAN0
    537                  //analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
    538                #endif
    539                #if HAS_FAN1
    540                  //analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
    541                #endif
    542                #if HAS_FAN2
    543                  //analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
    544                #endif
    545              #endif
    546          
    547            #endif // FAN_COUNT > 0
    548          
    549            #if ENABLED(AUTOTEMP)
    550              getHighESpeed();
   \                     ??check_axes_activity_0: (+1)
   \   0000001C   0x....             B.N      _ZN7Planner13getHighESpeedEv
    551            #endif
    552          
    553            #if ENABLED(BARICUDA)
    554              #if HAS_HEATER_1
    555                analogWrite(HEATER_1_PIN, tail_valve_pressure);
    556              #endif
    557              #if HAS_HEATER_2
    558                analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
    559              #endif
    560            #endif
    561          }
    562          
    563          #if DISABLED(NO_VOLUMETRICS)
    564          
    565            /**
    566             * Get a volumetric multiplier from a filament diameter.
    567             * This is the reciprocal of the circular cross-section area.
    568             * Return 1.0 with volumetric off or a diameter of 0.0.
    569             */
    570            inline float calculate_volumetric_multiplier(const float &diameter) {
    571              return (parser.volumetric_enabled && diameter) ? 1.0 / CIRCLE_AREA(diameter * 0.5) : 1.0;
    572            }
    573          
    574            /**
    575             * Convert the filament sizes into volumetric multipliers.
    576             * The multiplier converts a given E value into a length.
    577             */

   \                                 In section .text, align 2, keep-with-next
    578            void Planner::calculate_volumetric_multipliers() {
   \                     _ZN7Planner32calculate_volumetric_multipliersEv: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
    579              for (uint8_t i = 0; i < COUNT(filament_size); i++) {
   \   00000006   0x....             LDR.N    R0,??DataTable10_15
   \   00000008   0x....             LDR.N    R5,??DataTable10_2  ;; 0x3ff00000
   \   0000000A   0x9004             STR      R0,[SP, #+16]
   \   0000000C   0xF100 0x010C      ADD      R1,R0,#+12
   \   00000010   0x1D00             ADDS     R0,R0,#+4
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0x2600             MOVS     R6,#+0
   \   00000016   0x....             LDR.N    R0,??DataTable10_16
   \   00000018   0x9003             STR      R0,[SP, #+12]
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0x....             LDR.N    R0,??DataTable10_17
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xF88D 0x0008      STRB     R0,[SP, #+8]
    580                volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
   \                     ??calculate_volumetric_multipliers_0: (+1)
   \   00000026   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD034             BEQ.N    ??calculate_volumetric_multipliers_1
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000038   0xD02E             BEQ.N    ??calculate_volumetric_multipliers_1
   \   0000003A   0x.... 0x....      BL       __aeabi_f2d
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x....             LDR.N    R3,??DataTable10_18  ;; 0x3fe00000
   \   00000042   0x.... 0x....      BL       __aeabi_dmul
   \   00000046   0x4680             MOV      R8,R0
   \   00000048   0x4689             MOV      R9,R1
   \   0000004A   0x2702             MOVS     R7,#+2
   \   0000004C   0x46A2             MOV      R10,R4
   \   0000004E   0x46AB             MOV      R11,R5
   \   00000050   0xE007             B.N      ??calculate_volumetric_multipliers_2
   \                     ??calculate_volumetric_multipliers_3: (+1)
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0x4649             MOV      R1,R9
   \   00000056   0x4642             MOV      R2,R8
   \   00000058   0x464B             MOV      R3,R9
   \   0000005A   0x.... 0x....      BL       __aeabi_dmul
   \   0000005E   0x4680             MOV      R8,R0
   \   00000060   0x4689             MOV      R9,R1
   \                     ??calculate_volumetric_multipliers_2: (+1)
   \   00000062   0x07F8             LSLS     R0,R7,#+31
   \   00000064   0xD507             BPL.N    ??calculate_volumetric_multipliers_4
   \   00000066   0x4642             MOV      R2,R8
   \   00000068   0x464B             MOV      R3,R9
   \   0000006A   0x4650             MOV      R0,R10
   \   0000006C   0x4659             MOV      R1,R11
   \   0000006E   0x.... 0x....      BL       __aeabi_dmul
   \   00000072   0x4682             MOV      R10,R0
   \   00000074   0x468B             MOV      R11,R1
   \                     ??calculate_volumetric_multipliers_4: (+1)
   \   00000076   0x087F             LSRS     R7,R7,#+1
   \   00000078   0xD1EB             BNE.N    ??calculate_volumetric_multipliers_3
   \   0000007A   0x....             LDR.N    R0,??DataTable10_3  ;; 0x54442d18
   \   0000007C   0x....             LDR.N    R1,??DataTable10_4  ;; 0x400921fb
   \   0000007E   0x4652             MOV      R2,R10
   \   00000080   0x465B             MOV      R3,R11
   \   00000082   0x.... 0x....      BL       __aeabi_dmul
   \   00000086   0x4602             MOV      R2,R0
   \   00000088   0x460B             MOV      R3,R1
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x4629             MOV      R1,R5
   \   0000008E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000092   0x.... 0x....      BL       __aeabi_d2f
   \   00000096   0xE001             B.N      ??calculate_volumetric_multipliers_5
   \                     ??calculate_volumetric_multipliers_1: (+1)
   \   00000098   0xF04F 0x507E      MOV      R0,#+1065353216
   \                     ??calculate_volumetric_multipliers_5: (+1)
   \   0000009C   0x9901             LDR      R1,[SP, #+4]
   \   0000009E   0x6008             STR      R0,[R1, #+0]
    581                refresh_e_factor(i);
   \   000000A0   0x9804             LDR      R0,[SP, #+16]
   \   000000A2   0x1C80             ADDS     R0,R0,#+2
   \   000000A4   0x9004             STR      R0,[SP, #+16]
   \   000000A6   0x1E80             SUBS     R0,R0,#+2
   \   000000A8   0x5F00             LDRSH    R0,[R0, R4]
   \   000000AA   0x.... 0x....      BL       __aeabi_i2d
   \   000000AE   0x....             LDR.N    R2,??DataTable10_19  ;; 0x47ae147b
   \   000000B0   0x....             LDR.N    R3,??DataTable10_20  ;; 0x3f847ae1
   \   000000B2   0x.... 0x....      BL       __aeabi_dmul
   \   000000B6   0x4607             MOV      R7,R0
   \   000000B8   0x9801             LDR      R0,[SP, #+4]
   \   000000BA   0x1D00             ADDS     R0,R0,#+4
   \   000000BC   0x9001             STR      R0,[SP, #+4]
   \   000000BE   0x4689             MOV      R9,R1
   \   000000C0   0x1F00             SUBS     R0,R0,#+4
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0x.... 0x....      BL       __aeabi_f2d
   \   000000C8   0x463A             MOV      R2,R7
   \   000000CA   0x464B             MOV      R3,R9
   \   000000CC   0x.... 0x....      BL       __aeabi_dmul
   \   000000D0   0x.... 0x....      BL       __aeabi_d2f
   \   000000D4   0x9903             LDR      R1,[SP, #+12]
   \   000000D6   0x1D09             ADDS     R1,R1,#+4
   \   000000D8   0x9103             STR      R1,[SP, #+12]
    582              }
   \   000000DA   0x1C76             ADDS     R6,R6,#+1
   \   000000DC   0xF841 0x0D04      STR      R0,[R1, #-4]!
   \   000000E0   0x9800             LDR      R0,[SP, #+0]
   \   000000E2   0x1D00             ADDS     R0,R0,#+4
   \   000000E4   0x9000             STR      R0,[SP, #+0]
   \   000000E6   0x2E02             CMP      R6,#+2
   \   000000E8   0xD39D             BCC.N    ??calculate_volumetric_multipliers_0
    583            }
   \   000000EA                      REQUIRE ?Subroutine1
   \   000000EA                      ;; // Fall through to label ?Subroutine1
    584          
    585          #endif // !NO_VOLUMETRICS
    586          
    587          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    588            /**
    589             * Convert the ratio value given by the filament width sensor
    590             * into a volumetric multiplier. Conversion differs when using
    591             * linear extrusion vs volumetric extrusion.
    592             */
    593            void Planner::calculate_volumetric_for_width_sensor(const int8_t encoded_ratio) {
    594              // Reconstitute the nominal/measured ratio
    595              const float nom_meas_ratio = 1.0 + 0.01 * encoded_ratio,
    596                          ratio_2 = sq(nom_meas_ratio);
    597          
    598              volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
    599                ? ratio_2 / CIRCLE_AREA(filament_width_nominal * 0.5) // Volumetric uses a true volumetric multiplier
    600                : ratio_2;                                            // Linear squares the ratio, which scales the volume
    601          
    602              refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
    603            }
    604          #endif
    605          
    606          #if 1//PLANNER_LEVELING
    607            /**
    608             * rx, ry, rz - Cartesian positions in mm
    609             *              Leveled XYZ on completion
    610             */

   \                                 In section .text, align 2, keep-with-next
    611            void Planner::apply_leveling(float &rx, float &ry, float &rz) {
   \                     _ZN7Planner14apply_levelingERfS0_S0_: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    612          
    613              #if ENABLED(SKEW_CORRECTION)
    614                skew(rx, ry, rz);
    615              #endif
    616          
    617              if (!leveling_active) return;
   \   00000004   0x....             LDR.N    R0,??DataTable10_21
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xB08A             SUB      SP,SP,#+40
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0x4616             MOV      R6,R2
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD04A             BEQ.N    ??apply_leveling_0
   \   00000012   0x....             LDR.N    R0,??DataTable10_22
   \   00000014   0xF890 0x0042      LDRB     R0,[R0, #+66]
   \   00000018   0x2106             MOVS     R1,#+6
   \   0000001A   0x4208             TST      R0,R1
   \   0000001C   0xD017             BEQ.N    ??apply_leveling_1
    618          
    619              //#if ABL_PLANAR
    620              if(BED_LEVELING_METHOD & ABL_PLANAR)
    621              {
    622                float dx = rx - (X_TILT_FULCRUM),
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
    623                      dy = ry - (Y_TILT_FULCRUM);
    624          
    625                apply_rotation_xyz(bed_level_matrix, dx, dy, rz);
   \   00000020   0x....             LDR.N    R1,??DataTable10_6
   \   00000022   0x9009             STR      R0,[SP, #+36]
   \   00000024   0x2224             MOVS     R2,#+36
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x9008             STR      R0,[SP, #+32]
   \   0000002A   0x9607             STR      R6,[SP, #+28]
   \   0000002C   0xA808             ADD      R0,SP,#+32
   \   0000002E   0x9006             STR      R0,[SP, #+24]
   \   00000030   0xA809             ADD      R0,SP,#+36
   \   00000032   0x9005             STR      R0,[SP, #+20]
   \   00000034   0xB084             SUB      SP,SP,#+16
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000003C   0xBC0F             POP      {R0-R3}
   \   0000003E   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
    626          
    627                rx = dx + X_TILT_FULCRUM;
   \   00000042   0x9809             LDR      R0,[SP, #+36]
   \   00000044   0x6020             STR      R0,[R4, #+0]
    628                ry = dy + Y_TILT_FULCRUM;
   \   00000046   0x9808             LDR      R0,[SP, #+32]
   \   00000048   0x6028             STR      R0,[R5, #+0]
    629              }
    630              //#else
    631              else
    632              {
    633                #if 0//ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    634                  const float fade_scaling_factor = fade_scaling_factor_for_z(rz);
    635                  if (!fade_scaling_factor) return;
    636                //#elif HAS_MESH
    637                #else
    638                  float fade_scaling_factor;
    639                  if(BED_LEVELING_METHOD & HAS_MESH)
    640                      fade_scaling_factor = 1.0;
    641                #endif
    642          
    643                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
    644                float raw[XYZ];
    645                if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
    646                {
    647                  raw[0] = rx;
    648                  raw[1] = ry;
    649                  raw[2] = 0;
    650                }
    651                //#endif
    652          /*
    653                rz += (
    654                  #if ENABLED(AUTO_BED_LEVELING_UBL)
    655                    ubl.get_z_correction(rx, ry) * fade_scaling_factor
    656                  #elif ENABLED(MESH_BED_LEVELING)
    657                    mbl.get_z(rx, ry
    658                      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    659                        , fade_scaling_factor
    660                      #endif
    661                    )
    662                  #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
    663                    bilinear_z_offset(raw) * fade_scaling_factor
    664                  #else
    665                    0
    666                  #endif
    667                );
    668          */        
    669                  if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
    670                      rz += (ubl.get_z_correction(rx, ry) * fade_scaling_factor);
    671                  else if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
    672                      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    673                      rz += ( mbl.get_z(rx, ry,fade_scaling_factor));
    674                      #else
    675                      rz += ( mbl.get_z(rx, ry));
    676                      #endif
    677                  else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
    678                      rz += bilinear_z_offset(raw) * fade_scaling_factor;
    679                  else
    680                      rz += 0;
    681                  //#endif
    682              }
    683              //#endif
    684            }
   \   0000004A   0xB00A             ADD      SP,SP,#+40
   \   0000004C   0xBD70             POP      {R4-R6,PC}
   \                     ??apply_leveling_1: (+1)
   \   0000004E   0x2138             MOVS     R1,#+56
   \   00000050   0x4208             TST      R0,R1
   \   00000052   0xBF1C             ITT      NE 
   \   00000054   0xF04F 0x517E      MOVNE    R1,#+1065353216
   \   00000058   0x9100             STRNE    R1,[SP, #+0]
   \   0000005A   0xF010 0x0108      ANDS     R1,R0,#0x8
   \   0000005E   0xD005             BEQ.N    ??apply_leveling_2
   \   00000060   0x6822             LDR      R2,[R4, #+0]
   \   00000062   0x9201             STR      R2,[SP, #+4]
   \   00000064   0x682A             LDR      R2,[R5, #+0]
   \   00000066   0x9202             STR      R2,[SP, #+8]
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x9203             STR      R2,[SP, #+12]
   \                     ??apply_leveling_2: (+1)
   \   0000006C   0x06C2             LSLS     R2,R0,#+27
   \   0000006E   0xD505             BPL.N    ??apply_leveling_3
   \   00000070   0x4629             MOV      R1,R5
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       _ZN20unified_bed_leveling16get_z_correctionERKfS1_
   \   00000078   0x9900             LDR      R1,[SP, #+0]
   \   0000007A   0xE00F             B.N      ??apply_leveling_4
   \                     ??apply_leveling_3: (+1)
   \   0000007C   0x0680             LSLS     R0,R0,#+26
   \   0000007E   0xD507             BPL.N    ??apply_leveling_5
   \   00000080   0xAA00             ADD      R2,SP,#+0
   \   00000082   0x4629             MOV      R1,R5
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       _ZN17mesh_bed_leveling5get_zERKfS1_S1_
   \   0000008A   0x4601             MOV      R1,R0
   \   0000008C   0x6830             LDR      R0,[R6, #+0]
   \   0000008E   0xE008             B.N      ??apply_leveling_6
   \                     ??apply_leveling_5: (+1)
   \   00000090   0xB151             CBZ.N    R1,??apply_leveling_0
   \   00000092   0xA801             ADD      R0,SP,#+4
   \   00000094   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \   00000098   0x4601             MOV      R1,R0
   \   0000009A   0x9800             LDR      R0,[SP, #+0]
   \                     ??apply_leveling_4: (+1)
   \   0000009C   0x.... 0x....      BL       __aeabi_fmul
   \   000000A0   0x6831             LDR      R1,[R6, #+0]
   \                     ??apply_leveling_6: (+1)
   \   000000A2   0x.... 0x....      BL       __aeabi_fadd
   \   000000A6   0x6030             STR      R0,[R6, #+0]
   \                     ??apply_leveling_0: (+1)
   \   000000A8   0xB00A             ADD      SP,SP,#+40
   \   000000AA   0xBD70             POP      {R4-R6,PC}       ;; return
    685          

   \                                 In section .text, align 2, keep-with-next
    686            void Planner::unapply_leveling(float raw[XYZ]) {
   \                     _ZN7Planner16unapply_levelingEPf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x4604             MOV      R4,R0
    687          
    688              #if 0//ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    689                const float fade_scaling_factor = fade_scaling_factor_for_z(raw[Z_AXIS]);
    690              #else
    691                constexpr float fade_scaling_factor = 1.0;
   \   00000006   0xF04F 0x507E      MOV      R0,#+1065353216
   \   0000000A   0x900A             STR      R0,[SP, #+40]
    692              #endif
    693          
    694              if (leveling_active && fade_scaling_factor) {
   \   0000000C   0x....             LDR.N    R0,??DataTable10_21
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD047             BEQ.N    ??unapply_leveling_0
   \   00000014   0x....             LDR.N    R0,??DataTable10_22
   \   00000016   0xF890 0x0042      LDRB     R0,[R0, #+66]
   \   0000001A   0x2106             MOVS     R1,#+6
   \   0000001C   0x4208             TST      R0,R1
   \   0000001E   0xD023             BEQ.N    ??unapply_leveling_1
    695          
    696                //#if ABL_PLANAR
    697                if(BED_LEVELING_METHOD & ABL_PLANAR)
    698                {
    699                  matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
   \   00000020   0xB083             SUB      SP,SP,#+12
   \   00000022   0x....             LDR.N    R1,??DataTable10_6
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x2224             MOVS     R2,#+36
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002C   0xBC0E             POP      {R1-R3}
   \   0000002E   0xA80B             ADD      R0,SP,#+44
   \   00000030   0x.... 0x....      BL       _ZN10matrix_3x39transposeES_
    700          
    701                  float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x9009             STR      R0,[SP, #+36]
    702                        dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);
    703          
    704                  apply_rotation_xyz(inverse, dx, dy, raw[Z_AXIS]);
   \   00000038   0xA90B             ADD      R1,SP,#+44
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0x9008             STR      R0,[SP, #+32]
   \   0000003E   0x2224             MOVS     R2,#+36
   \   00000040   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000044   0x9007             STR      R0,[SP, #+28]
   \   00000046   0xA808             ADD      R0,SP,#+32
   \   00000048   0x9006             STR      R0,[SP, #+24]
   \   0000004A   0xA809             ADD      R0,SP,#+36
   \   0000004C   0x9005             STR      R0,[SP, #+20]
   \   0000004E   0xB084             SUB      SP,SP,#+16
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000056   0xBC0F             POP      {R0-R3}
   \   00000058   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
    705          
    706                  raw[X_AXIS] = dx + X_TILT_FULCRUM;
   \   0000005C   0x9809             LDR      R0,[SP, #+36]
   \   0000005E   0x6020             STR      R0,[R4, #+0]
    707                  raw[Y_AXIS] = dy + Y_TILT_FULCRUM;
   \   00000060   0x9808             LDR      R0,[SP, #+32]
   \   00000062   0x6060             STR      R0,[R4, #+4]
    708                }
    709                //#else // !ABL_PLANAR
    710                else
    711                {
    712                  if((BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL))
    713                  {
    714                    raw[Z_AXIS] -= (ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) * fade_scaling_factor);
    715                  }
    716                  else if((BED_LEVELING_METHOD == MESH_BED_LEVELING))
    717                  {
    718                      
    719                      raw[Z_AXIS] -= mbl.get_z(raw[X_AXIS], raw[Y_AXIS]
    720                        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    721                          , fade_scaling_factor
    722                        #endif
    723                      );
    724                  }
    725                  else if((BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR))
    726                  {
    727                      raw[Z_AXIS] -= (bilinear_z_offset(raw) * fade_scaling_factor);
    728                  }
    729                  else
    730                  {
    731                      raw[Z_AXIS] -= 0;
    732                  }
    733                  /*
    734                  raw[Z_AXIS] -= (
    735                    #if ENABLED(AUTO_BED_LEVELING_UBL)
    736                      ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) * fade_scaling_factor
    737                    #elif ENABLED(MESH_BED_LEVELING)
    738                      mbl.get_z(raw[X_AXIS], raw[Y_AXIS]
    739                        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    740                          , fade_scaling_factor
    741                        #endif
    742                      )
    743                    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
    744                      bilinear_z_offset(raw) * fade_scaling_factor
    745                    #else
    746                      0
    747                    #endif
    748                  );
    749                  */
    750                }
    751                //#endif // !ABL_PLANAR
    752              }
    753          
    754              #if ENABLED(SKEW_CORRECTION)
    755                unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
    756              #endif
    757            }
   \   00000064   0xB014             ADD      SP,SP,#+80
   \   00000066   0xBD10             POP      {R4,PC}
   \                     ??unapply_leveling_1: (+1)
   \   00000068   0x2810             CMP      R0,#+16
   \   0000006A   0xD105             BNE.N    ??unapply_leveling_2
   \   0000006C   0x1D21             ADDS     R1,R4,#+4
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       _ZN20unified_bed_leveling16get_z_correctionERKfS1_
   \   00000074   0x990A             LDR      R1,[SP, #+40]
   \   00000076   0xE00E             B.N      ??unapply_leveling_3
   \                     ??unapply_leveling_2: (+1)
   \   00000078   0x2820             CMP      R0,#+32
   \   0000007A   0xD105             BNE.N    ??unapply_leveling_4
   \   0000007C   0xAA0A             ADD      R2,SP,#+40
   \   0000007E   0x1D21             ADDS     R1,R4,#+4
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       _ZN17mesh_bed_leveling5get_zERKfS1_S1_
   \   00000086   0xE008             B.N      ??unapply_leveling_5
   \                     ??unapply_leveling_4: (+1)
   \   00000088   0x2808             CMP      R0,#+8
   \   0000008A   0xD10B             BNE.N    ??unapply_leveling_0
   \   0000008C   0x4620             MOV      R0,R4
   \   0000008E   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \   00000092   0x4601             MOV      R1,R0
   \   00000094   0x980A             LDR      R0,[SP, #+40]
   \                     ??unapply_leveling_3: (+1)
   \   00000096   0x.... 0x....      BL       __aeabi_fmul
   \                     ??unapply_leveling_5: (+1)
   \   0000009A   0x4601             MOV      R1,R0
   \   0000009C   0x68A0             LDR      R0,[R4, #+8]
   \   0000009E   0x.... 0x....      BL       __aeabi_fsub
   \   000000A2   0x60A0             STR      R0,[R4, #+8]
   \                     ??unapply_leveling_0: (+1)
   \   000000A4   0xB014             ADD      SP,SP,#+80
   \   000000A6   0xBD10             POP      {R4,PC}          ;; return
    758          
    759          #endif // PLANNER_LEVELING
    760          
    761          /**
    762           * Planner::_buffer_steps
    763           *
    764           * Add a new linear movement to the buffer (in terms of steps).
    765           *
    766           *  target      - target position in steps units
    767           *  fr_mm_s     - (target) speed of the move
    768           *  extruder    - target extruder
    769           */

   \                                 In section .text, align 2, keep-with-next
    770          void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const uint8_t extruder) {
   \                     _ZN7Planner13_buffer_stepsERA4_Kifh: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
    771          
    772            const int32_t da = target[X_AXIS] - position[X_AXIS],
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable11
   \   00000008   0x6C21             LDR      R1,[R4, #+64]
   \   0000000A   0xB092             SUB      SP,SP,#+72
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xEBA0 0x0A01      SUB      R10,R0,R1
    773                          db = target[Y_AXIS] - position[Y_AXIS],
   \   00000012   0x9812             LDR      R0,[SP, #+72]
   \   00000014   0x6C61             LDR      R1,[R4, #+68]
   \   00000016   0x6840             LDR      R0,[R0, #+4]
   \   00000018   0xEBA0 0x0801      SUB      R8,R0,R1
    774                          dc = target[Z_AXIS] - position[Z_AXIS];
   \   0000001C   0x9812             LDR      R0,[SP, #+72]
   \   0000001E   0x6CA1             LDR      R1,[R4, #+72]
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0xEBA0 0x0901      SUB      R9,R0,R1
    775          
    776            int32_t de = target[E_AXIS] - position[E_AXIS];
   \   00000026   0x9812             LDR      R0,[SP, #+72]
   \   00000028   0x68C6             LDR      R6,[R0, #+12]
   \   0000002A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000002C   0x1A35             SUBS     R5,R6,R0
    777          
    778          
    779            /* <-- add a slash to enable
    780              SERIAL_ECHOPAIR("  _buffer_steps FR:", fr_mm_s);
    781              SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
    782              SERIAL_ECHOPAIR(" (", da);
    783              SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
    784              SERIAL_ECHOPAIR(" (", db);
    785              SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
    786              SERIAL_ECHOPAIR(" (", dc);
    787              SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
    788              SERIAL_ECHOPAIR(" (", de);
    789              SERIAL_ECHOLNPGM(" steps)");
    790            //*/
                    ^
Warning[Pe009]: nested comment is not allowed
    791          
    792            // If LIN_ADVANCE is disabled then do E move prevention with integers
    793            // Otherwise it's done in _buffer_segment.
    794            #if DISABLED(LIN_ADVANCE) && (ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE))
    795              if (de) {
   \   0000002E   0xD060             BEQ.N    ??_buffer_steps_0
    796                #if ENABLED(PREVENT_COLD_EXTRUSION)
    797                  if (thermalManager.tooColdToExtrude(extruder)) {
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x4617             MOV      R7,R2
   \   00000038   0xBB38             CBNZ.N   R0,??_buffer_steps_1
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000003E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000042   0x.... 0x....      BL       __aeabi_i2f
   \   00000046   0x4601             MOV      R1,R0
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   0000004C   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   00000050   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000054   0xD219             BCS.N    ??_buffer_steps_1
    798                    position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \   00000056   0x64E6             STR      R6,[R4, #+76]
    799                    de = 0; // no difference
   \   00000058   0x2500             MOVS     R5,#+0
    800                    SERIAL_ECHO_START();
   \   0000005A   0x.... 0x....      LDR.W    R6,??DataTable11_4
   \   0000005E   0x.... 0x....      LDR.W    R11,??DataTable11_5
   \   00000062   0xE003             B.N      ??_buffer_steps_2
   \                     ??_buffer_steps_3: (+1)
   \   00000064   0xB2C9             UXTB     R1,R1
   \   00000066   0x4658             MOV      R0,R11
   \   00000068   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??_buffer_steps_2: (+1)
   \   0000006C   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   00000070   0x0008             MOVS     R0,R1
   \   00000072   0xD1F7             BNE.N    ??_buffer_steps_3
    801                    SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
   \   00000074   0x.... 0x....      LDR.W    R6,??DataTable11_6
   \   00000078   0xE003             B.N      ??_buffer_steps_4
   \                     ??_buffer_steps_5: (+1)
   \   0000007A   0xB2C9             UXTB     R1,R1
   \   0000007C   0x4658             MOV      R0,R11
   \   0000007E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??_buffer_steps_4: (+1)
   \   00000082   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   00000086   0x0008             MOVS     R0,R1
   \   00000088   0xD1F7             BNE.N    ??_buffer_steps_5
    802                  }
    803                #endif // PREVENT_COLD_EXTRUSION
    804                #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
    805                  if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_1: (+1)
   \   0000008A   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \   0000008E   0x9001             STR      R0,[SP, #+4]
   \   00000090   0x4628             MOV      R0,R5
   \   00000092   0x.... 0x....      BL       __aeabi_i2f
   \   00000096   0x9901             LDR      R1,[SP, #+4]
   \   00000098   0x6D09             LDR      R1,[R1, #+80]
   \   0000009A   0x.... 0x....      BL       __aeabi_fmul
   \   0000009E   0x.... 0x....      BL       __aeabi_f2iz
   \   000000A2   0x0006             MOVS     R6,R0
   \   000000A4   0xBF48             IT       MI 
   \   000000A6   0x4276             RSBMI    R6,R6,#+0
   \   000000A8   0x9801             LDR      R0,[SP, #+4]
   \   000000AA   0x6900             LDR      R0,[R0, #+16]
   \   000000AC   0x.... 0x....      BL       __aeabi_f2iz
   \   000000B0   0xF44F 0x717A      MOV      R1,#+1000
   \   000000B4   0x4348             MULS     R0,R1,R0
   \   000000B6   0x42B0             CMP      R0,R6
   \   000000B8   0xDA1B             BGE.N    ??_buffer_steps_0
    806                    position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \   000000BA   0x9812             LDR      R0,[SP, #+72]
    807                    de = 0; // no difference
    808                    SERIAL_ECHO_START();
   \   000000BC   0x.... 0x....      LDR.W    R6,??DataTable11_4
   \   000000C0   0x68C0             LDR      R0,[R0, #+12]
   \   000000C2   0x.... 0x....      LDR.W    R7,??DataTable11_5
   \   000000C6   0x64E0             STR      R0,[R4, #+76]
   \   000000C8   0x2500             MOVS     R5,#+0
   \   000000CA   0xE003             B.N      ??_buffer_steps_6
   \                     ??_buffer_steps_7: (+1)
   \   000000CC   0xB2C9             UXTB     R1,R1
   \   000000CE   0x4638             MOV      R0,R7
   \   000000D0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??_buffer_steps_6: (+1)
   \   000000D4   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   000000D8   0x0008             MOVS     R0,R1
   \   000000DA   0xD1F7             BNE.N    ??_buffer_steps_7
    809                    SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   \   000000DC   0x.... 0x....      LDR.W    R6,??DataTable11_7
   \   000000E0   0xE003             B.N      ??_buffer_steps_8
   \                     ??_buffer_steps_9: (+1)
   \   000000E2   0xB2C9             UXTB     R1,R1
   \   000000E4   0x4638             MOV      R0,R7
   \   000000E6   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??_buffer_steps_8: (+1)
   \   000000EA   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   000000EE   0x0008             MOVS     R0,R1
   \   000000F0   0xD1F7             BNE.N    ??_buffer_steps_9
    810                  }
    811                #endif // PREVENT_LENGTHY_EXTRUDE
    812              }
    813            #endif // !LIN_ADVANCE && (PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE)
    814          
    815            // Compute direction bit-mask for this block
    816            uint8_t dm = 0;
   \                     ??_buffer_steps_0: (+1)
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \   000000F6   0xF9B0 0x1058      LDRSH    R1,[R0, #+88]
   \   000000FA   0x2600             MOVS     R6,#+0
   \   000000FC   0x220C             MOVS     R2,#+12
   \   000000FE   0x4211             TST      R1,R2
   \   00000100   0xD01D             BEQ.N    ??_buffer_steps_10
    817            //#if CORE_IS_XY
    818            if(MACHINETPYE & CORE_IS_XY)
    819            {
    820              if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
   \   00000102   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000106   0xBF48             IT       MI 
   \   00000108   0x2610             MOVMI    R6,#+16
    821              if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
   \   0000010A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000010E   0xBF48             IT       MI 
   \   00000110   0xF046 0x0620      ORRMI    R6,R6,#0x20
    822              if (dc < 0) SBI(dm, Z_AXIS);
   \   00000114   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000118   0xBF48             IT       MI 
   \   0000011A   0xF046 0x0604      ORRMI    R6,R6,#0x4
    823              if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
   \   0000011E   0xEB18 0x000A      ADDS     R0,R8,R10
   \   00000122   0xBF48             IT       MI 
   \   00000124   0xF046 0x0601      ORRMI    R6,R6,#0x1
    824              if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
   \   00000128   0x23A8             MOVS     R3,#+168
   \   0000012A   0xEBAA 0x0208      SUB      R2,R10,R8
   \   0000012E   0x4219             TST      R1,R3
   \   00000130   0xBF18             IT       NE 
   \   00000132   0x4252             RSBNE    R2,R2,#+0
   \   00000134   0x2A00             CMP      R2,#+0
   \   00000136   0xD54C             BPL.N    ??_buffer_steps_11
   \   00000138   0xF046 0x0602      ORR      R6,R6,#0x2
   \   0000013C   0xE049             B.N      ??_buffer_steps_11
    825            }
    826            //#elif CORE_IS_XZ
    827            else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_steps_10: (+1)
   \   0000013E   0x2230             MOVS     R2,#+48
   \   00000140   0x4211             TST      R1,R2
   \   00000142   0xD01A             BEQ.N    ??_buffer_steps_12
    828            {
    829              if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
   \   00000144   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000148   0xBF48             IT       MI 
   \   0000014A   0x2610             MOVMI    R6,#+16
    830              if (db < 0) SBI(dm, Y_AXIS);
   \   0000014C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000150   0xBF48             IT       MI 
   \   00000152   0xF046 0x0602      ORRMI    R6,R6,#0x2
    831              if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
   \   00000156   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000015A   0xBF48             IT       MI 
   \   0000015C   0xF046 0x0640      ORRMI    R6,R6,#0x40
    832              if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
   \   00000160   0xEB19 0x000A      ADDS     R0,R9,R10
   \   00000164   0xBF48             IT       MI 
   \   00000166   0xF046 0x0601      ORRMI    R6,R6,#0x1
    833              if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   \   0000016A   0x23A8             MOVS     R3,#+168
   \   0000016C   0xEBAA 0x0209      SUB      R2,R10,R9
   \   00000170   0x4219             TST      R1,R3
   \   00000172   0xBF18             IT       NE 
   \   00000174   0x4252             RSBNE    R2,R2,#+0
    834            }
   \   00000176   0x2A00             CMP      R2,#+0
   \   00000178   0xE028             B.N      ??_buffer_steps_13
    835            //#elif CORE_IS_YZ
    836            else if(MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_steps_12: (+1)
   \   0000017A   0x22C0             MOVS     R2,#+192
   \   0000017C   0x4211             TST      R1,R2
   \   0000017E   0xD01A             BEQ.N    ??_buffer_steps_14
    837            {
    838              if (da < 0) SBI(dm, X_AXIS);
   \   00000180   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000184   0xBF48             IT       MI 
   \   00000186   0x2601             MOVMI    R6,#+1
    839              if (db < 0) SBI(dm, Y_HEAD);                // Save the real Extruder (head) direction in Y Axis
   \   00000188   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000018C   0xBF48             IT       MI 
   \   0000018E   0xF046 0x0620      ORRMI    R6,R6,#0x20
    840              if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
   \   00000192   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000196   0xBF48             IT       MI 
   \   00000198   0xF046 0x0640      ORRMI    R6,R6,#0x40
    841              if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
   \   0000019C   0xEB19 0x0008      ADDS     R0,R9,R8
   \   000001A0   0xBF48             IT       MI 
   \   000001A2   0xF046 0x0602      ORRMI    R6,R6,#0x2
    842              if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   \   000001A6   0x23A8             MOVS     R3,#+168
   \   000001A8   0xEBA8 0x0209      SUB      R2,R8,R9
   \   000001AC   0x4219             TST      R1,R3
   \   000001AE   0xBF18             IT       NE 
   \   000001B0   0x4252             RSBNE    R2,R2,#+0
    843            }
   \   000001B2   0x2A00             CMP      R2,#+0
   \   000001B4   0xE00A             B.N      ??_buffer_steps_13
    844            //#else
    845            else
    846            {
    847              if (da < 0) SBI(dm, X_AXIS);
   \                     ??_buffer_steps_14: (+1)
   \   000001B6   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001BA   0xBF48             IT       MI 
   \   000001BC   0x2601             MOVMI    R6,#+1
    848              if (db < 0) SBI(dm, Y_AXIS);
   \   000001BE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001C2   0xBF48             IT       MI 
   \   000001C4   0xF046 0x0602      ORRMI    R6,R6,#0x2
    849              if (dc < 0) SBI(dm, Z_AXIS);
   \   000001C8   0xF1B9 0x0F00      CMP      R9,#+0
   \                     ??_buffer_steps_13: (+1)
   \   000001CC   0xBF48             IT       MI 
   \   000001CE   0xF046 0x0604      ORRMI    R6,R6,#0x4
    850            }
    851            //#endif
    852            if (de < 0) SBI(dm, E_AXIS);
   \                     ??_buffer_steps_11: (+1)
   \   000001D2   0x2D00             CMP      R5,#+0
   \   000001D4   0xBF48             IT       MI 
   \   000001D6   0xF046 0x0608      ORRMI    R6,R6,#0x8
    853          
    854            const float esteps_float = de * e_factor[extruder];
   \   000001DA   0xF89D 0x7050      LDRB     R7,[SP, #+80]
   \   000001DE   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \   000001E2   0x9001             STR      R0,[SP, #+4]
   \   000001E4   0x4628             MOV      R0,R5
   \   000001E6   0x.... 0x....      BL       __aeabi_i2f
   \   000001EA   0x9901             LDR      R1,[SP, #+4]
   \   000001EC   0x6D09             LDR      R1,[R1, #+80]
   \   000001EE   0x.... 0x....      BL       __aeabi_fmul
   \   000001F2   0x9000             STR      R0,[SP, #+0]
    855            const int32_t esteps = abs(esteps_float) + 0.5;
                                          ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000001F4   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   000001F8   0x.... 0x....      BL       __aeabi_f2d
   \   000001FC   0x2200             MOVS     R2,#+0
   \   000001FE   0x.... 0x....      LDR.W    R3,??DataTable11_9  ;; 0x3fe00000
   \   00000202   0x.... 0x....      BL       __aeabi_dadd
   \   00000206   0x.... 0x....      BL       __aeabi_d2iz
   \   0000020A   0x9002             STR      R0,[SP, #+8]
    856          
    857            // Calculate the buffer head after we push this byte
    858            const uint8_t next_buffer_head = next_block_index(block_buffer_head);
   \   0000020C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000210   0x1C40             ADDS     R0,R0,#+1
   \   00000212   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000216   0x9006             STR      R0,[SP, #+24]
   \   00000218   0xE001             B.N      ??_buffer_steps_15
    859          
    860            // If the buffer is full: good! That means we are well ahead of the robot.
    861            // Rest here until there is room in the buffer.
    862            while (block_buffer_tail == next_buffer_head) idle();
   \                     ??_buffer_steps_16: (+1)
   \   0000021A   0x.... 0x....      BL       _Z4idlev
   \                     ??_buffer_steps_15: (+1)
   \   0000021E   0x7860             LDRB     R0,[R4, #+1]
   \   00000220   0x9906             LDR      R1,[SP, #+24]
   \   00000222   0xB2C9             UXTB     R1,R1
   \   00000224   0x4288             CMP      R0,R1
   \   00000226   0xD0F8             BEQ.N    ??_buffer_steps_16
    863          
    864            // Prepare to set up new block
    865            block_t* block = &block_buffer[block_buffer_head];
   \   00000228   0x2154             MOVS     R1,#+84
   \   0000022A   0x7820             LDRB     R0,[R4, #+0]
   \   0000022C   0x.... 0x....      LDR.W    R2,??DataTable11_10
   \   00000230   0xFB01 0x2700      MLA      R7,R1,R0,R2
    866          
    867            // Clear all flags, including the "busy" bit
    868            block->flag = 0x00;
   \   00000234   0x2000             MOVS     R0,#+0
   \   00000236   0x7038             STRB     R0,[R7, #+0]
    869          
    870            // Set direction bits
    871            block->direction_bits = dm;
   \   00000238   0xF887 0x6024      STRB     R6,[R7, #+36]
    872          
    873            // Number of steps for each axis
    874            // See http://www.corexy.com/theory.html
    875            //#if CORE_IS_XY
    876            if(MACHINETPYE & CORE_IS_XY)
   \   0000023C   0x210C             MOVS     R1,#+12
   \   0000023E   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \   00000242   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   00000246   0x4208             TST      R0,R1
   \   00000248   0xD007             BEQ.N    ??_buffer_steps_17
    877            {
    878              block->steps[A_AXIS] = labs(da + db);
   \   0000024A   0xEB18 0x000A      ADDS     R0,R8,R10
   \   0000024E   0xBF48             IT       MI 
   \   00000250   0x4240             RSBMI    R0,R0,#+0
   \   00000252   0x6078             STR      R0,[R7, #+4]
    879              block->steps[B_AXIS] = labs(da - db);
   \   00000254   0xEBBA 0x0008      SUBS     R0,R10,R8
   \   00000258   0xE021             B.N      ??_buffer_steps_18
    880              block->steps[Z_AXIS] = labs(dc);
    881            }
    882            //#elif CORE_IS_XZ
    883            else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_steps_17: (+1)
   \   0000025A   0x2130             MOVS     R1,#+48
   \   0000025C   0x4208             TST      R0,R1
   \   0000025E   0xD00C             BEQ.N    ??_buffer_steps_19
    884            {
    885              block->steps[A_AXIS] = labs(da + dc);
   \   00000260   0xEB19 0x000A      ADDS     R0,R9,R10
   \   00000264   0xBF48             IT       MI 
   \   00000266   0x4240             RSBMI    R0,R0,#+0
   \   00000268   0x6078             STR      R0,[R7, #+4]
    886              block->steps[Y_AXIS] = labs(db);
   \   0000026A   0x4640             MOV      R0,R8
   \   0000026C   0x2800             CMP      R0,#+0
   \   0000026E   0xBF48             IT       MI 
   \   00000270   0x4240             RSBMI    R0,R0,#+0
   \   00000272   0x60B8             STR      R0,[R7, #+8]
    887              block->steps[C_AXIS] = labs(da - dc);
   \   00000274   0xEBBA 0x0009      SUBS     R0,R10,R9
   \   00000278   0xE016             B.N      ??_buffer_steps_20
    888            }
    889            //#elif CORE_IS_YZ
    890            else if(MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_steps_19: (+1)
   \   0000027A   0xEA5F 0x010A      MOVS     R1,R10
   \   0000027E   0xBF48             IT       MI 
   \   00000280   0x4249             RSBMI    R1,R1,#+0
   \   00000282   0x22C0             MOVS     R2,#+192
   \   00000284   0x4210             TST      R0,R2
   \   00000286   0x6079             STR      R1,[R7, #+4]
   \   00000288   0xD007             BEQ.N    ??_buffer_steps_21
    891            {
    892              block->steps[X_AXIS] = labs(da);
    893              block->steps[B_AXIS] = labs(db + dc);
   \   0000028A   0xEB19 0x0008      ADDS     R0,R9,R8
   \   0000028E   0xBF48             IT       MI 
   \   00000290   0x4240             RSBMI    R0,R0,#+0
   \   00000292   0x60B8             STR      R0,[R7, #+8]
    894              block->steps[C_AXIS] = labs(db - dc);
   \   00000294   0xEBB8 0x0009      SUBS     R0,R8,R9
   \   00000298   0xE006             B.N      ??_buffer_steps_20
    895            }
    896            //#else
    897            else
    898            {
    899              // default non-h-bot planning
    900              block->steps[X_AXIS] = labs(da);
    901              block->steps[Y_AXIS] = labs(db);
   \                     ??_buffer_steps_21: (+1)
   \   0000029A   0x4640             MOV      R0,R8
   \   0000029C   0x2800             CMP      R0,#+0
   \                     ??_buffer_steps_18: (+1)
   \   0000029E   0xBF48             IT       MI 
   \   000002A0   0x4240             RSBMI    R0,R0,#+0
   \   000002A2   0x60B8             STR      R0,[R7, #+8]
    902              block->steps[Z_AXIS] = labs(dc);
   \   000002A4   0x4648             MOV      R0,R9
   \   000002A6   0x2800             CMP      R0,#+0
   \                     ??_buffer_steps_20: (+1)
   \   000002A8   0xBF48             IT       MI 
   \   000002AA   0x4240             RSBMI    R0,R0,#+0
    903            }
   \   000002AC   0x60F8             STR      R0,[R7, #+12]
    904            //#endif
    905          
    906            block->steps[E_AXIS] = esteps;
   \   000002AE   0x9802             LDR      R0,[SP, #+8]
   \   000002B0   0x6138             STR      R0,[R7, #+16]
    907            block->step_event_count = MAX4(block->steps[X_AXIS], block->steps[Y_AXIS], block->steps[Z_AXIS], esteps);
   \   000002B2   0x68B9             LDR      R1,[R7, #+8]
   \   000002B4   0x6878             LDR      R0,[R7, #+4]
   \   000002B6   0x460A             MOV      R2,R1
   \   000002B8   0x4281             CMP      R1,R0
   \   000002BA   0xBFB8             IT       LT 
   \   000002BC   0x4602             MOVLT    R2,R0
   \   000002BE   0x68FB             LDR      R3,[R7, #+12]
   \   000002C0   0x461E             MOV      R6,R3
   \   000002C2   0x4293             CMP      R3,R2
   \   000002C4   0xBFB8             IT       LT 
   \   000002C6   0x4616             MOVLT    R6,R2
   \   000002C8   0x9D02             LDR      R5,[SP, #+8]
   \   000002CA   0x42B5             CMP      R5,R6
   \   000002CC   0xDA07             BGE.N    ??_buffer_steps_22
   \   000002CE   0x4293             CMP      R3,R2
   \   000002D0   0xDA03             BGE.N    ??_buffer_steps_23
   \   000002D2   0x4281             CMP      R1,R0
   \   000002D4   0xDB04             BLT.N    ??_buffer_steps_24
   \   000002D6   0x4608             MOV      R0,R1
   \   000002D8   0xE002             B.N      ??_buffer_steps_24
   \                     ??_buffer_steps_23: (+1)
   \   000002DA   0x4618             MOV      R0,R3
   \   000002DC   0xE000             B.N      ??_buffer_steps_24
   \                     ??_buffer_steps_22: (+1)
   \   000002DE   0x4628             MOV      R0,R5
   \                     ??_buffer_steps_24: (+1)
   \   000002E0   0x6178             STR      R0,[R7, #+20]
    908          
    909            // Bail if this is a zero-length block
    910            if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return;
   \   000002E2   0x2806             CMP      R0,#+6
   \   000002E4   0xF0C0 0x8566      BCC.W    ??_buffer_steps_25
    911          
    912            // For a mixing extruder, get a magnified step_event_count for each
    913            #if ENABLED(MIXING_EXTRUDER)
    914              for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
    915                block->mix_event_count[i] = mixing_factor[i] * block->step_event_count;
    916            #endif
    917          
    918            #if FAN_COUNT > 0
    919              for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
   \   000002E8   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000002EC   0x6800             LDR      R0,[R0, #+0]
   \   000002EE   0xF8A7 0x004C      STRH     R0,[R7, #+76]
    920            #endif
    921          
    922            #if ENABLED(BARICUDA)
    923              block->valve_pressure = baricuda_valve_pressure;
    924              block->e_to_p_pressure = baricuda_e_to_p_pressure;
    925            #endif
    926          
    927            block->active_extruder = extruder;
    928          
    929            //enable active axes
    930            #if 0
    931            #if CORE_IS_XY
    932              if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
    933                enable_X();
    934                enable_Y();
    935              }
    936              #if DISABLED(Z_LATE_ENABLE)
    937                if (block->steps[Z_AXIS]) enable_Z();
    938              #endif
    939            #elif CORE_IS_XZ
    940              if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
    941                enable_X();
    942                enable_Z();
    943              }
    944              if (block->steps[Y_AXIS]) enable_Y();
    945            #elif CORE_IS_YZ
    946              if (block->steps[B_AXIS] || block->steps[C_AXIS]) {
    947                enable_Y();
    948                enable_Z();
    949              }
    950              if (block->steps[X_AXIS]) enable_X();
    951            #else
    952              if (block->steps[X_AXIS]) enable_X();
    953              if (block->steps[Y_AXIS]) enable_Y();
    954              #if DISABLED(Z_LATE_ENABLE)
    955                if (block->steps[Z_AXIS]) enable_Z();
    956              #endif
    957            #endif
    958          #endif
    959            if(MACHINETPYE & CORE_IS_XY)
   \   000002F2   0x210C             MOVS     R1,#+12
   \   000002F4   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \   000002F8   0x7078             STRB     R0,[R7, #+1]
   \   000002FA   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \   000002FE   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   00000302   0x4208             TST      R0,R1
   \   00000304   0xD017             BEQ.N    ??_buffer_steps_26
    960           {
    961          	  if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
   \   00000306   0x6878             LDR      R0,[R7, #+4]
   \   00000308   0x2800             CMP      R0,#+0
   \   0000030A   0xBF04             ITT      EQ 
   \   0000030C   0x68B8             LDREQ    R0,[R7, #+8]
   \   0000030E   0x2800             CMPEQ    R0,#+0
   \   00000310   0xF000 0x8089      BEQ.W    ??_buffer_steps_27
    962          		enable_X();
   \   00000314   0x.... 0x....      LDR.W    R11,??DataTable14
   \   00000318   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   0000031C   0x.... 0x....      LDR.W    R5,??DataTable14_2
   \   00000320   0xF99B 0x2003      LDRSB    R2,[R11, #+3]
   \   00000324   0x88A9             LDRH     R1,[R5, #+4]
   \   00000326   0x68B0             LDR      R0,[R6, #+8]
   \   00000328   0x.... 0x....      BL       HAL_GPIO_WritePin
    963          		enable_Y();
   \   0000032C   0xF99B 0x2004      LDRSB    R2,[R11, #+4]
   \   00000330   0x89E9             LDRH     R1,[R5, #+14]
   \   00000332   0x69F0             LDR      R0,[R6, #+28]
   \   00000334   0xE075             B.N      ??_buffer_steps_28
    964          	  }
    965            	#if DISABLED(Z_LATE_ENABLE)
    966          		if (block->steps[Z_AXIS]) enable_Z();
    967            	#endif
    968            }
    969            else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_steps_26: (+1)
   \   00000336   0x2130             MOVS     R1,#+48
   \   00000338   0x4208             TST      R0,R1
   \   0000033A   0xD02A             BEQ.N    ??_buffer_steps_29
    970            	{
    971          	  if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
   \   0000033C   0x6878             LDR      R0,[R7, #+4]
   \   0000033E   0x2800             CMP      R0,#+0
   \   00000340   0xBF08             IT       EQ 
   \   00000342   0x2B00             CMPEQ    R3,#+0
   \   00000344   0xD017             BEQ.N    ??_buffer_steps_30
    972          		enable_X();
   \   00000346   0x.... 0x....      LDR.W    R11,??DataTable14
   \   0000034A   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   0000034E   0x.... 0x....      LDR.W    R5,??DataTable14_2
   \   00000352   0xF99B 0x2003      LDRSB    R2,[R11, #+3]
   \   00000356   0x88A9             LDRH     R1,[R5, #+4]
   \   00000358   0x68B0             LDR      R0,[R6, #+8]
   \   0000035A   0x.... 0x....      BL       HAL_GPIO_WritePin
    973          		enable_Z();
   \   0000035E   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   00000362   0x8B29             LDRH     R1,[R5, #+24]
   \   00000364   0x6B30             LDR      R0,[R6, #+48]
   \   00000366   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000036A   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   0000036E   0x8D29             LDRH     R1,[R5, #+40]
   \   00000370   0x6D30             LDR      R0,[R6, #+80]
   \   00000372   0x.... 0x....      BL       HAL_GPIO_WritePin
    974          	  }
    975          	  if (block->steps[Y_AXIS]) enable_Y();
   \                     ??_buffer_steps_30: (+1)
   \   00000376   0x68B8             LDR      R0,[R7, #+8]
   \   00000378   0x2800             CMP      R0,#+0
   \   0000037A   0xD068             BEQ.N    ??_buffer_steps_31
   \   0000037C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000380   0xF990 0x2004      LDRSB    R2,[R0, #+4]
   \   00000384   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000388   0x89C1             LDRH     R1,[R0, #+14]
   \   0000038A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000038E   0x69C0             LDR      R0,[R0, #+28]
   \   00000390   0xE05B             B.N      ??_buffer_steps_32
    976            	}
    977            else if(MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_steps_29: (+1)
   \   00000392   0x21C0             MOVS     R1,#+192
   \   00000394   0x4208             TST      R0,R1
   \   00000396   0xD02A             BEQ.N    ??_buffer_steps_33
    978            	{
    979          	  if (block->steps[B_AXIS] || block->steps[C_AXIS]) {
   \   00000398   0x68B8             LDR      R0,[R7, #+8]
   \   0000039A   0x2800             CMP      R0,#+0
   \   0000039C   0xBF08             IT       EQ 
   \   0000039E   0x2B00             CMPEQ    R3,#+0
   \   000003A0   0xD017             BEQ.N    ??_buffer_steps_34
    980          		enable_Y();
   \   000003A2   0x.... 0x....      LDR.W    R11,??DataTable14
   \   000003A6   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   000003AA   0x.... 0x....      LDR.W    R5,??DataTable14_2
   \   000003AE   0xF99B 0x2004      LDRSB    R2,[R11, #+4]
   \   000003B2   0x89E9             LDRH     R1,[R5, #+14]
   \   000003B4   0x69F0             LDR      R0,[R6, #+28]
   \   000003B6   0x.... 0x....      BL       HAL_GPIO_WritePin
    981          		enable_Z();
   \   000003BA   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   000003BE   0x8B29             LDRH     R1,[R5, #+24]
   \   000003C0   0x6B30             LDR      R0,[R6, #+48]
   \   000003C2   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000003C6   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   000003CA   0x8D29             LDRH     R1,[R5, #+40]
   \   000003CC   0x6D30             LDR      R0,[R6, #+80]
   \   000003CE   0x.... 0x....      BL       HAL_GPIO_WritePin
    982          	  }
    983          	  if (block->steps[X_AXIS]) enable_X();
   \                     ??_buffer_steps_34: (+1)
   \   000003D2   0x6878             LDR      R0,[R7, #+4]
   \   000003D4   0x2800             CMP      R0,#+0
   \   000003D6   0xD03A             BEQ.N    ??_buffer_steps_31
   \   000003D8   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000003DC   0xF990 0x2003      LDRSB    R2,[R0, #+3]
   \   000003E0   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000003E4   0x8881             LDRH     R1,[R0, #+4]
   \   000003E6   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   000003EA   0x6880             LDR      R0,[R0, #+8]
   \   000003EC   0xE02D             B.N      ??_buffer_steps_32
    984            	}
    985          	else
    986          	{
    987          		if (block->steps[X_AXIS]) enable_X();
   \                     ??_buffer_steps_33: (+1)
   \   000003EE   0x6878             LDR      R0,[R7, #+4]
   \   000003F0   0xB158             CBZ.N    R0,??_buffer_steps_35
   \   000003F2   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000003F6   0xF990 0x2003      LDRSB    R2,[R0, #+3]
   \   000003FA   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000003FE   0x8881             LDRH     R1,[R0, #+4]
   \   00000400   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000404   0x6880             LDR      R0,[R0, #+8]
   \   00000406   0x.... 0x....      BL       HAL_GPIO_WritePin
    988          		if (block->steps[Y_AXIS]) enable_Y();
   \                     ??_buffer_steps_35: (+1)
   \   0000040A   0x68B8             LDR      R0,[R7, #+8]
   \   0000040C   0xB158             CBZ.N    R0,??_buffer_steps_27
   \   0000040E   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000412   0xF990 0x2004      LDRSB    R2,[R0, #+4]
   \   00000416   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000041A   0x89C1             LDRH     R1,[R0, #+14]
   \   0000041C   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000420   0x69C0             LDR      R0,[R0, #+28]
   \                     ??_buffer_steps_28: (+1)
   \   00000422   0x.... 0x....      BL       HAL_GPIO_WritePin
    989          	  #if DISABLED(Z_LATE_ENABLE)
    990          		  if (block->steps[Z_AXIS]) enable_Z();
   \                     ??_buffer_steps_27: (+1)
   \   00000426   0x68F8             LDR      R0,[R7, #+12]
   \   00000428   0xB188             CBZ.N    R0,??_buffer_steps_31
   \   0000042A   0x.... 0x....      LDR.W    R11,??DataTable14
   \   0000042E   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   00000432   0x.... 0x....      LDR.W    R5,??DataTable14_2
   \   00000436   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   0000043A   0x8B29             LDRH     R1,[R5, #+24]
   \   0000043C   0x6B30             LDR      R0,[R6, #+48]
   \   0000043E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000442   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   00000446   0x8D29             LDRH     R1,[R5, #+40]
   \   00000448   0x6D30             LDR      R0,[R6, #+80]
   \                     ??_buffer_steps_32: (+1)
   \   0000044A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??_buffer_steps_31: (+1)
   \   0000044E   0x9802             LDR      R0,[SP, #+8]
   \   00000450   0x2800             CMP      R0,#+0
   \   00000452   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000456   0xD054             BEQ.N    ??_buffer_steps_36
    991          	  #endif
    992          	}
    993          
    994            // Enable extruder(s)
    995            if (esteps) {
    996          
    997              #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
    998          
    999                #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
   1000          
   1001                for (uint8_t i = 0; i < EXTRUDERS; i++)
   1002                  if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
   \   00000458   0x7800             LDRB     R0,[R0, #+0]
   \   0000045A   0xB118             CBZ.N    R0,??_buffer_steps_37
   \   0000045C   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000460   0x1E40             SUBS     R0,R0,#+1
   \   00000462   0x7008             STRB     R0,[R1, #+0]
   \                     ??_buffer_steps_37: (+1)
   \   00000464   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000468   0x7840             LDRB     R0,[R0, #+1]
   \   0000046A   0xB118             CBZ.N    R0,??_buffer_steps_38
   \   0000046C   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000470   0x1E40             SUBS     R0,R0,#+1
   \   00000472   0x7048             STRB     R0,[R1, #+1]
   1003          
   1004                switch(extruder) {
   \                     ??_buffer_steps_38: (+1)
   \   00000474   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \   00000478   0xB110             CBZ.N    R0,??_buffer_steps_39
   \   0000047A   0x2801             CMP      R0,#+1
   \   0000047C   0xD021             BEQ.N    ??_buffer_steps_40
   \   0000047E   0xE03C             B.N      ??_buffer_steps_41
   1005                  case 0:
   1006                    enable_E0();
   \                     ??_buffer_steps_39: (+1)
   \   00000480   0x.... 0x....      LDR.W    R11,??DataTable14
   \   00000484   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   00000488   0x.... 0x....      LDR.W    R5,??DataTable14_2
   \   0000048C   0xF99B 0x2006      LDRSB    R2,[R11, #+6]
   \   00000490   0x8C69             LDRH     R1,[R5, #+34]
   \   00000492   0x6C70             LDR      R0,[R6, #+68]
   \   00000494   0x.... 0x....      BL       HAL_GPIO_WritePin
   1007                    g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
   \   00000498   0x.... 0x....      LDR.W    R1,??DataTable18
   \   0000049C   0x2020             MOVS     R0,#+32
   \   0000049E   0x7008             STRB     R0,[R1, #+0]
   1008                    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   1009                      if (extruder_duplication_enabled) {
   1010                        enable_E1();
   1011                        g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
   1012                      }
   1013                    #endif
   1014                    #if EXTRUDERS > 1
   1015                      if(mksCfg.z2_enable != 1)
   \   000004A0   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \   000004A4   0xF890 0x0101      LDRB     R0,[R0, #+257]
   \   000004A8   0x2801             CMP      R0,#+1
   \   000004AA   0xD026             BEQ.N    ??_buffer_steps_41
   1016                          DISABLE_IDLE_E(1);
   \   000004AC   0x7848             LDRB     R0,[R1, #+1]
   \   000004AE   0xBB20             CBNZ.N   R0,??_buffer_steps_41
   \   000004B0   0xF89B 0x0006      LDRB     R0,[R11, #+6]
   \   000004B4   0x8D29             LDRH     R1,[R5, #+40]
   \   000004B6   0x1E42             SUBS     R2,R0,#+1
   \   000004B8   0x4192             SBCS     R2,R2,R2
   \   000004BA   0x0FD2             LSRS     R2,R2,#+31
   \   000004BC   0x6D30             LDR      R0,[R6, #+80]
   \   000004BE   0xB252             SXTB     R2,R2
   \   000004C0   0xE019             B.N      ??_buffer_steps_42
   1017                      #if EXTRUDERS > 2
   1018                        DISABLE_IDLE_E(2);
   1019                        #if EXTRUDERS > 3
   1020                          DISABLE_IDLE_E(3);
   1021                          #if EXTRUDERS > 4
   1022                            DISABLE_IDLE_E(4);
   1023                          #endif // EXTRUDERS > 4
   1024                        #endif // EXTRUDERS > 3
   1025                      #endif // EXTRUDERS > 2
   1026                    #endif // EXTRUDERS > 1
   1027                  break;
   1028                  #if EXTRUDERS > 1
   1029                    case 1:
   1030                      enable_E1();
   \                     ??_buffer_steps_40: (+1)
   \   000004C2   0x.... 0x....      LDR.W    R11,??DataTable14
   \   000004C6   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   000004CA   0x.... 0x....      LDR.W    R5,??DataTable14_2
   \   000004CE   0xF99B 0x2006      LDRSB    R2,[R11, #+6]
   \   000004D2   0x8D29             LDRH     R1,[R5, #+40]
   \   000004D4   0x6D30             LDR      R0,[R6, #+80]
   \   000004D6   0x.... 0x....      BL       HAL_GPIO_WritePin
   1031                      g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
   \   000004DA   0x.... 0x....      LDR.W    R1,??DataTable18
   \   000004DE   0x2020             MOVS     R0,#+32
   \   000004E0   0x7048             STRB     R0,[R1, #+1]
   1032                      DISABLE_IDLE_E(0);
   \   000004E2   0x7808             LDRB     R0,[R1, #+0]
   \   000004E4   0xB948             CBNZ.N   R0,??_buffer_steps_41
   \   000004E6   0xF89B 0x0006      LDRB     R0,[R11, #+6]
   \   000004EA   0x8C69             LDRH     R1,[R5, #+34]
   \   000004EC   0x1E42             SUBS     R2,R0,#+1
   \   000004EE   0x4192             SBCS     R2,R2,R2
   \   000004F0   0x0FD2             LSRS     R2,R2,#+31
   \   000004F2   0x6C70             LDR      R0,[R6, #+68]
   \   000004F4   0xB252             SXTB     R2,R2
   \                     ??_buffer_steps_42: (+1)
   \   000004F6   0x.... 0x....      BL       HAL_GPIO_WritePin
   1033                      #if EXTRUDERS > 2
   1034                        DISABLE_IDLE_E(2);
   1035                        #if EXTRUDERS > 3
   1036                          DISABLE_IDLE_E(3);
   1037                          #if EXTRUDERS > 4
   1038                            DISABLE_IDLE_E(4);
   1039                          #endif // EXTRUDERS > 4
   1040                        #endif // EXTRUDERS > 3
   1041                      #endif // EXTRUDERS > 2
   1042                    break;
   1043                    #if EXTRUDERS > 2
   1044                      case 2:
   1045                        enable_E2();
   1046                        g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
   1047                        DISABLE_IDLE_E(0);
   1048                        DISABLE_IDLE_E(1);
   1049                        #if EXTRUDERS > 3
   1050                          DISABLE_IDLE_E(3);
   1051                          #if EXTRUDERS > 4
   1052                            DISABLE_IDLE_E(4);
   1053                          #endif
   1054                        #endif
   1055                      break;
   1056                      #if EXTRUDERS > 3
   1057                        case 3:
   1058                          enable_E3();
   1059                          g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
   1060                          DISABLE_IDLE_E(0);
   1061                          DISABLE_IDLE_E(1);
   1062                          DISABLE_IDLE_E(2);
   1063                          #if EXTRUDERS > 4
   1064                            DISABLE_IDLE_E(4);
   1065                          #endif
   1066                        break;
   1067                        #if EXTRUDERS > 4
   1068                          case 4:
   1069                            enable_E4();
   1070                            g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
   1071                            DISABLE_IDLE_E(0);
   1072                            DISABLE_IDLE_E(1);
   1073                            DISABLE_IDLE_E(2);
   1074                            DISABLE_IDLE_E(3);
   1075                          break;
   1076                        #endif // EXTRUDERS > 4
   1077                      #endif // EXTRUDERS > 3
   1078                    #endif // EXTRUDERS > 2
   1079                  #endif // EXTRUDERS > 1
   1080                }
   1081              #else
   1082                enable_E0();
   1083                enable_E1();
   1084                enable_E2();
   1085                enable_E3();
   1086                enable_E4();
   1087              #endif
   1088            }
   1089          
   1090            if (esteps)
   1091              NOLESS(fr_mm_s, min_feedrate_mm_s);
   \                     ??_buffer_steps_41: (+1)
   \   000004FA   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000004FE   0x69C1             LDR      R1,[R0, #+28]
   \   00000500   0xE000             B.N      ??_buffer_steps_43
   1092            else
   1093              NOLESS(fr_mm_s, min_travel_feedrate_mm_s);
   \                     ??_buffer_steps_36: (+1)
   \   00000502   0x6BC1             LDR      R1,[R0, #+60]
   \                     ??_buffer_steps_43: (+1)
   \   00000504   0x9813             LDR      R0,[SP, #+76]
   \   00000506   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000050A   0xBF38             IT       CC 
   \   0000050C   0x9113             STRCC    R1,[SP, #+76]
   1094          
   1095            /**
   1096             * This part of the code calculates the total length of the movement.
   1097             * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
   1098             * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
   1099             * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
   1100             * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
   1101             * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
   1102             */
   1103            //#if IS_CORE
   1104              float delta_mm[Z_HEAD + 1];
   1105            if(MACHINETPYE & IS_CORE) {
   \   0000050E   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \   00000512   0xF9B0 0x5058      LDRSH    R5,[R0, #+88]
   \   00000516   0x21FC             MOVS     R1,#+252
   \   00000518   0xAE0B             ADD      R6,SP,#+44
   \   0000051A   0x420D             TST      R5,R1
   \   0000051C   0xF000 0x8085      BEQ.W    ??_buffer_steps_44
   1106              //#if CORE_IS_XY
   1107              if(MACHINETPYE & CORE_IS_XY) {
   \   00000520   0x210C             MOVS     R1,#+12
   \   00000522   0x420D             TST      R5,R1
   \   00000524   0xD029             BEQ.N    ??_buffer_steps_45
   \   00000526   0x4650             MOV      R0,R10
   \   00000528   0x.... 0x....      BL       __aeabi_i2f
   \   0000052C   0x69A1             LDR      R1,[R4, #+24]
   \   0000052E   0x.... 0x....      BL       __aeabi_fmul
   \   00000532   0x6130             STR      R0,[R6, #+16]
   \   00000534   0x4640             MOV      R0,R8
   \   00000536   0x.... 0x....      BL       __aeabi_i2f
   \   0000053A   0x69E1             LDR      R1,[R4, #+28]
   \   0000053C   0x.... 0x....      BL       __aeabi_fmul
   \   00000540   0x6170             STR      R0,[R6, #+20]
   1108                delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
   1109                delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
   1110                delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
   \   00000542   0x4648             MOV      R0,R9
   \   00000544   0x.... 0x....      BL       __aeabi_i2f
   \   00000548   0x6A21             LDR      R1,[R4, #+32]
   \   0000054A   0x.... 0x....      BL       __aeabi_fmul
   \   0000054E   0x60B0             STR      R0,[R6, #+8]
   1111                delta_mm[A_AXIS] = (da + db) * steps_to_mm[A_AXIS];
   \   00000550   0xEB08 0x000A      ADD      R0,R8,R10
   \   00000554   0x.... 0x....      BL       __aeabi_i2f
   \   00000558   0x69A1             LDR      R1,[R4, #+24]
   \   0000055A   0x.... 0x....      BL       __aeabi_fmul
   \   0000055E   0x900B             STR      R0,[SP, #+44]
   1112                delta_mm[B_AXIS] = CORESIGN(da - db) * steps_to_mm[B_AXIS];}
   \   00000560   0x21A8             MOVS     R1,#+168
   \   00000562   0xEBAA 0x0008      SUB      R0,R10,R8
   \   00000566   0x420D             TST      R5,R1
   \   00000568   0xBF18             IT       NE 
   \   0000056A   0x4240             RSBNE    R0,R0,#+0
   \   0000056C   0x.... 0x....      BL       __aeabi_i2f
   \   00000570   0x69E1             LDR      R1,[R4, #+28]
   \   00000572   0x.... 0x....      BL       __aeabi_fmul
   \   00000576   0x6070             STR      R0,[R6, #+4]
   \   00000578   0xE06C             B.N      ??_buffer_steps_46
   1113             // #elif CORE_IS_XZ
   1114             else if(MACHINETPYE & CORE_IS_XZ) {
   \                     ??_buffer_steps_45: (+1)
   \   0000057A   0x2130             MOVS     R1,#+48
   \   0000057C   0x420D             TST      R5,R1
   \   0000057E   0xD028             BEQ.N    ??_buffer_steps_47
   \   00000580   0x4650             MOV      R0,R10
   \   00000582   0x.... 0x....      BL       __aeabi_i2f
   \   00000586   0x69A1             LDR      R1,[R4, #+24]
   \   00000588   0x.... 0x....      BL       __aeabi_fmul
   \   0000058C   0x6130             STR      R0,[R6, #+16]
   1115                delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
   1116                delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
   \   0000058E   0x4640             MOV      R0,R8
   \   00000590   0x.... 0x....      BL       __aeabi_i2f
   \   00000594   0x69E1             LDR      R1,[R4, #+28]
   \   00000596   0x.... 0x....      BL       __aeabi_fmul
   \   0000059A   0x6070             STR      R0,[R6, #+4]
   1117                delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
   \   0000059C   0x4648             MOV      R0,R9
   \   0000059E   0xF8D4 0xB020      LDR      R11,[R4, #+32]
   \   000005A2   0x.... 0x....      BL       __aeabi_i2f
   \   000005A6   0x4659             MOV      R1,R11
   \   000005A8   0x.... 0x....      BL       __aeabi_fmul
   \   000005AC   0x61B0             STR      R0,[R6, #+24]
   1118                delta_mm[A_AXIS] = (da + dc) * steps_to_mm[A_AXIS];
   \   000005AE   0xEB09 0x000A      ADD      R0,R9,R10
   \   000005B2   0x.... 0x....      BL       __aeabi_i2f
   \   000005B6   0x69A1             LDR      R1,[R4, #+24]
   \   000005B8   0x.... 0x....      BL       __aeabi_fmul
   \   000005BC   0x900B             STR      R0,[SP, #+44]
   1119                delta_mm[C_AXIS] = CORESIGN(da - dc) * steps_to_mm[C_AXIS];}
   \   000005BE   0x21A8             MOVS     R1,#+168
   \   000005C0   0xEBAA 0x0009      SUB      R0,R10,R9
   \   000005C4   0x420D             TST      R5,R1
   \   000005C6   0xBF18             IT       NE 
   \   000005C8   0x4240             RSBNE    R0,R0,#+0
   \   000005CA   0x.... 0x....      BL       __aeabi_i2f
   \   000005CE   0x4659             MOV      R1,R11
   \   000005D0   0xE03D             B.N      ??_buffer_steps_48
   1120              //#elif CORE_IS_YZ
   1121              else if(MACHINETPYE & CORE_IS_YZ) {
   \                     ??_buffer_steps_47: (+1)
   \   000005D2   0x21C0             MOVS     R1,#+192
   \   000005D4   0x420D             TST      R5,R1
   \   000005D6   0xD03D             BEQ.N    ??_buffer_steps_46
   1122                delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
   \   000005D8   0x4650             MOV      R0,R10
   \   000005DA   0x.... 0x....      BL       __aeabi_i2f
   \   000005DE   0x69A1             LDR      R1,[R4, #+24]
   \   000005E0   0x.... 0x....      BL       __aeabi_fmul
   \   000005E4   0x900B             STR      R0,[SP, #+44]
   \   000005E6   0x4640             MOV      R0,R8
   \   000005E8   0x.... 0x....      BL       __aeabi_i2f
   \   000005EC   0x69E1             LDR      R1,[R4, #+28]
   \   000005EE   0x.... 0x....      BL       __aeabi_fmul
   \   000005F2   0x6170             STR      R0,[R6, #+20]
   1123                delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
   1124                delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
   \   000005F4   0x4648             MOV      R0,R9
   \   000005F6   0xF8D4 0xA020      LDR      R10,[R4, #+32]
   \   000005FA   0x.... 0x....      BL       __aeabi_i2f
   \   000005FE   0x4651             MOV      R1,R10
   \   00000600   0x.... 0x....      BL       __aeabi_fmul
   \   00000604   0x61B0             STR      R0,[R6, #+24]
   1125                delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
   \   00000606   0xEB09 0x0008      ADD      R0,R9,R8
   \   0000060A   0x.... 0x....      BL       __aeabi_i2f
   \   0000060E   0x69E1             LDR      R1,[R4, #+28]
   \   00000610   0x.... 0x....      BL       __aeabi_fmul
   \   00000614   0x6070             STR      R0,[R6, #+4]
   1126                delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS];}
   \   00000616   0x21A8             MOVS     R1,#+168
   \   00000618   0xEBA8 0x0009      SUB      R0,R8,R9
   \   0000061C   0x420D             TST      R5,R1
   \   0000061E   0xBF18             IT       NE 
   \   00000620   0x4240             RSBNE    R0,R0,#+0
   1127              //#endif
   1128            	}
   \   00000622   0x.... 0x....      BL       __aeabi_i2f
   \   00000626   0x4651             MOV      R1,R10
   \   00000628   0xE011             B.N      ??_buffer_steps_48
   1129            //#else
   1130            else
   1131            {
   1132              //float delta_mm[XYZE];
   1133              delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
   \                     ??_buffer_steps_44: (+1)
   \   0000062A   0x4650             MOV      R0,R10
   \   0000062C   0x.... 0x....      BL       __aeabi_i2f
   \   00000630   0x69A1             LDR      R1,[R4, #+24]
   \   00000632   0x.... 0x....      BL       __aeabi_fmul
   \   00000636   0x900B             STR      R0,[SP, #+44]
   1134              delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
   \   00000638   0x4640             MOV      R0,R8
   \   0000063A   0x.... 0x....      BL       __aeabi_i2f
   \   0000063E   0x69E1             LDR      R1,[R4, #+28]
   \   00000640   0x.... 0x....      BL       __aeabi_fmul
   \   00000644   0x6070             STR      R0,[R6, #+4]
   1135              delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
   \   00000646   0x4648             MOV      R0,R9
   \   00000648   0x.... 0x....      BL       __aeabi_i2f
   \   0000064C   0x6A21             LDR      R1,[R4, #+32]
   \                     ??_buffer_steps_48: (+1)
   \   0000064E   0x.... 0x....      BL       __aeabi_fmul
   \   00000652   0x60B0             STR      R0,[R6, #+8]
   1136            }
   1137            //#endif
   1138            delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N];
   \                     ??_buffer_steps_46: (+1)
   \   00000654   0x9801             LDR      R0,[SP, #+4]
   \   00000656   0x9900             LDR      R1,[SP, #+0]
   \   00000658   0x6A40             LDR      R0,[R0, #+36]
   \   0000065A   0x.... 0x....      BL       __aeabi_fmul
   \   0000065E   0x60F0             STR      R0,[R6, #+12]
   1139          
   1140            if (block->steps[X_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Y_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Z_AXIS] < MIN_STEPS_PER_SEGMENT) {
   \   00000660   0x6879             LDR      R1,[R7, #+4]
   \   00000662   0x2906             CMP      R1,#+6
   \   00000664   0xBFBC             ITT      LT 
   \   00000666   0x68B9             LDRLT    R1,[R7, #+8]
   \   00000668   0x2906             CMPLT    R1,#+6
   \   0000066A   0xDA06             BGE.N    ??_buffer_steps_49
   \   0000066C   0x68F9             LDR      R1,[R7, #+12]
   \   0000066E   0x2906             CMP      R1,#+6
   \   00000670   0xBFB8             IT       LT 
   1141              block->millimeters = FABS(delta_mm[E_AXIS]);
   \   00000672   0xF020 0x4000      BICLT    R0,R0,#0x80000000
   \   00000676   0xF2C0 0x80B2      BLT.W    ??_buffer_steps_50
   1142            }
   1143            else {
   1144            	/*
   1145              block->millimeters = SQRT(
   1146                #if CORE_IS_XY
   1147                  sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
   1148                #elif CORE_IS_XZ
   1149                  sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
   1150                #elif CORE_IS_YZ
   1151                  sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
   1152                #else
   1153                  sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
   1154                #endif
   1155              );
   1156              */
   1157          		if(MACHINETPYE & CORE_IS_XY)
   \                     ??_buffer_steps_49: (+1)
   \   0000067A   0x200C             MOVS     R0,#+12
   \   0000067C   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   00000680   0x4205             TST      R5,R0
   \   00000682   0xD015             BEQ.N    ??_buffer_steps_51
   1158          			block->millimeters = sqrt(sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS]));
   \   00000684   0xF8D6 0x9010      LDR      R9,[R6, #+16]
   \   00000688   0x2502             MOVS     R5,#+2
   \   0000068A   0x46D0             MOV      R8,R10
   \   0000068C   0xE004             B.N      ??_buffer_steps_52
   \                     ??_buffer_steps_53: (+1)
   \   0000068E   0x4648             MOV      R0,R9
   \   00000690   0x4649             MOV      R1,R9
   \   00000692   0x.... 0x....      BL       __aeabi_fmul
   \   00000696   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_52: (+1)
   \   00000698   0x07E8             LSLS     R0,R5,#+31
   \   0000069A   0xD504             BPL.N    ??_buffer_steps_54
   \   0000069C   0x4640             MOV      R0,R8
   \   0000069E   0x4649             MOV      R1,R9
   \   000006A0   0x.... 0x....      BL       __aeabi_fmul
   \   000006A4   0x4680             MOV      R8,R0
   \                     ??_buffer_steps_54: (+1)
   \   000006A6   0x086D             LSRS     R5,R5,#+1
   \   000006A8   0xD1F1             BNE.N    ??_buffer_steps_53
   \   000006AA   0xF8D6 0xB014      LDR      R11,[R6, #+20]
   \   000006AE   0xE068             B.N      ??_buffer_steps_55
   1159          		else if (MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_steps_51: (+1)
   \   000006B0   0x2030             MOVS     R0,#+48
   \   000006B2   0x4205             TST      R5,R0
   \   000006B4   0xD027             BEQ.N    ??_buffer_steps_56
   1160          			block->millimeters = sqrt(sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD]));
   \   000006B6   0xF8D6 0x9010      LDR      R9,[R6, #+16]
   \   000006BA   0x2502             MOVS     R5,#+2
   \   000006BC   0x46D0             MOV      R8,R10
   \   000006BE   0xE004             B.N      ??_buffer_steps_57
   \                     ??_buffer_steps_58: (+1)
   \   000006C0   0x4648             MOV      R0,R9
   \   000006C2   0x4649             MOV      R1,R9
   \   000006C4   0x.... 0x....      BL       __aeabi_fmul
   \   000006C8   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_57: (+1)
   \   000006CA   0x07E8             LSLS     R0,R5,#+31
   \   000006CC   0xD504             BPL.N    ??_buffer_steps_59
   \   000006CE   0x4640             MOV      R0,R8
   \   000006D0   0x4649             MOV      R1,R9
   \   000006D2   0x.... 0x....      BL       __aeabi_fmul
   \   000006D6   0x4680             MOV      R8,R0
   \                     ??_buffer_steps_59: (+1)
   \   000006D8   0x086D             LSRS     R5,R5,#+1
   \   000006DA   0xD1F1             BNE.N    ??_buffer_steps_58
   \   000006DC   0xF8D6 0xB004      LDR      R11,[R6, #+4]
   \   000006E0   0x2502             MOVS     R5,#+2
   \   000006E2   0x46D1             MOV      R9,R10
   \   000006E4   0xE004             B.N      ??_buffer_steps_60
   \                     ??_buffer_steps_61: (+1)
   \   000006E6   0x4658             MOV      R0,R11
   \   000006E8   0x4659             MOV      R1,R11
   \   000006EA   0x.... 0x....      BL       __aeabi_fmul
   \   000006EE   0x4683             MOV      R11,R0
   \                     ??_buffer_steps_60: (+1)
   \   000006F0   0x07E8             LSLS     R0,R5,#+31
   \   000006F2   0xD504             BPL.N    ??_buffer_steps_62
   \   000006F4   0x4648             MOV      R0,R9
   \   000006F6   0x4659             MOV      R1,R11
   \   000006F8   0x.... 0x....      BL       __aeabi_fmul
   \   000006FC   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_62: (+1)
   \   000006FE   0x086D             LSRS     R5,R5,#+1
   \   00000700   0xD1F1             BNE.N    ??_buffer_steps_61
   \   00000702   0x69B5             LDR      R5,[R6, #+24]
   \   00000704   0xE04F             B.N      ??_buffer_steps_63
   1161          		else if (MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_steps_56: (+1)
   \   00000706   0x20C0             MOVS     R0,#+192
   \   00000708   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   \   0000070C   0x4205             TST      R5,R0
   \   0000070E   0xD025             BEQ.N    ??_buffer_steps_64
   1162          			block->millimeters = sqrt(sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD]));
   \   00000710   0x2502             MOVS     R5,#+2
   \   00000712   0x46D0             MOV      R8,R10
   \   00000714   0xE004             B.N      ??_buffer_steps_65
   \                     ??_buffer_steps_66: (+1)
   \   00000716   0x4648             MOV      R0,R9
   \   00000718   0x4649             MOV      R1,R9
   \   0000071A   0x.... 0x....      BL       __aeabi_fmul
   \   0000071E   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_65: (+1)
   \   00000720   0x07E8             LSLS     R0,R5,#+31
   \   00000722   0xD504             BPL.N    ??_buffer_steps_67
   \   00000724   0x4640             MOV      R0,R8
   \   00000726   0x4649             MOV      R1,R9
   \   00000728   0x.... 0x....      BL       __aeabi_fmul
   \   0000072C   0x4680             MOV      R8,R0
   \                     ??_buffer_steps_67: (+1)
   \   0000072E   0x086D             LSRS     R5,R5,#+1
   \   00000730   0xD1F1             BNE.N    ??_buffer_steps_66
   \   00000732   0xF8D6 0xB014      LDR      R11,[R6, #+20]
   \   00000736   0x2502             MOVS     R5,#+2
   \   00000738   0x46D1             MOV      R9,R10
   \   0000073A   0xE004             B.N      ??_buffer_steps_68
   \                     ??_buffer_steps_69: (+1)
   \   0000073C   0x4658             MOV      R0,R11
   \   0000073E   0x4659             MOV      R1,R11
   \   00000740   0x.... 0x....      BL       __aeabi_fmul
   \   00000744   0x4683             MOV      R11,R0
   \                     ??_buffer_steps_68: (+1)
   \   00000746   0x07E8             LSLS     R0,R5,#+31
   \   00000748   0xD504             BPL.N    ??_buffer_steps_70
   \   0000074A   0x4648             MOV      R0,R9
   \   0000074C   0x4659             MOV      R1,R11
   \   0000074E   0x.... 0x....      BL       __aeabi_fmul
   \   00000752   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_70: (+1)
   \   00000754   0x086D             LSRS     R5,R5,#+1
   \   00000756   0xD1F1             BNE.N    ??_buffer_steps_69
   \   00000758   0x69B5             LDR      R5,[R6, #+24]
   \   0000075A   0xE024             B.N      ??_buffer_steps_63
   1163          		else	
   1164          			block->millimeters = sqrt(sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS]));
   \                     ??_buffer_steps_64: (+1)
   \   0000075C   0x2502             MOVS     R5,#+2
   \   0000075E   0x46D0             MOV      R8,R10
   \   00000760   0xE004             B.N      ??_buffer_steps_71
   \                     ??_buffer_steps_72: (+1)
   \   00000762   0x4648             MOV      R0,R9
   \   00000764   0x4649             MOV      R1,R9
   \   00000766   0x.... 0x....      BL       __aeabi_fmul
   \   0000076A   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_71: (+1)
   \   0000076C   0x07E8             LSLS     R0,R5,#+31
   \   0000076E   0xD504             BPL.N    ??_buffer_steps_73
   \   00000770   0x4640             MOV      R0,R8
   \   00000772   0x4649             MOV      R1,R9
   \   00000774   0x.... 0x....      BL       __aeabi_fmul
   \   00000778   0x4680             MOV      R8,R0
   \                     ??_buffer_steps_73: (+1)
   \   0000077A   0x086D             LSRS     R5,R5,#+1
   \   0000077C   0xD1F1             BNE.N    ??_buffer_steps_72
   \   0000077E   0xF8D6 0xB004      LDR      R11,[R6, #+4]
   \                     ??_buffer_steps_55: (+1)
   \   00000782   0x2502             MOVS     R5,#+2
   \   00000784   0x46D1             MOV      R9,R10
   \   00000786   0xE004             B.N      ??_buffer_steps_74
   \                     ??_buffer_steps_75: (+1)
   \   00000788   0x4658             MOV      R0,R11
   \   0000078A   0x4659             MOV      R1,R11
   \   0000078C   0x.... 0x....      BL       __aeabi_fmul
   \   00000790   0x4683             MOV      R11,R0
   \                     ??_buffer_steps_74: (+1)
   \   00000792   0x07E8             LSLS     R0,R5,#+31
   \   00000794   0xD504             BPL.N    ??_buffer_steps_76
   \   00000796   0x4648             MOV      R0,R9
   \   00000798   0x4659             MOV      R1,R11
   \   0000079A   0x.... 0x....      BL       __aeabi_fmul
   \   0000079E   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_76: (+1)
   \   000007A0   0x086D             LSRS     R5,R5,#+1
   \   000007A2   0xD1F1             BNE.N    ??_buffer_steps_75
   \   000007A4   0x68B5             LDR      R5,[R6, #+8]
   \                     ??_buffer_steps_63: (+1)
   \   000007A6   0xF04F 0x0B02      MOV      R11,#+2
   \   000007AA   0xE004             B.N      ??_buffer_steps_77
   \                     ??_buffer_steps_78: (+1)
   \   000007AC   0x4628             MOV      R0,R5
   \   000007AE   0x4629             MOV      R1,R5
   \   000007B0   0x.... 0x....      BL       __aeabi_fmul
   \   000007B4   0x4605             MOV      R5,R0
   \                     ??_buffer_steps_77: (+1)
   \   000007B6   0xEA5F 0x70CB      LSLS     R0,R11,#+31
   \   000007BA   0xD504             BPL.N    ??_buffer_steps_79
   \   000007BC   0x4650             MOV      R0,R10
   \   000007BE   0x4629             MOV      R1,R5
   \   000007C0   0x.... 0x....      BL       __aeabi_fmul
   \   000007C4   0x4682             MOV      R10,R0
   \                     ??_buffer_steps_79: (+1)
   \   000007C6   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   \   000007CA   0xD1EF             BNE.N    ??_buffer_steps_78
   1165          			
   1166              
   1167            }
   \   000007CC   0x4640             MOV      R0,R8
   \   000007CE   0x4649             MOV      R1,R9
   \   000007D0   0x.... 0x....      BL       __aeabi_fadd
   \   000007D4   0x4651             MOV      R1,R10
   \   000007D6   0x.... 0x....      BL       __aeabi_fadd
   \   000007DA   0x.... 0x....      BL       sqrtf
   \                     ??_buffer_steps_50: (+1)
   \   000007DE   0x6378             STR      R0,[R7, #+52]
   1168            const float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
   \   000007E0   0xF04F 0x507E      MOV      R0,#+1065353216
   \   000007E4   0x6B79             LDR      R1,[R7, #+52]
   \   000007E6   0x.... 0x....      BL       __aeabi_fdiv
   1169          
   1170            // Calculate inverse time for this move. No divide by zero due to previous checks.
   1171            // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   1172            float inverse_secs = fr_mm_s * inverse_millimeters;
   \   000007EA   0x9913             LDR      R1,[SP, #+76]
   \   000007EC   0x9000             STR      R0,[SP, #+0]
   \   000007EE   0x.... 0x....      BL       __aeabi_fmul
   \   000007F2   0x4680             MOV      R8,R0
   1173          
   1174            const uint8_t moves_queued = movesplanned();
   \   000007F4   0x7820             LDRB     R0,[R4, #+0]
   \   000007F6   0x7861             LDRB     R1,[R4, #+1]
   \   000007F8   0x1A40             SUBS     R0,R0,R1
   \   000007FA   0xF000 0x000F      AND      R0,R0,#0xF
   \   000007FE   0x9003             STR      R0,[SP, #+12]
   1175          
   1176            // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   1177            //#if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
   1178              // Segment time im micro seconds
   1179              uint32_t segment_time_us = LROUND(1000000.0 / inverse_secs);
   \   00000800   0x4640             MOV      R0,R8
   \   00000802   0x.... 0x....      BL       __aeabi_f2d
   \   00000806   0x4602             MOV      R2,R0
   \   00000808   0x460B             MOV      R3,R1
   \   0000080A   0x2000             MOVS     R0,#+0
   \   0000080C   0x.... 0x....      LDR.W    R1,??DataTable18_1  ;; 0x412e8480
   \   00000810   0x.... 0x....      BL       __aeabi_ddiv
   \   00000814   0x.... 0x....      BL       lround
   \   00000818   0x4605             MOV      R5,R0
   1180            //#endif
   1181          
   1182            //#if ENABLED(SLOWDOWN)
   1183            if(!(MACHINETPYE & IS_KINEMATIC))
   \   0000081A   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \   0000081E   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000822   0xF240 0x3102      MOVW     R1,#+770
   \   00000826   0x4208             TST      R0,R1
   \   00000828   0xD11E             BNE.N    ??_buffer_steps_80
   1184            { 
   1185              if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
   \   0000082A   0x9803             LDR      R0,[SP, #+12]
   \   0000082C   0x1E80             SUBS     R0,R0,#+2
   \   0000082E   0x2806             CMP      R0,#+6
   \   00000830   0xBF3E             ITTT     CC 
   1186                if (segment_time_us < min_segment_time_us) {
   \   00000832   0x.... 0x....      LDRCC.W  R0,??DataTable18
   \   00000836   0x6980             LDRCC    R0,[R0, #+24]
   \   00000838   0x4285             CMPCC    R5,R0
   \   0000083A   0xD215             BCS.N    ??_buffer_steps_80
   1187                  // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
   1188                  const uint32_t nst = segment_time_us + LROUND((double)(2 * (min_segment_time_us - segment_time_us) / moves_queued));
   1189                  inverse_secs = 1000000.0 / nst;
   \   0000083C   0x1B40             SUBS     R0,R0,R5
   \   0000083E   0x9903             LDR      R1,[SP, #+12]
   \   00000840   0x0040             LSLS     R0,R0,#+1
   \   00000842   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000846   0x.... 0x....      BL       __aeabi_ui2d
   \   0000084A   0x.... 0x....      BL       lround
   \   0000084E   0x4428             ADD      R0,R0,R5
   \   00000850   0x.... 0x....      BL       __aeabi_ui2d
   \   00000854   0x4602             MOV      R2,R0
   \   00000856   0x460B             MOV      R3,R1
   \   00000858   0x2000             MOVS     R0,#+0
   \   0000085A   0x.... 0x....      LDR.W    R1,??DataTable18_1  ;; 0x412e8480
   \   0000085E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000862   0x.... 0x....      BL       __aeabi_d2f
   \   00000866   0x4680             MOV      R8,R0
   1190                  #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
   1191                    segment_time_us = nst;
   1192                  #endif
   1193                }
   1194              }
   1195             }
   1196            //#endif
   1197          
   1198            #if ENABLED(ULTRA_LCD)
   1199              CRITICAL_SECTION_START
   1200                block_buffer_runtime_us += segment_time_us;
   1201              CRITICAL_SECTION_END
   1202            #endif
   1203          
   1204            block->nominal_speed = block->millimeters * inverse_secs;           //   (mm/sec) Always > 0
   \                     ??_buffer_steps_80: (+1)
   \   00000868   0x6B78             LDR      R0,[R7, #+52]
   \   0000086A   0x4641             MOV      R1,R8
   \   0000086C   0x.... 0x....      BL       __aeabi_fmul
   \   00000870   0x62B8             STR      R0,[R7, #+40]
   1205            block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
                                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000872   0x6978             LDR      R0,[R7, #+20]
   \   00000874   0x.... 0x....      BL       __aeabi_ui2f
   \   00000878   0x4641             MOV      R1,R8
   \   0000087A   0x.... 0x....      BL       __aeabi_fmul
   \   0000087E   0x.... 0x....      BL       ceilf
   \   00000882   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000886   0x63F8             STR      R0,[R7, #+60]
   1206          
   1207            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1208              static float filwidth_e_count = 0, filwidth_delay_dist = 0;
   1209          
   1210              //FMM update ring buffer used for delay with filament measurements
   1211              if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
   1212          
   1213                constexpr int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
   1214          
   1215                // increment counters with next move in e axis
   1216                filwidth_e_count += delta_mm[E_AXIS];
   1217                filwidth_delay_dist += delta_mm[E_AXIS];
   1218          
   1219                // Only get new measurements on forward E movement
   1220                if (!UNEAR_ZERO(filwidth_e_count)) {
   1221          
   1222                  // Loop the delay distance counter (modulus by the mm length)
   1223                  while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
   1224          
   1225                  // Convert into an index into the measurement array
   1226                  filwidth_delay_index[0] = int8_t(filwidth_delay_dist * 0.1);
   1227          
   1228                  // If the index has changed (must have gone forward)...
   1229                  if (filwidth_delay_index[0] != filwidth_delay_index[1]) {
   1230                    filwidth_e_count = 0; // Reset the E movement counter
   1231                    const int8_t meas_sample = thermalManager.widthFil_to_size_ratio();
   1232                    do {
   1233                      filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
   1234                      measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
   1235                    } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
   1236                  }
   1237                }
   1238              }
   1239            #endif
   1240          
   1241            // Calculate and limit speed in mm/sec for each axis
   1242            float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
   \   00000888   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   0000088C   0x46D1             MOV      R9,R10
   1243            LOOP_XYZE(i) {
   \   0000088E   0xF04F 0x0B00      MOV      R11,#+0
   \   00000892   0xAD07             ADD      R5,SP,#+28
   1244              const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_secs));
   \                     ??_buffer_steps_81: (+1)
   \   00000894   0xF856 0x002B      LDR      R0,[R6, R11, LSL #+2]
   \   00000898   0x4641             MOV      R1,R8
   \   0000089A   0x.... 0x....      BL       __aeabi_fmul
   \   0000089E   0xF845 0x002B      STR      R0,[R5, R11, LSL #+2]
   \   000008A2   0xF020 0x4100      BIC      R1,R0,#0x80000000
   1245              #if ENABLED(DISTINCT_E_FACTORS)
   1246                if (i == E_AXIS) i += extruder;
   \   000008A6   0xF1BB 0x0F03      CMP      R11,#+3
   \   000008AA   0xD104             BNE.N    ??_buffer_steps_82
   \   000008AC   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \   000008B0   0x4458             ADD      R0,R0,R11
   \   000008B2   0xFA5F 0xFB80      UXTB     R11,R0
   \                     ??_buffer_steps_82: (+1)
   \   000008B6   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000008BA   0xEB00 0x008B      ADD      R0,R0,R11, LSL #+2
   \   000008BE   0x6840             LDR      R0,[R0, #+4]
   \   000008C0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000008C4   0xD206             BCS.N    ??_buffer_steps_83
   1247              #endif
   1248              if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   \   000008C6   0x.... 0x....      BL       __aeabi_fdiv
   \   000008CA   0x4649             MOV      R1,R9
   \   000008CC   0x.... 0x....      BL       __aeabi_cfcmple
   \   000008D0   0xBF38             IT       CC 
   \   000008D2   0x4681             MOVCC    R9,R0
   1249            }
   \                     ??_buffer_steps_83: (+1)
   \   000008D4   0xF10B 0x0001      ADD      R0,R11,#+1
   \   000008D8   0xFA5F 0xFB80      UXTB     R11,R0
   \   000008DC   0xF1BB 0x0F04      CMP      R11,#+4
   \   000008E0   0xDBD8             BLT.N    ??_buffer_steps_81
   1250          
   1251            // Max segment time in µs.
   1252            #ifdef XY_FREQUENCY_LIMIT
   1253          
   1254              // Check and limit the xy direction change frequency
   1255              const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
   1256              old_direction_bits = block->direction_bits;
   1257              segment_time_us = LROUND((float)segment_time_us / speed_factor);
   1258          
   1259              uint32_t xs0 = axis_segment_time_us[X_AXIS][0],
   1260                       xs1 = axis_segment_time_us[X_AXIS][1],
   1261                       xs2 = axis_segment_time_us[X_AXIS][2],
   1262                       ys0 = axis_segment_time_us[Y_AXIS][0],
   1263                       ys1 = axis_segment_time_us[Y_AXIS][1],
   1264                       ys2 = axis_segment_time_us[Y_AXIS][2];
   1265          
   1266              if (TEST(direction_change, X_AXIS)) {
   1267                xs2 = axis_segment_time_us[X_AXIS][2] = xs1;
   1268                xs1 = axis_segment_time_us[X_AXIS][1] = xs0;
   1269                xs0 = 0;
   1270              }
   1271              xs0 = axis_segment_time_us[X_AXIS][0] = xs0 + segment_time_us;
   1272          
   1273              if (TEST(direction_change, Y_AXIS)) {
   1274                ys2 = axis_segment_time_us[Y_AXIS][2] = axis_segment_time_us[Y_AXIS][1];
   1275                ys1 = axis_segment_time_us[Y_AXIS][1] = axis_segment_time_us[Y_AXIS][0];
   1276                ys0 = 0;
   1277              }
   1278              ys0 = axis_segment_time_us[Y_AXIS][0] = ys0 + segment_time_us;
   1279          
   1280              const uint32_t max_x_segment_time = MAX3(xs0, xs1, xs2),
   1281                             max_y_segment_time = MAX3(ys0, ys1, ys2),
   1282                             min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
   1283              if (min_xy_segment_time < MAX_FREQ_TIME_US) {
   1284                const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
   1285                NOMORE(speed_factor, low_sf);
   1286              }
   1287            #endif // XY_FREQUENCY_LIMIT
   1288          
   1289            // Correct the speed
   1290            if (speed_factor < 1.0) {
   \   000008E2   0x4648             MOV      R0,R9
   \   000008E4   0x4651             MOV      R1,R10
   \   000008E6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000008EA   0xD221             BCS.N    ??_buffer_steps_84
   1291              LOOP_XYZE(i) current_speed[i] *= speed_factor;
   \   000008EC   0x9807             LDR      R0,[SP, #+28]
   \   000008EE   0x4649             MOV      R1,R9
   \   000008F0   0x.... 0x....      BL       __aeabi_fmul
   \   000008F4   0x9007             STR      R0,[SP, #+28]
   \   000008F6   0x4649             MOV      R1,R9
   \   000008F8   0x6868             LDR      R0,[R5, #+4]
   \   000008FA   0x.... 0x....      BL       __aeabi_fmul
   \   000008FE   0x6068             STR      R0,[R5, #+4]
   \   00000900   0x4649             MOV      R1,R9
   \   00000902   0x68A8             LDR      R0,[R5, #+8]
   \   00000904   0x.... 0x....      BL       __aeabi_fmul
   \   00000908   0x60A8             STR      R0,[R5, #+8]
   \   0000090A   0x4649             MOV      R1,R9
   \   0000090C   0x68E8             LDR      R0,[R5, #+12]
   \   0000090E   0x.... 0x....      BL       __aeabi_fmul
   \   00000912   0x60E8             STR      R0,[R5, #+12]
   1292              block->nominal_speed *= speed_factor;
   \   00000914   0x4649             MOV      R1,R9
   \   00000916   0x6AB8             LDR      R0,[R7, #+40]
   \   00000918   0x.... 0x....      BL       __aeabi_fmul
   \   0000091C   0x62B8             STR      R0,[R7, #+40]
   1293              block->nominal_rate *= speed_factor;
   \   0000091E   0x6BF8             LDR      R0,[R7, #+60]
   \   00000920   0x.... 0x....      BL       __aeabi_ui2f
   \   00000924   0x4649             MOV      R1,R9
   \   00000926   0x.... 0x....      BL       __aeabi_fmul
   \   0000092A   0x.... 0x....      BL       __aeabi_f2uiz
   \   0000092E   0x63F8             STR      R0,[R7, #+60]
   1294            }
   1295          
   1296            // Compute and limit the acceleration rate for the trapezoid generator.
   1297            const float steps_per_mm = block->step_event_count * inverse_millimeters;
   \                     ??_buffer_steps_84: (+1)
   \   00000930   0x6978             LDR      R0,[R7, #+20]
   \   00000932   0x.... 0x....      BL       __aeabi_ui2f
   \   00000936   0x9900             LDR      R1,[SP, #+0]
   \   00000938   0x.... 0x....      BL       __aeabi_fmul
   \   0000093C   0x4606             MOV      R6,R0
   1298            uint32_t accel;
   1299            if (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) {
   \   0000093E   0x6878             LDR      R0,[R7, #+4]
   \   00000940   0x2800             CMP      R0,#+0
   \   00000942   0xBF04             ITT      EQ 
   \   00000944   0x68B8             LDREQ    R0,[R7, #+8]
   \   00000946   0x2800             CMPEQ    R0,#+0
   \   00000948   0xD10A             BNE.N    ??_buffer_steps_85
   \   0000094A   0x68F8             LDR      R0,[R7, #+12]
   \   0000094C   0xB940             CBNZ.N   R0,??_buffer_steps_85
   1300              // convert to: acceleration steps/sec^2
   1301              accel = CEIL(retract_acceleration * steps_per_mm);
                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000094E   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000952   0x6A40             LDR      R0,[R0, #+36]
   \   00000954   0x4631             MOV      R1,R6
   \   00000956   0x.... 0x....      BL       __aeabi_fmul
   \   0000095A   0x.... 0x....      BL       ceilf
   \   0000095E   0xE0D6             B.N      ??_buffer_steps_86
   1302            }
   1303            else {
   1304              #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
   1305                if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
   1306                  const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
   1307                  if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
   1308                } \
   1309              }while(0)
   1310          
   1311              #define LIMIT_ACCEL_FLOAT(AXIS,INDX) do{ \
   1312                if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
   1313                  const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
   1314                  if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
   1315                } \
   1316              }while(0)
   1317          
   1318              // Start with print or travel acceleration
   1319              accel = CEIL((esteps ? acceleration : travel_acceleration) * steps_per_mm);
                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_85: (+1)
   \   00000960   0x9802             LDR      R0,[SP, #+8]
   \   00000962   0x2800             CMP      R0,#+0
   \   00000964   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000968   0xBF14             ITE      NE 
   \   0000096A   0x6A00             LDRNE    R0,[R0, #+32]
   \   0000096C   0x6A80             LDREQ    R0,[R0, #+40]
   \   0000096E   0x4631             MOV      R1,R6
   \   00000970   0x.... 0x....      BL       __aeabi_fmul
   \   00000974   0x.... 0x....      BL       ceilf
   \   00000978   0x.... 0x....      BL       __aeabi_f2uiz
   1320          
   1321              #if ENABLED(DISTINCT_E_FACTORS)
   1322                #define ACCEL_IDX extruder
   1323              #else
   1324                #define ACCEL_IDX 0
   1325              #endif
   1326          
   1327              // Limit acceleration per axis
   1328              if (block->step_event_count <= cutoff_long) {
   \   0000097C   0x687D             LDR      R5,[R7, #+4]
   \   0000097E   0xF8D7 0x8014      LDR      R8,[R7, #+20]
   \   00000982   0x4681             MOV      R9,R0
   \   00000984   0x6E60             LDR      R0,[R4, #+100]
   \   00000986   0x4540             CMP      R0,R8
   \   00000988   0xD334             BCC.N    ??_buffer_steps_87
   1329                LIMIT_ACCEL_LONG(X_AXIS, 0);
   \   0000098A   0xB14D             CBZ.N    R5,??_buffer_steps_88
   \   0000098C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000098E   0x4548             CMP      R0,R9
   \   00000990   0xBF3F             ITTTT    CC 
   \   00000992   0xFB08 0xF000      MULCC    R0,R8,R0
   \   00000996   0xFB05 0xF109      MULCC    R1,R5,R9
   \   0000099A   0x4288             CMPCC    R0,R1
   \   0000099C   0xFBB0 0xF9F5      UDIVCC   R9,R0,R5
   1330                LIMIT_ACCEL_LONG(Y_AXIS, 0);
   \                     ??_buffer_steps_88: (+1)
   \   000009A0   0x68BA             LDR      R2,[R7, #+8]
   \   000009A2   0xB14A             CBZ.N    R2,??_buffer_steps_89
   \   000009A4   0x6B20             LDR      R0,[R4, #+48]
   \   000009A6   0x4548             CMP      R0,R9
   \   000009A8   0xBF3F             ITTTT    CC 
   \   000009AA   0xFB08 0xF000      MULCC    R0,R8,R0
   \   000009AE   0xFB02 0xF109      MULCC    R1,R2,R9
   \   000009B2   0x4288             CMPCC    R0,R1
   \   000009B4   0xFBB0 0xF9F2      UDIVCC   R9,R0,R2
   1331                LIMIT_ACCEL_LONG(Z_AXIS, 0);
   \                     ??_buffer_steps_89: (+1)
   \   000009B8   0x68FA             LDR      R2,[R7, #+12]
   \   000009BA   0xB14A             CBZ.N    R2,??_buffer_steps_90
   \   000009BC   0x6B60             LDR      R0,[R4, #+52]
   \   000009BE   0x4548             CMP      R0,R9
   \   000009C0   0xBF3F             ITTTT    CC 
   \   000009C2   0xFB08 0xF000      MULCC    R0,R8,R0
   \   000009C6   0xFB02 0xF109      MULCC    R1,R2,R9
   \   000009CA   0x4288             CMPCC    R0,R1
   \   000009CC   0xFBB0 0xF9F2      UDIVCC   R9,R0,R2
   1332                LIMIT_ACCEL_LONG(E_AXIS, ACCEL_IDX);
   \                     ??_buffer_steps_90: (+1)
   \   000009D0   0x693A             LDR      R2,[R7, #+16]
   \   000009D2   0x2A00             CMP      R2,#+0
   \   000009D4   0xF000 0x809E      BEQ.W    ??_buffer_steps_91
   \   000009D8   0x9801             LDR      R0,[SP, #+4]
   \   000009DA   0x6B80             LDR      R0,[R0, #+56]
   \   000009DC   0x4548             CMP      R0,R9
   \   000009DE   0xBF3E             ITTT     CC 
   \   000009E0   0xFB08 0xF000      MULCC    R0,R8,R0
   \   000009E4   0xFB02 0xF109      MULCC    R1,R2,R9
   \   000009E8   0x4288             CMPCC    R0,R1
   \   000009EA   0xF080 0x8093      BCS.W    ??_buffer_steps_91
   \   000009EE   0xFBB0 0xF9F2      UDIV     R9,R0,R2
   \   000009F2   0xE08F             B.N      ??_buffer_steps_91
   1333              }
   1334              else {
   1335                LIMIT_ACCEL_FLOAT(X_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_87: (+1)
   \   000009F4   0xB30D             CBZ.N    R5,??_buffer_steps_92
   \   000009F6   0x6AE0             LDR      R0,[R4, #+44]
   \   000009F8   0x4548             CMP      R0,R9
   \   000009FA   0xD21E             BCS.N    ??_buffer_steps_92
   \   000009FC   0x.... 0x....      BL       __aeabi_ui2f
   \   00000A00   0x4683             MOV      R11,R0
   \   00000A02   0x4640             MOV      R0,R8
   \   00000A04   0x.... 0x....      BL       __aeabi_ui2f
   \   00000A08   0x4659             MOV      R1,R11
   \   00000A0A   0x.... 0x....      BL       __aeabi_fmul
   \   00000A0E   0x4683             MOV      R11,R0
   \   00000A10   0x4628             MOV      R0,R5
   \   00000A12   0x.... 0x....      BL       __aeabi_i2f
   \   00000A16   0x4605             MOV      R5,R0
   \   00000A18   0x4648             MOV      R0,R9
   \   00000A1A   0x.... 0x....      BL       __aeabi_ui2f
   \   00000A1E   0x4629             MOV      R1,R5
   \   00000A20   0x.... 0x....      BL       __aeabi_fmul
   \   00000A24   0x4601             MOV      R1,R0
   \   00000A26   0x4658             MOV      R0,R11
   \   00000A28   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000A2C   0xD205             BCS.N    ??_buffer_steps_92
   \   00000A2E   0x4629             MOV      R1,R5
   \   00000A30   0x.... 0x....      BL       __aeabi_fdiv
   \   00000A34   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000A38   0x4681             MOV      R9,R0
   1336                LIMIT_ACCEL_FLOAT(Y_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_92: (+1)
   \   00000A3A   0x68BD             LDR      R5,[R7, #+8]
   \   00000A3C   0xB30D             CBZ.N    R5,??_buffer_steps_93
   \   00000A3E   0x6B20             LDR      R0,[R4, #+48]
   \   00000A40   0x4548             CMP      R0,R9
   \   00000A42   0xD21E             BCS.N    ??_buffer_steps_93
   \   00000A44   0x.... 0x....      BL       __aeabi_ui2f
   \   00000A48   0x4683             MOV      R11,R0
   \   00000A4A   0x4640             MOV      R0,R8
   \   00000A4C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000A50   0x4659             MOV      R1,R11
   \   00000A52   0x.... 0x....      BL       __aeabi_fmul
   \   00000A56   0x4683             MOV      R11,R0
   \   00000A58   0x4628             MOV      R0,R5
   \   00000A5A   0x.... 0x....      BL       __aeabi_i2f
   \   00000A5E   0x4605             MOV      R5,R0
   \   00000A60   0x4648             MOV      R0,R9
   \   00000A62   0x.... 0x....      BL       __aeabi_ui2f
   \   00000A66   0x4629             MOV      R1,R5
   \   00000A68   0x.... 0x....      BL       __aeabi_fmul
   \   00000A6C   0x4601             MOV      R1,R0
   \   00000A6E   0x4658             MOV      R0,R11
   \   00000A70   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000A74   0xD205             BCS.N    ??_buffer_steps_93
   \   00000A76   0x4629             MOV      R1,R5
   \   00000A78   0x.... 0x....      BL       __aeabi_fdiv
   \   00000A7C   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000A80   0x4681             MOV      R9,R0
   1337                LIMIT_ACCEL_FLOAT(Z_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_93: (+1)
   \   00000A82   0x68FD             LDR      R5,[R7, #+12]
   \   00000A84   0xB30D             CBZ.N    R5,??_buffer_steps_94
   \   00000A86   0x6B60             LDR      R0,[R4, #+52]
   \   00000A88   0x4548             CMP      R0,R9
   \   00000A8A   0xD21E             BCS.N    ??_buffer_steps_94
   \   00000A8C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000A90   0x4683             MOV      R11,R0
   \   00000A92   0x4640             MOV      R0,R8
   \   00000A94   0x.... 0x....      BL       __aeabi_ui2f
   \   00000A98   0x4659             MOV      R1,R11
   \   00000A9A   0x.... 0x....      BL       __aeabi_fmul
   \   00000A9E   0x4683             MOV      R11,R0
   \   00000AA0   0x4628             MOV      R0,R5
   \   00000AA2   0x.... 0x....      BL       __aeabi_i2f
   \   00000AA6   0x4605             MOV      R5,R0
   \   00000AA8   0x4648             MOV      R0,R9
   \   00000AAA   0x.... 0x....      BL       __aeabi_ui2f
   \   00000AAE   0x4629             MOV      R1,R5
   \   00000AB0   0x.... 0x....      BL       __aeabi_fmul
   \   00000AB4   0x4601             MOV      R1,R0
   \   00000AB6   0x4658             MOV      R0,R11
   \   00000AB8   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000ABC   0xD205             BCS.N    ??_buffer_steps_94
   \   00000ABE   0x4629             MOV      R1,R5
   \   00000AC0   0x.... 0x....      BL       __aeabi_fdiv
   \   00000AC4   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000AC8   0x4681             MOV      R9,R0
   1338                LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_94: (+1)
   \   00000ACA   0x693D             LDR      R5,[R7, #+16]
   \   00000ACC   0xB315             CBZ.N    R5,??_buffer_steps_91
   \   00000ACE   0x9801             LDR      R0,[SP, #+4]
   \   00000AD0   0x6B80             LDR      R0,[R0, #+56]
   \   00000AD2   0x4548             CMP      R0,R9
   \   00000AD4   0xD21E             BCS.N    ??_buffer_steps_91
   \   00000AD6   0x.... 0x....      BL       __aeabi_ui2f
   \   00000ADA   0x4683             MOV      R11,R0
   \   00000ADC   0x4640             MOV      R0,R8
   \   00000ADE   0x.... 0x....      BL       __aeabi_ui2f
   \   00000AE2   0x4659             MOV      R1,R11
   \   00000AE4   0x.... 0x....      BL       __aeabi_fmul
   \   00000AE8   0x4680             MOV      R8,R0
   \   00000AEA   0x4628             MOV      R0,R5
   \   00000AEC   0x.... 0x....      BL       __aeabi_i2f
   \   00000AF0   0x4605             MOV      R5,R0
   \   00000AF2   0x4648             MOV      R0,R9
   \   00000AF4   0x.... 0x....      BL       __aeabi_ui2f
   \   00000AF8   0x4629             MOV      R1,R5
   \   00000AFA   0x.... 0x....      BL       __aeabi_fmul
   \   00000AFE   0x4601             MOV      R1,R0
   \   00000B00   0x4640             MOV      R0,R8
   \   00000B02   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000B06   0xD205             BCS.N    ??_buffer_steps_91
   \   00000B08   0x4629             MOV      R1,R5
   \   00000B0A   0x.... 0x....      BL       __aeabi_fdiv
   \                     ??_buffer_steps_86: (+1)
   \   00000B0E   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000B12   0x4681             MOV      R9,R0
   1339              }
   1340            }
   1341            block->acceleration_steps_per_s2 = accel;
   \                     ??_buffer_steps_91: (+1)
   \   00000B14   0xF8C7 0x9048      STR      R9,[R7, #+72]
   1342            block->acceleration = accel / steps_per_mm;
   \   00000B18   0x4648             MOV      R0,R9
   \   00000B1A   0x.... 0x....      BL       __aeabi_ui2f
   \   00000B1E   0x4631             MOV      R1,R6
   \   00000B20   0x.... 0x....      BL       __aeabi_fdiv
   \   00000B24   0x63B8             STR      R0,[R7, #+56]
   1343            //block->acceleration_rate = (long)(accel * 16777216.0 / ((F_CPU) * 0.125)); // * 8.388608
   1344            block->acceleration_rate = (long)(accel * 8.388608); // * 8.388608
   \   00000B26   0x4648             MOV      R0,R9
   \   00000B28   0x.... 0x....      BL       __aeabi_ui2d
   \   00000B2C   0x.... 0x....      LDR.W    R2,??DataTable18_2  ;; 0xa0b5ed8d
   \   00000B30   0x.... 0x....      LDR.W    R3,??DataTable18_3  ;; 0x4020c6f7
   \   00000B34   0x.... 0x....      BL       __aeabi_dmul
   \   00000B38   0x.... 0x....      BL       __aeabi_d2iz
   \   00000B3C   0x6238             STR      R0,[R7, #+32]
   1345          
   1346            // Initial limit on the segment entry velocity
   1347            float vmax_junction;
   1348          
   1349            #if 0  // Use old jerk for now
   1350          
   1351              float junction_deviation = 0.1;
   1352          
   1353              // Compute path unit vector
   1354              double unit_vec[XYZ] = {
   1355                delta_mm[X_AXIS] * inverse_millimeters,
   1356                delta_mm[Y_AXIS] * inverse_millimeters,
   1357                delta_mm[Z_AXIS] * inverse_millimeters
   1358              };
   1359          
   1360              /*
   1361                 Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
   1362          
   1363                 Let a circle be tangent to both previous and current path line segments, where the junction
   1364                 deviation is defined as the distance from the junction to the closest edge of the circle,
   1365                 collinear with the circle center.
   1366          
   1367                 The circular segment joining the two paths represents the path of centripetal acceleration.
   1368                 Solve for max velocity based on max acceleration about the radius of the circle, defined
   1369                 indirectly by junction deviation.
   1370          
   1371                 This may be also viewed as path width or max_jerk in the previous grbl version. This approach
   1372                 does not actually deviate from path, but used as a robust way to compute cornering speeds, as
   1373                 it takes into account the nonlinearities of both the junction angle and junction velocity.
   1374               */
   1375          
   1376              vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
   1377          
   1378              // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
   1379              if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
   1380                // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
   1381                // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
   1382                const float cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
   1383                                        - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
   1384                                        - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS];
   1385                // Skip and use default max junction speed for 0 degree acute junction.
   1386                if (cos_theta < 0.95) {
   1387                  vmax_junction = min(previous_nominal_speed, block->nominal_speed);
   1388                  // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
   1389                  if (cos_theta > -0.95) {
   1390                    // Compute maximum junction velocity based on maximum acceleration and junction deviation
   1391                    float sin_theta_d2 = SQRT(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
   1392                    NOMORE(vmax_junction, SQRT(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
   1393                  }
   1394                }
   1395              }
   1396            #endif
   1397          
   1398            /**
   1399             * Adapted from Průša MKS firmware
   1400             * https://github.com/prusa3d/Prusa-Firmware
   1401             *
   1402             * Start with a safe speed (from which the machine may halt to stop immediately).
   1403             */
   1404          
   1405            // Exit speed limited by a jerk to full halt of a previous last segment
   1406            static float previous_safe_speed;
   1407          
   1408            float safe_speed = block->nominal_speed;
   1409            uint8_t limited = 0;
   \   00000B3E   0x2500             MOVS     R5,#+0
   \   00000B40   0x6ABE             LDR      R6,[R7, #+40]
   1410            LOOP_XYZE(i) {
   \   00000B42   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \   00000B46   0x9000             STR      R0,[SP, #+0]
   \   00000B48   0xF10D 0x081C      ADD      R8,SP,#+28
   \   00000B4C   0xF04F 0x0904      MOV      R9,#+4
   1411              const float jerk = FABS(current_speed[i]), maxj = max_jerk[i];
   \                     ??_buffer_steps_95: (+1)
   \   00000B50   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000B54   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000B58   0x9001             STR      R0,[SP, #+4]
   \   00000B5A   0x9800             LDR      R0,[SP, #+0]
   1412              if (jerk > maxj) {
   \   00000B5C   0x9901             LDR      R1,[SP, #+4]
   \   00000B5E   0x6800             LDR      R0,[R0, #+0]
   \   00000B60   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000B64   0xD213             BCS.N    ??_buffer_steps_96
   1413                if (limited) {
   \   00000B66   0xB185             CBZ.N    R5,??_buffer_steps_97
   1414                  const float mjerk = maxj * block->nominal_speed;
   \   00000B68   0x6AB9             LDR      R1,[R7, #+40]
   \   00000B6A   0x.... 0x....      BL       __aeabi_fmul
   \   00000B6E   0x4683             MOV      R11,R0
   1415                  if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
   \   00000B70   0x9801             LDR      R0,[SP, #+4]
   \   00000B72   0x4631             MOV      R1,R6
   \   00000B74   0x.... 0x....      BL       __aeabi_fmul
   \   00000B78   0x4601             MOV      R1,R0
   \   00000B7A   0x4658             MOV      R0,R11
   \   00000B7C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000B80   0xD205             BCS.N    ??_buffer_steps_96
   \   00000B82   0x9901             LDR      R1,[SP, #+4]
   \   00000B84   0x.... 0x....      BL       __aeabi_fdiv
   \   00000B88   0xE000             B.N      ??_buffer_steps_98
   1416                }
   1417                else {
   1418                  ++limited;
   \                     ??_buffer_steps_97: (+1)
   \   00000B8A   0x2501             MOVS     R5,#+1
   1419                  safe_speed = maxj;
   \                     ??_buffer_steps_98: (+1)
   \   00000B8C   0x4606             MOV      R6,R0
   1420                }
   1421              }
   1422            }
   \                     ??_buffer_steps_96: (+1)
   \   00000B8E   0x9800             LDR      R0,[SP, #+0]
   \   00000B90   0x1D00             ADDS     R0,R0,#+4
   \   00000B92   0x9000             STR      R0,[SP, #+0]
   \   00000B94   0xF108 0x0804      ADD      R8,R8,#+4
   \   00000B98   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   00000B9C   0xD1D8             BNE.N    ??_buffer_steps_95
   1423          
   1424            if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
   \   00000B9E   0x9803             LDR      R0,[SP, #+12]
   \   00000BA0   0x2800             CMP      R0,#+0
   \   00000BA2   0xF000 0x8094      BEQ.W    ??_buffer_steps_99
   \   00000BA6   0x6FA2             LDR      R2,[R4, #+120]
   \   00000BA8   0x.... 0x....      LDR.W    R1,??DataTable18_5  ;; 0x358637be
   \   00000BAC   0x4610             MOV      R0,R2
   \   00000BAE   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000BB2   0xF0C0 0x808C      BCC.W    ??_buffer_steps_99
   1425              // Estimate a maximum velocity allowed at a joint of two successive segments.
   1426              // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
   1427              // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
   1428          
   1429              // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
   1430              // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
   1431              vmax_junction = min(block->nominal_speed, previous_nominal_speed);
   \   00000BB6   0x6AB8             LDR      R0,[R7, #+40]
   \   00000BB8   0x4611             MOV      R1,R2
   \   00000BBA   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000BBE   0xBF34             ITE      CC 
   \   00000BC0   0x4680             MOVCC    R8,R0
   \   00000BC2   0x4690             MOVCS    R8,R2
   1432          
   1433              // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
   1434              float v_factor = 1;
   \   00000BC4   0xF8CD 0xA010      STR      R10,[SP, #+16]
   1435              limited = 0;
   \   00000BC8   0x2500             MOVS     R5,#+0
   1436          
   1437              // Now limit the jerk in all axes.
   1438              const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
   \   00000BCA   0x4640             MOV      R0,R8
   \   00000BCC   0x.... 0x....      BL       __aeabi_fdiv
   \   00000BD0   0x9001             STR      R0,[SP, #+4]
   1439              LOOP_XYZE(axis) {
   \   00000BD2   0xF104 0x0068      ADD      R0,R4,#+104
   \   00000BD6   0x9000             STR      R0,[SP, #+0]
   \   00000BD8   0xA807             ADD      R0,SP,#+28
   \   00000BDA   0x9002             STR      R0,[SP, #+8]
   \   00000BDC   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \   00000BE0   0x9003             STR      R0,[SP, #+12]
   \   00000BE2   0x2004             MOVS     R0,#+4
   \   00000BE4   0x9005             STR      R0,[SP, #+20]
   1440                // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
   1441                float v_exit = previous_speed[axis] * smaller_speed_factor,
   \                     ??_buffer_steps_100: (+1)
   \   00000BE6   0x9800             LDR      R0,[SP, #+0]
   \   00000BE8   0x9901             LDR      R1,[SP, #+4]
   \   00000BEA   0x6800             LDR      R0,[R0, #+0]
   \   00000BEC   0x.... 0x....      BL       __aeabi_fmul
   \   00000BF0   0x4681             MOV      R9,R0
   1442                      v_entry = current_speed[axis];
   \   00000BF2   0x9802             LDR      R0,[SP, #+8]
   \   00000BF4   0xF8D0 0xB000      LDR      R11,[R0, #+0]
   1443                if (limited) {
   \   00000BF8   0xB2ED             UXTB     R5,R5
   \   00000BFA   0xB14D             CBZ.N    R5,??_buffer_steps_101
   1444                  v_exit *= v_factor;
   \   00000BFC   0x9804             LDR      R0,[SP, #+16]
   \   00000BFE   0x4649             MOV      R1,R9
   \   00000C00   0x.... 0x....      BL       __aeabi_fmul
   \   00000C04   0x4681             MOV      R9,R0
   1445                  v_entry *= v_factor;
   \   00000C06   0x9804             LDR      R0,[SP, #+16]
   \   00000C08   0x4659             MOV      R1,R11
   \   00000C0A   0x.... 0x....      BL       __aeabi_fmul
   \   00000C0E   0x4683             MOV      R11,R0
   1446                }
   1447          
   1448                // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
   1449                const float jerk = (v_exit > v_entry)
   1450                    ? //                                  coasting             axis reversal
   1451                      ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
   1452                    : // v_exit <= v_entry                coasting             axis reversal
   1453                      ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : max(-v_exit, v_entry) );
   \                     ??_buffer_steps_101: (+1)
   \   00000C10   0x4658             MOV      R0,R11
   \   00000C12   0x4649             MOV      R1,R9
   \   00000C14   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C18   0xD213             BCS.N    ??_buffer_steps_102
   \   00000C1A   0x2100             MOVS     R1,#+0
   \   00000C1C   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000C20   0xD303             BCC.N    ??_buffer_steps_103
   \   00000C22   0x4648             MOV      R0,R9
   \   00000C24   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C28   0xD202             BCS.N    ??_buffer_steps_104
   \                     ??_buffer_steps_103: (+1)
   \   00000C2A   0x4648             MOV      R0,R9
   \   00000C2C   0x4659             MOV      R1,R11
   \   00000C2E   0xE012             B.N      ??_buffer_steps_105
   \                     ??_buffer_steps_104: (+1)
   \   00000C30   0xF08B 0x4200      EOR      R2,R11,#0x80000000
   \   00000C34   0x4610             MOV      R0,R2
   \   00000C36   0x4649             MOV      R1,R9
   \   00000C38   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C3C   0xD317             BCC.N    ??_buffer_steps_106
   \   00000C3E   0x4691             MOV      R9,R2
   \   00000C40   0xE015             B.N      ??_buffer_steps_106
   \                     ??_buffer_steps_102: (+1)
   \   00000C42   0x2100             MOVS     R1,#+0
   \   00000C44   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C48   0xD303             BCC.N    ??_buffer_steps_107
   \   00000C4A   0x4648             MOV      R0,R9
   \   00000C4C   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000C50   0xD205             BCS.N    ??_buffer_steps_108
   \                     ??_buffer_steps_107: (+1)
   \   00000C52   0x4658             MOV      R0,R11
   \   00000C54   0x4649             MOV      R1,R9
   \                     ??_buffer_steps_105: (+1)
   \   00000C56   0x.... 0x....      BL       __aeabi_fsub
   \   00000C5A   0x4681             MOV      R9,R0
   \   00000C5C   0xE007             B.N      ??_buffer_steps_106
   \                     ??_buffer_steps_108: (+1)
   \   00000C5E   0xF089 0x4900      EOR      R9,R9,#0x80000000
   \   00000C62   0x4658             MOV      R0,R11
   \   00000C64   0x4649             MOV      R1,R9
   \   00000C66   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C6A   0xBF28             IT       CS 
   \   00000C6C   0x46D9             MOVCS    R9,R11
   1454          
   1455                if (jerk > max_jerk[axis]) {
   \                     ??_buffer_steps_106: (+1)
   \   00000C6E   0x9803             LDR      R0,[SP, #+12]
   \   00000C70   0x6800             LDR      R0,[R0, #+0]
   \   00000C72   0x4649             MOV      R1,R9
   \   00000C74   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C78   0xD206             BCS.N    ??_buffer_steps_109
   1456                  v_factor *= max_jerk[axis] / jerk;
   \   00000C7A   0x.... 0x....      BL       __aeabi_fdiv
   \   00000C7E   0x9904             LDR      R1,[SP, #+16]
   \   00000C80   0x.... 0x....      BL       __aeabi_fmul
   \   00000C84   0x9004             STR      R0,[SP, #+16]
   1457                  ++limited;
   \   00000C86   0x1C6D             ADDS     R5,R5,#+1
   1458                }
   1459              }
   \                     ??_buffer_steps_109: (+1)
   \   00000C88   0x9803             LDR      R0,[SP, #+12]
   \   00000C8A   0x1D00             ADDS     R0,R0,#+4
   \   00000C8C   0x9003             STR      R0,[SP, #+12]
   \   00000C8E   0x9802             LDR      R0,[SP, #+8]
   \   00000C90   0x1D00             ADDS     R0,R0,#+4
   \   00000C92   0x9002             STR      R0,[SP, #+8]
   \   00000C94   0x9800             LDR      R0,[SP, #+0]
   \   00000C96   0x1D00             ADDS     R0,R0,#+4
   \   00000C98   0x9000             STR      R0,[SP, #+0]
   \   00000C9A   0x9805             LDR      R0,[SP, #+20]
   \   00000C9C   0x1E40             SUBS     R0,R0,#+1
   \   00000C9E   0x9005             STR      R0,[SP, #+20]
   \   00000CA0   0xD1A1             BNE.N    ??_buffer_steps_100
   1460              if (limited) vmax_junction *= v_factor;
   \   00000CA2   0xB2E8             UXTB     R0,R5
   \   00000CA4   0xB120             CBZ.N    R0,??_buffer_steps_110
   \   00000CA6   0x4641             MOV      R1,R8
   \   00000CA8   0x9804             LDR      R0,[SP, #+16]
   \   00000CAA   0x.... 0x....      BL       __aeabi_fmul
   \   00000CAE   0x4680             MOV      R8,R0
   1461              // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
   1462              // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
   1463              const float vmax_junction_threshold = vmax_junction * 0.99f;
   \                     ??_buffer_steps_110: (+1)
   \   00000CB0   0x.... 0x....      LDR.W    R0,??DataTable18_6  ;; 0x3f7d70a4
   \   00000CB4   0x4641             MOV      R1,R8
   \   00000CB6   0x.... 0x....      BL       __aeabi_fmul
   1464              if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold) {
   \   00000CBA   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000CBE   0x6C09             LDR      R1,[R1, #+64]
   \   00000CC0   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000CC4   0xD208             BCS.N    ??_buffer_steps_111
   \   00000CC6   0x4631             MOV      R1,R6
   \   00000CC8   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000CCC   0xD204             BCS.N    ??_buffer_steps_111
   1465                // Not coasting. The machine will stop and start the movements anyway,
   1466                // better to start the segment from start.
   1467                SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
   1468                vmax_junction = safe_speed;
   1469              }
   1470            }
   1471            else {
   1472              SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
   \                     ??_buffer_steps_99: (+1)
   \   00000CCE   0x7838             LDRB     R0,[R7, #+0]
   \   00000CD0   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000CD4   0x7038             STRB     R0,[R7, #+0]
   1473              vmax_junction = safe_speed;
   \   00000CD6   0x46B0             MOV      R8,R6
   1474            }
   1475          
   1476            // Max entry speed of this block equals the max exit speed of the previous block.
   1477            block->max_entry_speed = vmax_junction;
   \                     ??_buffer_steps_111: (+1)
   \   00000CD8   0xF8C7 0x8030      STR      R8,[R7, #+48]
   1478          
   1479            // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   1480            const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
   \   00000CDC   0xF04F 0x0B02      MOV      R11,#+2
   \   00000CE0   0x6BB8             LDR      R0,[R7, #+56]
   \   00000CE2   0x.... 0x....      LDR.W    R5,??DataTable18_7  ;; 0x3d4ccccd
   \   00000CE6   0xF080 0x4900      EOR      R9,R0,#0x80000000
   \   00000CEA   0xF107 0x0034      ADD      R0,R7,#+52
   \   00000CEE   0x9000             STR      R0,[SP, #+0]
   \   00000CF0   0xE004             B.N      ??_buffer_steps_112
   \                     ??_buffer_steps_113: (+1)
   \   00000CF2   0x4628             MOV      R0,R5
   \   00000CF4   0x4629             MOV      R1,R5
   \   00000CF6   0x.... 0x....      BL       __aeabi_fmul
   \   00000CFA   0x4605             MOV      R5,R0
   \                     ??_buffer_steps_112: (+1)
   \   00000CFC   0xEA5F 0x70CB      LSLS     R0,R11,#+31
   \   00000D00   0xD504             BPL.N    ??_buffer_steps_114
   \   00000D02   0x4650             MOV      R0,R10
   \   00000D04   0x4629             MOV      R1,R5
   \   00000D06   0x.... 0x....      BL       __aeabi_fmul
   \   00000D0A   0x4682             MOV      R10,R0
   \                     ??_buffer_steps_114: (+1)
   \   00000D0C   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   \   00000D10   0xD1EF             BNE.N    ??_buffer_steps_113
   \   00000D12   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000D16   0x4649             MOV      R1,R9
   \   00000D18   0x.... 0x....      BL       __aeabi_fmul
   \   00000D1C   0x9900             LDR      R1,[SP, #+0]
   \   00000D1E   0x6809             LDR      R1,[R1, #+0]
   \   00000D20   0x.... 0x....      BL       __aeabi_fmul
   \   00000D24   0x4601             MOV      R1,R0
   \   00000D26   0x4650             MOV      R0,R10
   \   00000D28   0x.... 0x....      BL       __aeabi_fsub
   \   00000D2C   0x.... 0x....      BL       sqrtf
   \   00000D30   0x4601             MOV      R1,R0
   1481            block->entry_speed = min(vmax_junction, v_allowable);
   \   00000D32   0x4640             MOV      R0,R8
   \   00000D34   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000D38   0xBF28             IT       CS 
   \   00000D3A   0x4688             MOVCS    R8,R1
   \   00000D3C   0xF8C7 0x802C      STR      R8,[R7, #+44]
   1482          
   1483            // Initialize planner efficiency flags
   1484            // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   1485            // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   1486            // the current block and next block junction speeds are guaranteed to always be at their maximum
   1487            // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   1488            // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   1489            // the reverse and forward planners, the corresponding block junction speed will always be at the
   1490            // the maximum junction speed and may always be ignored for any speed reduction checks.
   1491            block->flag |= BLOCK_FLAG_RECALCULATE | (block->nominal_speed <= v_allowable ? BLOCK_FLAG_NOMINAL_LENGTH : 0);
   \   00000D40   0x4608             MOV      R0,R1
   \   00000D42   0x6AB9             LDR      R1,[R7, #+40]
   \   00000D44   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000D48   0xBF94             ITE      LS 
   \   00000D4A   0x2002             MOVLS    R0,#+2
   \   00000D4C   0x2000             MOVHI    R0,#+0
   \   00000D4E   0x7839             LDRB     R1,[R7, #+0]
   \   00000D50   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000D54   0x4308             ORRS     R0,R0,R1
   \   00000D56   0x7038             STRB     R0,[R7, #+0]
   1492          
   1493            // Update previous path unit_vector and nominal speed
   1494            COPY(previous_speed, current_speed);
   \   00000D58   0x2210             MOVS     R2,#+16
   \   00000D5A   0xA907             ADD      R1,SP,#+28
   \   00000D5C   0xF104 0x0068      ADD      R0,R4,#+104
   \   00000D60   0x.... 0x....      BL       __aeabi_memcpy4
   1495            previous_nominal_speed = block->nominal_speed;
   \   00000D64   0x6AB8             LDR      R0,[R7, #+40]
   \   00000D66   0x67A0             STR      R0,[R4, #+120]
   1496            previous_safe_speed = safe_speed;
   \   00000D68   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000D6C   0x6406             STR      R6,[R0, #+64]
   1497          
   1498            #if ENABLED(LIN_ADVANCE)
   1499              /**
   1500               *
   1501               * Use LIN_ADVANCE for blocks if all these are true:
   1502               *
   1503               * esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS]) : This is a print move
   1504               *
   1505               * extruder_advance_k                 : There is an advance factor set.
   1506               *
   1507               * esteps != block->step_event_count  : A problem occurs if the move before a retract is too small.
   1508               *                                      In that case, the retract and move will be executed together.
   1509               *                                      This leads to too many advance steps due to a huge e_acceleration.
   1510               *                                      The math is good, but we must avoid retract moves with advance!
   1511               * lin_dist_e > 0                       : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
   1512               */
   1513              block->use_advance_lead =  esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS])
   1514                                      && extruder_advance_k
   1515                                      && (uint32_t)esteps != block->step_event_count
   1516                                      && lin_dist_e > 0;
   1517              if (block->use_advance_lead)
   1518                block->abs_adv_steps_multiplier8 = LROUND(
   1519                  extruder_advance_k
   1520                  * (UNEAR_ZERO(advance_ed_ratio) ? lin_dist_e / lin_dist_xy : advance_ed_ratio) // Use the fixed ratio, if set
   1521                  * (block->nominal_speed / (float)block->nominal_rate)
   1522                  * axis_steps_per_mm[E_AXIS_N] * 256.0
   1523                );
   1524          
   1525            #endif // LIN_ADVANCE
   1526          
   1527            const float bnsr = 1.0 / block->nominal_speed;
   \   00000D6E   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000D72   0x6AB9             LDR      R1,[R7, #+40]
   \   00000D74   0x.... 0x....      BL       __aeabi_fdiv
   \   00000D78   0x4605             MOV      R5,R0
   1528            calculate_trapezoid_for_block(block, block->entry_speed * bnsr, safe_speed * bnsr);
   \   00000D7A   0x6AF8             LDR      R0,[R7, #+44]
   \   00000D7C   0x4629             MOV      R1,R5
   \   00000D7E   0x.... 0x....      BL       __aeabi_fmul
   \   00000D82   0x9001             STR      R0,[SP, #+4]
   \   00000D84   0x4629             MOV      R1,R5
   \   00000D86   0x4630             MOV      R0,R6
   \   00000D88   0x.... 0x....      BL       __aeabi_fmul
   \   00000D8C   0x9000             STR      R0,[SP, #+0]
   \   00000D8E   0xAA00             ADD      R2,SP,#+0
   \   00000D90   0xA901             ADD      R1,SP,#+4
   \   00000D92   0x4638             MOV      R0,R7
   \   00000D94   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
   1529          
   1530            // Move buffer head
   1531            block_buffer_head = next_buffer_head;
   \   00000D98   0x9806             LDR      R0,[SP, #+24]
   \   00000D9A   0x7020             STRB     R0,[R4, #+0]
   1532          
   1533            // Update the position (only when a move was queued)
   1534            static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   1535            COPY(position, target);
   \   00000D9C   0x2210             MOVS     R2,#+16
   \   00000D9E   0x9912             LDR      R1,[SP, #+72]
   \   00000DA0   0xF104 0x0040      ADD      R0,R4,#+64
   \   00000DA4   0x.... 0x....      BL       __aeabi_memcpy4
   1536          
   1537            recalculate();
   \   00000DA8   0x.... 0x....      BL       _ZN7Planner12reverse_passEv
   \   00000DAC   0x.... 0x....      BL       _ZN7Planner12forward_passEv
   \   00000DB0   0x.... 0x....      BL       _ZN7Planner22recalculate_trapezoidsEv
   1538          
   1539          } // _buffer_steps()
   \                     ??_buffer_steps_25: (+1)
   \   00000DB4   0xB015             ADD      SP,SP,#+84
   \   00000DB6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .bss, align 4
   \                     _ZN7Planner23g_uc_extruder_last_moveE:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \                     _ZN7Planner17max_feedrate_mm_sE:
   \   00000004                      DS8 20
   \                     _ZN7Planner19min_segment_time_usE:
   \   00000018                      DS8 4
   \                     _ZN7Planner17min_feedrate_mm_sE:
   \   0000001C                      DS8 4
   \                     _ZN7Planner12accelerationE:
   \   00000020                      DS8 4
   \                     _ZN7Planner20retract_accelerationE:
   \   00000024                      DS8 4
   \                     _ZN7Planner19travel_accelerationE:
   \   00000028                      DS8 4
   \                     _ZN7Planner8max_jerkE:
   \   0000002C                      DS8 16
   \                     _ZN7Planner24min_travel_feedrate_mm_sE:
   \   0000003C                      DS8 4
   \   00000040                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner26max_acceleration_mm_per_s2E:
   \   00000000                      DS8 20

   \                                 In section .bss, align 1
   \                     _ZN7Planner15leveling_activeE:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZN7Planner16bed_level_matrixE:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
   \                     _ZN7Planner13z_fade_heightE:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner21inverse_z_fade_heightE:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner11last_fade_zE:
   \   00000000                      DS8 4
   1540          
   1541          /**
   1542           * Planner::buffer_segment
   1543           *
   1544           * Add a new linear movement to the buffer in axis units.
   1545           *
   1546           * Leveling and kinematics should be applied ahead of calling this.
   1547           *
   1548           *  a,b,c,e   - target positions in mm and/or degrees
   1549           *  fr_mm_s   - (target) speed of the move
   1550           *  extruder  - target extruder
   1551           */

   \                                 In section .text, align 2, keep-with-next
   1552          void Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder) {
   \                     _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h: (+1)
   \   00000000   0xE92D 0x4EF0      PUSH     {R4-R7,R9-R11,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0xF8DD 0x9054      LDR      R9,[SP, #+84]
   1553          
   1554          
   1555            
   1556            // When changing extruders recalculate steps corresponding to the E position
   1557            #if ENABLED(DISTINCT_E_FACTORS)
   1558              if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable18_8
   \   00000010   0xEB04 0x0089      ADD      R0,R4,R9, LSL #+2
   \   00000014   0x9001             STR      R0,[SP, #+4]
   \   00000016   0x460D             MOV      R5,R1
   \   00000018   0x78A0             LDRB     R0,[R4, #+2]
   \   0000001A   0x4692             MOV      R10,R2
   \   0000001C   0x461F             MOV      R7,R3
   \   0000001E   0x4548             CMP      R0,R9
   \   00000020   0xD01A             BEQ.N    ??buffer_segment_0
   \   00000022   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x9801             LDR      R0,[SP, #+4]
   \   0000002A   0x9900             LDR      R1,[SP, #+0]
   \   0000002C   0xF8D0 0xB010      LDR      R11,[R0, #+16]
   \   00000030   0x6909             LDR      R1,[R1, #+16]
   \   00000032   0x4658             MOV      R0,R11
   \   00000034   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000038   0xD00E             BEQ.N    ??buffer_segment_0
   1559                position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
   \   0000003A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000003C   0x.... 0x....      BL       __aeabi_i2f
   \   00000040   0x4659             MOV      R1,R11
   \   00000042   0x.... 0x....      BL       __aeabi_fmul
   \   00000046   0x9900             LDR      R1,[SP, #+0]
   \   00000048   0x6A49             LDR      R1,[R1, #+36]
   \   0000004A   0x.... 0x....      BL       __aeabi_fmul
   \   0000004E   0x.... 0x....      BL       lroundf
   \   00000052   0x64E0             STR      R0,[R4, #+76]
   1560                last_extruder = extruder;
   \   00000054   0xF884 0x9002      STRB     R9,[R4, #+2]
   1561              }
   1562            #endif
   1563          
   1564            // The target position of the tool in absolute steps
   1565            // Calculate target position in absolute steps
   1566            const int32_t target[XYZE] = {
   \                     ??buffer_segment_0: (+1)
   \   00000058   0x6831             LDR      R1,[R6, #+0]
   \   0000005A   0x6860             LDR      R0,[R4, #+4]
   \   0000005C   0x.... 0x....      BL       __aeabi_fmul
   \   00000060   0x.... 0x....      BL       lroundf
   \   00000064   0x9002             STR      R0,[SP, #+8]
   \   00000066   0xAE02             ADD      R6,SP,#+8
   \   00000068   0x6829             LDR      R1,[R5, #+0]
   \   0000006A   0x68A0             LDR      R0,[R4, #+8]
   \   0000006C   0x.... 0x....      BL       __aeabi_fmul
   \   00000070   0x.... 0x....      BL       lroundf
   \   00000074   0x6070             STR      R0,[R6, #+4]
   \   00000076   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   0000007A   0x68E0             LDR      R0,[R4, #+12]
   \   0000007C   0x.... 0x....      BL       __aeabi_fmul
   \   00000080   0x.... 0x....      BL       lroundf
   \   00000084   0x60B0             STR      R0,[R6, #+8]
   \   00000086   0x9801             LDR      R0,[SP, #+4]
   \   00000088   0x6839             LDR      R1,[R7, #+0]
   \   0000008A   0x6900             LDR      R0,[R0, #+16]
   \   0000008C   0x.... 0x....      BL       __aeabi_fmul
   \   00000090   0x.... 0x....      BL       lroundf
   1567              LROUND(a * axis_steps_per_mm[X_AXIS]),
   1568              LROUND(b * axis_steps_per_mm[Y_AXIS]),
   1569              LROUND(c * axis_steps_per_mm[Z_AXIS]),
   1570              LROUND(e * axis_steps_per_mm[E_AXIS_N])
   1571            };
   1572          
   1573            
   1574            if(MACHINETPYE & IS_KINEMATIC)
   \   00000094   0x.... 0x....      LDR.W    R3,??DataTable18_9
   \   00000098   0x4602             MOV      R2,R0
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable18_10
   \   0000009E   0x60F2             STR      R2,[R6, #+12]
   \   000000A0   0xF240 0x3102      MOVW     R1,#+770
   \   000000A4   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   000000A8   0x4208             TST      R0,R1
   \   000000AA   0xF893 0x0158      LDRB     R0,[R3, #+344]
   \   000000AE   0xD00A             BEQ.N    ??buffer_segment_1
   1575            {
   1576              if (gCfgItems.breakpoint_reprint_flg == 1)
   \   000000B0   0x2801             CMP      R0,#+1
   \   000000B2   0xD11F             BNE.N    ??buffer_segment_2
   1577              {
   1578                  if(gCfgItems.had_breakpoint)
   \   000000B4   0xF503 0x70AC      ADD      R0,R3,#+344
   \   000000B8   0x7B01             LDRB     R1,[R0, #+12]
   \   000000BA   0xB1D9             CBZ.N    R1,??buffer_segment_2
   1579                  {
   1580                      gCfgItems.had_breakpoint=0;
   \   000000BC   0x2100             MOVS     R1,#+0
   \   000000BE   0x7301             STRB     R1,[R0, #+12]
   1581                      position[E_AXIS] = gCfgItems.breakpoint_e_position;
   \   000000C0   0x6880             LDR      R0,[R0, #+8]
   \   000000C2   0x64E0             STR      R0,[R4, #+76]
   \   000000C4   0xE016             B.N      ??buffer_segment_2
   1582                  }
   1583              }
   1584            }
   1585            else
   1586            {
   1587          	if (gCfgItems.breakpoint_reprint_flg == 1) {
   \                     ??buffer_segment_1: (+1)
   \   000000C6   0x2801             CMP      R0,#+1
   \   000000C8   0xD110             BNE.N    ??buffer_segment_3
   1588          		if (c < gCfgItems.breakpoint_z_pos) 
   \   000000CA   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000000CE   0xF8D3 0x12A8      LDR      R1,[R3, #+680]
   \   000000D2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D6   0xD209             BCS.N    ??buffer_segment_3
   1589                  {
   1590                      position[E_AXIS] = target[E_AXIS_N];
   \   000000D8   0xA802             ADD      R0,SP,#+8
   \   000000DA   0xEB00 0x0089      ADD      R0,R0,R9, LSL #+2
   1591                      gCfgItems.breakpoint_flg=1;
   \   000000DE   0xF503 0x71AC      ADD      R1,R3,#+344
   \   000000E2   0x68C0             LDR      R0,[R0, #+12]
   \   000000E4   0x64E0             STR      R0,[R4, #+76]
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0x7348             STRB     R0,[R1, #+13]
   1592                      return;
   1593                  }
   1594          	}
   1595              //gCfgItems.breakpoint_reprint_flg = 0;
   1596              gCfgItems.breakpoint_flg=0;
   1597            }
   1598          
   1599            // DRYRUN prevents E moves from taking place
   1600            if (DEBUGGING(DRYRUN)) {
   1601              position[E_AXIS] = target[E_AXIS];
   1602              #if ENABLED(LIN_ADVANCE)
   1603                position_float[E_AXIS] = e;
   1604              #endif
   1605            }
   1606          
   1607            #if ENABLED(LIN_ADVANCE)
   1608              lin_dist_e = e - position_float[E_AXIS];
   1609            #endif
   1610          
   1611            // If LIN_ADVANCE is enabled then do E move prevention with floats
   1612            // Otherwise it's done in _buffer_steps.
   1613            #if ENABLED(LIN_ADVANCE) && (ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE))
   1614              if (lin_dist_e) {
   1615                #if ENABLED(PREVENT_COLD_EXTRUSION)
   1616                  if (thermalManager.tooColdToExtrude(extruder)) {
   1617                    position_float[E_AXIS] = e; // Behave as if the move really took place, but ignore E part
   1618                    position[E_AXIS] = target[E_AXIS];
   1619                    lin_dist_e = 0;
   1620                    SERIAL_ECHO_START();
   1621                    SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
   1622                  }
   1623                #endif // PREVENT_COLD_EXTRUSION
   1624                #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
   1625                  if (lin_dist_e * e_factor[extruder] > (EXTRUDE_MAXLENGTH)) {
   1626                    position_float[E_AXIS] = e; // Behave as if the move really took place, but ignore E part
   1627                    position[E_AXIS] = target[E_AXIS];
   1628                    lin_dist_e = 0;
   1629                    SERIAL_ECHO_START();
   1630                    SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   1631                  }
   1632                #endif // PREVENT_LENGTHY_EXTRUDE
   1633              }
   1634            #endif // LIN_ADVANCE && (PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE)
   1635          
   1636            #if ENABLED(LIN_ADVANCE)
   1637              if (lin_dist_e > 0)
   1638                lin_dist_xy = HYPOT(a - position_float[X_AXIS], b - position_float[Y_AXIS]);
   1639            #endif
   1640          
   1641            /* <-- add a slash to enable
   1642              SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
   1643              #if IS_KINEMATIC
   1644                SERIAL_ECHOPAIR(" A:", a);
   1645                SERIAL_ECHOPAIR(" (", position[A_AXIS]);
   1646                SERIAL_ECHOPAIR("->", target[A_AXIS]);
   1647                SERIAL_ECHOPAIR(") B:", b);
   1648              #else
   1649                SERIAL_ECHOPAIR(" X:", a);
   1650                SERIAL_ECHOPAIR(" (", position[X_AXIS]);
   1651                SERIAL_ECHOPAIR("->", target[X_AXIS]);
   1652                SERIAL_ECHOPAIR(") Y:", b);
   1653              #endif
   1654              SERIAL_ECHOPAIR(" (", position[Y_AXIS]);
   1655              SERIAL_ECHOPAIR("->", target[Y_AXIS]);
   1656              #if ENABLED(DELTA)
   1657                SERIAL_ECHOPAIR(") C:", c);
   1658              #else
   1659                SERIAL_ECHOPAIR(") Z:", c);
   1660              #endif
   1661              SERIAL_ECHOPAIR(" (", position[Z_AXIS]);
   1662              SERIAL_ECHOPAIR("->", target[Z_AXIS]);
   1663              SERIAL_ECHOPAIR(") E:", e);
   1664              SERIAL_ECHOPAIR(" (", position[E_AXIS]);
   1665              SERIAL_ECHOPAIR("->", target[E_AXIS]);
   1666              SERIAL_ECHOLNPGM(")");
   1667            //*/
                    ^
Warning[Pe009]: nested comment is not allowed
   1668          
   1669            // Always split the first move into two (if not homing or probing)
   1670          
   1671            if (!blocks_queued()) {
   1672          
   1673              #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
   1674              const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
   1675              DISABLE_STEPPER_DRIVER_INTERRUPT();
   1676          
   1677              #if ENABLED(LIN_ADVANCE)
   1678                lin_dist_xy *= 0.5;
   1679                lin_dist_e *= 0.5;
   1680              #endif
   1681          
   1682              _buffer_steps(between, fr_mm_s, extruder);
   1683          
   1684              #if ENABLED(LIN_ADVANCE)
   1685                position_float[X_AXIS] = (position_float[X_AXIS] + a) * 0.5;
   1686                position_float[Y_AXIS] = (position_float[Y_AXIS] + b) * 0.5;
   1687                //position_float[Z_AXIS] = (position_float[Z_AXIS] + c) * 0.5;
   1688                position_float[E_AXIS] = (position_float[E_AXIS] + e) * 0.5;
   1689              #endif
   1690          
   1691              const uint8_t next = block_buffer_head;
   1692              _buffer_steps(target, fr_mm_s, extruder);
   1693              SBI(block_buffer[next].flag, BLOCK_BIT_CONTINUED);
   1694              ENABLE_STEPPER_DRIVER_INTERRUPT();
   1695            }
   1696            else
   1697          
   1698              _buffer_steps(target, fr_mm_s, extruder);
   1699          
   1700            stepper.wake_up();
   1701          
   1702            #if ENABLED(LIN_ADVANCE)
   1703              position_float[X_AXIS] = a;
   1704              position_float[Y_AXIS] = b;
   1705              //position_float[Z_AXIS] = c;
   1706              position_float[E_AXIS] = e;
   1707            #endif
   1708          } // buffer_segment()
   \   000000EA   0x....             B.N      ?Subroutine2
   \                     ??buffer_segment_3: (+1)
   \   000000EC   0xF503 0x71AC      ADD      R1,R3,#+344
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x7348             STRB     R0,[R1, #+13]
   \                     ??buffer_segment_2: (+1)
   \   000000F4   0x....             LDR.N    R0,??DataTable18_11
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x0700             LSLS     R0,R0,#+28
   \   000000FA   0xBF48             IT       MI 
   \   000000FC   0x64E2             STRMI    R2,[R4, #+76]
   \   000000FE   0x7820             LDRB     R0,[R4, #+0]
   \   00000100   0x9D14             LDR      R5,[SP, #+80]
   \   00000102   0x7861             LDRB     R1,[R4, #+1]
   \   00000104   0x4288             CMP      R0,R1
   \   00000106   0xD12D             BNE.N    ??buffer_segment_4
   \   00000108   0x6C20             LDR      R0,[R4, #+64]
   \   0000010A   0x9902             LDR      R1,[SP, #+8]
   \   0000010C   0x1808             ADDS     R0,R1,R0
   \   0000010E   0x1040             ASRS     R0,R0,#+1
   \   00000110   0x9006             STR      R0,[SP, #+24]
   \   00000112   0x6C61             LDR      R1,[R4, #+68]
   \   00000114   0x6873             LDR      R3,[R6, #+4]
   \   00000116   0xA806             ADD      R0,SP,#+24
   \   00000118   0x1859             ADDS     R1,R3,R1
   \   0000011A   0x1049             ASRS     R1,R1,#+1
   \   0000011C   0x6041             STR      R1,[R0, #+4]
   \   0000011E   0x68B3             LDR      R3,[R6, #+8]
   \   00000120   0x6CA1             LDR      R1,[R4, #+72]
   \   00000122   0x....             LDR.N    R6,??DataTable18_12
   \   00000124   0x1859             ADDS     R1,R3,R1
   \   00000126   0x1049             ASRS     R1,R1,#+1
   \   00000128   0x6081             STR      R1,[R0, #+8]
   \   0000012A   0x6CE1             LDR      R1,[R4, #+76]
   \   0000012C   0x1851             ADDS     R1,R2,R1
   \   0000012E   0x1049             ASRS     R1,R1,#+1
   \   00000130   0x60C1             STR      R1,[R0, #+12]
   \   00000132   0x4630             MOV      R0,R6
   \   00000134   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   \   00000138   0x6829             LDR      R1,[R5, #+0]
   \   0000013A   0x464A             MOV      R2,R9
   \   0000013C   0xA806             ADD      R0,SP,#+24
   \   0000013E   0x.... 0x....      BL       _ZN7Planner13_buffer_stepsERA4_Kifh
   \   00000142   0x7827             LDRB     R7,[R4, #+0]
   \   00000144   0x6829             LDR      R1,[R5, #+0]
   \   00000146   0x464A             MOV      R2,R9
   \   00000148   0xA802             ADD      R0,SP,#+8
   \   0000014A   0x.... 0x....      BL       _ZN7Planner13_buffer_stepsERA4_Kifh
   \   0000014E   0x2054             MOVS     R0,#+84
   \   00000150   0x4378             MULS     R0,R0,R7
   \   00000152   0x....             LDR.N    R1,??DataTable18_13
   \   00000154   0x5C42             LDRB     R2,[R0, R1]
   \   00000156   0xF042 0x0210      ORR      R2,R2,#0x10
   \   0000015A   0x5442             STRB     R2,[R0, R1]
   \   0000015C   0x4630             MOV      R0,R6
   \   0000015E   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \   00000162   0xE004             B.N      ??buffer_segment_5
   \                     ??buffer_segment_4: (+1)
   \   00000164   0x6829             LDR      R1,[R5, #+0]
   \   00000166   0x464A             MOV      R2,R9
   \   00000168   0xA802             ADD      R0,SP,#+8
   \   0000016A   0x.... 0x....      BL       _ZN7Planner13_buffer_stepsERA4_Kifh
   \                     ??buffer_segment_5: (+1)
   \   0000016E   0x.... 0x....      BL       _ZN7Stepper7wake_upEv
   \   00000172                      REQUIRE ?Subroutine2
   \   00000172                      ;; // Fall through to label ?Subroutine2

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xB00C             ADD      SP,SP,#+48
   \   00000002   0xE8BD 0x8EF0      POP      {R4-R7,R9-R11,PC}  ;; return
   1709          
   1710          /**
   1711           * Directly set the planner XYZ position (and stepper positions)
   1712           * converting mm (or angles for SCARA) into steps.
   1713           *
   1714           * On CORE machines stepper ABC will be translated from the given XYZ.
   1715           */
   1716          

   \                                 In section .text, align 2, keep-with-next
   1717          void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   \                     _ZN7Planner16_set_position_mmERKfS1_S1_S1_: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   1718            #if ENABLED(DISTINCT_E_FACTORS)
   1719              #define _EINDEX (E_AXIS + active_extruder)
   1720              last_extruder = active_extruder;
   \   00000004   0x.... 0x....      LDR.W    R9,??DataTable18_14
   \   00000008   0x....             LDR.N    R4,??DataTable18_8
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   00000010   0x70A1             STRB     R1,[R4, #+2]
   \   00000012   0xB084             SUB      SP,SP,#+16
   1721            #else
   1722              #define _EINDEX E_AXIS
   1723            #endif
   1724            const int32_t na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x4692             MOV      R10,R2
   \   0000001A   0x4698             MOV      R8,R3
   \   0000001C   0x.... 0x....      BL       __aeabi_fmul
   \   00000020   0x.... 0x....      BL       lroundf
   \   00000024   0x4607             MOV      R7,R0
   \   00000026   0x6427             STR      R7,[R4, #+64]
   1725                          nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
   \   00000028   0x6829             LDR      R1,[R5, #+0]
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x.... 0x....      BL       __aeabi_fmul
   \   00000030   0x.... 0x....      BL       lroundf
   \   00000034   0x4606             MOV      R6,R0
   \   00000036   0x6466             STR      R6,[R4, #+68]
   1726                          nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
   \   00000038   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   0000003C   0x68E0             LDR      R0,[R4, #+12]
   \   0000003E   0x.... 0x....      BL       __aeabi_fmul
   \   00000042   0x.... 0x....      BL       lroundf
   \   00000046   0x4605             MOV      R5,R0
   1727                          ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   \   00000048   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000004C   0x64A5             STR      R5,[R4, #+72]
   \   0000004E   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000052   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   00000056   0x6900             LDR      R0,[R0, #+16]
   \   00000058   0x.... 0x....      BL       __aeabi_fmul
   \   0000005C   0x.... 0x....      BL       lroundf
   \   00000060   0x64E0             STR      R0,[R4, #+76]
   1728            #if ENABLED(LIN_ADVANCE)
   1729              position_float[X_AXIS] = a;
   1730              position_float[Y_AXIS] = b;
   1731              //position_float[Z_AXIS] = c;
   1732              position_float[E_AXIS] = e;
   1733            #endif
   1734            stepper.set_position(na, nb, nc, ne);
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x9703             STR      R7,[SP, #+12]
   \   00000066   0x9602             STR      R6,[SP, #+8]
   \   00000068   0x9501             STR      R5,[SP, #+4]
   \   0000006A   0xAB00             ADD      R3,SP,#+0
   \   0000006C   0xAA01             ADD      R2,SP,#+4
   \   0000006E   0xA902             ADD      R1,SP,#+8
   \   00000070   0xA803             ADD      R0,SP,#+12
   \   00000072   0x.... 0x....      BL       _ZN7Stepper12set_positionERKlS1_S1_S1_
   1735            previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x67A0             STR      R0,[R4, #+120]
   1736            ZERO(previous_speed);
   \   0000007A   0x2110             MOVS     R1,#+16
   \   0000007C   0xF104 0x0068      ADD      R0,R4,#+104
   \   00000080   0x.... 0x....      BL       __aeabi_memclr
   1737          }
   \   00000084   0xB004             ADD      SP,SP,#+16
   \   00000086   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1738          

   \                                 In section .text, align 2, keep-with-next
   1739          void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
   \                     _ZN7Planner25set_position_mm_kinematicERA4_Kf: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB085             SUB      SP,SP,#+20
   1740          	/*
   1741            #if PLANNER_LEVELING
   1742              float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
   1743              apply_leveling(raw);
   1744            #else
   1745              const float (&raw)[XYZE] = cart;
   1746            #endif
   1747          */
   1748            float raw[NUM_AXIS];
   1749            if(BED_LEVELING_METHOD&PLANNER_LEVELING)	{
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x....             LDR.N    R5,??DataTable18_10
   \   0000000A   0xF895 0x2042      LDRB     R2,[R5, #+66]
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0x6048             STR      R0,[R1, #+4]
   \   00000016   0x232E             MOVS     R3,#+46
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0x6088             STR      R0,[R1, #+8]
   \   0000001C   0x421A             TST      R2,R3
   \   0000001E   0xD005             BEQ.N    ??set_position_mm_kinematic_0
   1750            	raw[0] = cart[X_AXIS];
   1751            	raw[1] = cart[Y_AXIS];
   1752            	raw[2] = cart[Z_AXIS];
   1753          	apply_leveling(raw[0],raw[1],raw[2]);
   \   00000020   0xAA02             ADD      R2,SP,#+8
   \   00000022   0xA901             ADD      R1,SP,#+4
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   \   0000002A   0xE001             B.N      ??set_position_mm_kinematic_1
   1754            	}
   1755            else
   1756            	{
   1757          	  raw[0] = cart[X_AXIS];
   1758          	  raw[1] = cart[Y_AXIS];
   1759          	  raw[2] = cart[Z_AXIS];
   1760          	  raw[3] = cart[3];
   \                     ??set_position_mm_kinematic_0: (+1)
   \   0000002C   0x68E0             LDR      R0,[R4, #+12]
   \   0000002E   0x60C8             STR      R0,[R1, #+12]
   \                     ??set_position_mm_kinematic_1: (+1)
   \   00000030   0xF105 0x0042      ADD      R0,R5,#+66
   \   00000034   0xF240 0x3102      MOVW     R1,#+770
   \   00000038   0xF9B0 0x0016      LDRSH    R0,[R0, #+22]
   \   0000003C   0x4208             TST      R0,R1
   \   0000003E   0xD012             BEQ.N    ??set_position_mm_kinematic_2
   1761            	}
   1762            /*
   1763            #if IS_KINEMATIC
   1764              inverse_kinematics(raw);
   1765              _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS]);
   1766            #else
   1767              _set_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS]);
   1768            #endif
   1769            */
   1770            if(MACHINETPYE & IS_KINEMATIC)
   1771            	{
   1772            	
   1773          	if(MACHINETPYE == MORGAN_SCARA)
   \   00000040   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000044   0xA800             ADD      R0,SP,#+0
   \   00000046   0xD102             BNE.N    ??set_position_mm_kinematic_3
   1774          	  inverse_kinematics_MORGAN_SCARA(raw);
   \   00000048   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \   0000004C   0xE001             B.N      ??set_position_mm_kinematic_4
   1775          	else
   1776          	  inverse_kinematics(raw);
   \                     ??set_position_mm_kinematic_3: (+1)
   \   0000004E   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   1777          	  
   1778          	  _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS]);
   \                     ??set_position_mm_kinematic_4: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable18_15
   \   00000054   0xF104 0x030C      ADD      R3,R4,#+12
   \   00000058   0xF100 0x0208      ADD      R2,R0,#+8
   \   0000005C   0x1D01             ADDS     R1,R0,#+4
   \   0000005E   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   1779            	}
   1780            else
   1781            	{
   1782          	  _set_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS]);
   1783            	}  
   1784          }
   \   00000062   0xB005             ADD      SP,SP,#+20
   \   00000064   0xBD30             POP      {R4,R5,PC}
   \                     ??set_position_mm_kinematic_2: (+1)
   \   00000066   0xF104 0x030C      ADD      R3,R4,#+12
   \   0000006A   0xAA02             ADD      R2,SP,#+8
   \   0000006C   0xA901             ADD      R1,SP,#+4
   \   0000006E   0xA800             ADD      R0,SP,#+0
   \   00000070   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   \   00000074   0xB005             ADD      SP,SP,#+20
   \   00000076   0xBD30             POP      {R4,R5,PC}       ;; return
   1785          
   1786          /**
   1787           * Sync from the stepper positions. (e.g., after an interrupted move)
   1788           */

   \                                 In section .text, align 2, keep-with-next
   1789          void Planner::sync_from_steppers() {
   \                     _ZN7Planner18sync_from_steppersEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1790            LOOP_XYZE(i) {
   1791              position[i] = stepper.position((AxisEnum)i);
   \   00000002   0x....             LDR.N    R4,??DataTable18_8
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       _ZN7Stepper8positionE8AxisEnum
   \   0000000A   0x6420             STR      R0,[R4, #+64]
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       _ZN7Stepper8positionE8AxisEnum
   \   00000012   0x6460             STR      R0,[R4, #+68]
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x.... 0x....      BL       _ZN7Stepper8positionE8AxisEnum
   \   0000001A   0x64A0             STR      R0,[R4, #+72]
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x.... 0x....      BL       _ZN7Stepper8positionE8AxisEnum
   \   00000022   0x64E0             STR      R0,[R4, #+76]
   1792              #if ENABLED(LIN_ADVANCE)
   1793                position_float[i] = position[i] * steps_to_mm[i
   1794                  #if ENABLED(DISTINCT_E_FACTORS)
   1795                    + (i == E_AXIS ? active_extruder : 0)
   1796                  #endif
   1797                ];
   1798              #endif
   1799            }
   1800          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1801          
   1802          /**
   1803           * Setters for planner position (also setting stepper position).
   1804           */

   \                                 In section .text, align 2, keep-with-next
   1805          void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   \                     _ZN7Planner15set_position_mmE8AxisEnumRKf: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
   1806            #if ENABLED(DISTINCT_E_FACTORS)
   1807              const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
   \   00000006   0x....             LDR.N    R0,??DataTable18_14
   \   00000008   0xF99D 0x1008      LDRSB    R1,[SP, #+8]
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2903             CMP      R1,#+3
   \   00000010   0xBF0C             ITE      EQ 
   \   00000012   0x4602             MOVEQ    R2,R0
   \   00000014   0x2200             MOVNE    R2,#+0
   1808              last_extruder = active_extruder;
   \   00000016   0x....             LDR.N    R5,??DataTable18_8
   \   00000018   0x70A8             STRB     R0,[R5, #+2]
   1809            #else
   1810              const uint8_t axis_index = axis;
   1811            #endif
   1812            position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
   \   0000001A   0xF99D 0x0008      LDRSB    R0,[SP, #+8]
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x1810             ADDS     R0,R2,R0
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x.... 0x....      BL       __aeabi_fmul
   \   0000002E   0x.... 0x....      BL       lroundf
   \   00000032   0xF99D 0x1008      LDRSB    R1,[SP, #+8]
   \   00000036   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \   0000003A   0x6408             STR      R0,[R1, #+64]
   1813            #if ENABLED(LIN_ADVANCE)
   1814              position_float[axis] = v;
   1815            #endif
   1816            stepper.set_position(axis, v);
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0xA802             ADD      R0,SP,#+8
   \   00000048   0x.... 0x....      BL       _ZN7Stepper12set_positionERK8AxisEnumRKl
   1817            previous_speed[axis] = 0.0;
   \   0000004C   0xF99D 0x1008      LDRSB    R1,[SP, #+8]
   \   00000050   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x6688             STR      R0,[R1, #+104]
   1818          }
   \   00000058   0xB003             ADD      SP,SP,#+12
   \   0000005A   0xBD30             POP      {R4,R5,PC}       ;; return
   1819          
   1820          // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2

   \                                 In section .text, align 2, keep-with-next
   1821          void Planner::reset_acceleration_rates() {
   \                     _ZN7Planner24reset_acceleration_ratesEv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   1822            #if ENABLED(DISTINCT_E_FACTORS)
   1823              #define HIGHEST_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   1824            #else
   1825              #define HIGHEST_CONDITION true
   1826            #endif
   1827            uint32_t highest_rate = 1;
   1828            LOOP_XYZE_N(i) {
   \   00000004   0x....             LDR.N    R6,??DataTable18_8
   \   00000006   0x.... 0x....      LDR.W    R8,??DataTable18_16
   \   0000000A   0xF04F 0x0901      MOV      R9,#+1
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xF106 0x072C      ADD      R7,R6,#+44
   \   00000014   0x1D34             ADDS     R4,R6,#+4
   1829              max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
                                                      ^
Warning[Pa093]: implicit conversion from floating point to integer

      FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
                                                   ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.h",294  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

      static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
                                    ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.h",549  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   \                     ??reset_acceleration_rates_0: (+1)
   \   00000016   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x.... 0x....      BL       __aeabi_fmul
   \   00000024   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000028   0x6038             STR      R0,[R7, #+0]
   1830              if (HIGHEST_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   \   0000002A   0x2D03             CMP      R5,#+3
   \   0000002C   0xDB04             BLT.N    ??reset_acceleration_rates_1
   \   0000002E   0x....             LDR.N    R1,??DataTable18_14
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0x1CC9             ADDS     R1,R1,#+3
   \   00000034   0x428D             CMP      R5,R1
   \   00000036   0xD102             BNE.N    ??reset_acceleration_rates_2
   \                     ??reset_acceleration_rates_1: (+1)
   \   00000038   0x4581             CMP      R9,R0
   \   0000003A   0xBF38             IT       CC 
   \   0000003C   0x4681             MOVCC    R9,R0
   1831            }
   \                     ??reset_acceleration_rates_2: (+1)
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
   \   00000040   0x1D24             ADDS     R4,R4,#+4
   \   00000042   0x1D3F             ADDS     R7,R7,#+4
   \   00000044   0xF108 0x0804      ADD      R8,R8,#+4
   \   00000048   0x2D05             CMP      R5,#+5
   \   0000004A   0xDBE4             BLT.N    ??reset_acceleration_rates_0
   1832            cutoff_long = 4294967295UL / highest_rate;
   \   0000004C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000050   0xFBB0 0xF0F9      UDIV     R0,R0,R9
   \   00000054   0x6670             STR      R0,[R6, #+100]
   1833          }
   \   00000056   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1834          
   1835          // Recalculate position, steps_to_mm if axis_steps_per_mm changes!

   \                                 In section .text, align 2, keep-with-next
   1836          void Planner::refresh_positioning() {
   \                     _ZN7Planner19refresh_positioningEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1837            LOOP_XYZE_N(i) steps_to_mm[i] = 1.0 / axis_steps_per_mm[i];
   \   00000002   0x....             LDR.N    R4,??DataTable18_8
   \   00000004   0x6861             LDR      R1,[R4, #+4]
   \   00000006   0xF04F 0x507E      MOV      R0,#+1065353216
   \   0000000A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000000E   0x61A0             STR      R0,[R4, #+24]
   \   00000010   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000014   0x68A1             LDR      R1,[R4, #+8]
   \   00000016   0x.... 0x....      BL       __aeabi_fdiv
   \   0000001A   0x68E1             LDR      R1,[R4, #+12]
   \   0000001C   0x61E0             STR      R0,[R4, #+28]
   \   0000001E   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000022   0x.... 0x....      BL       __aeabi_fdiv
   \   00000026   0x6220             STR      R0,[R4, #+32]
   \   00000028   0xF04F 0x507E      MOV      R0,#+1065353216
   \   0000002C   0x6921             LDR      R1,[R4, #+16]
   \   0000002E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000032   0x6961             LDR      R1,[R4, #+20]
   \   00000034   0x6260             STR      R0,[R4, #+36]
   \   00000036   0xF04F 0x507E      MOV      R0,#+1065353216
   \   0000003A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000003E   0x62A0             STR      R0,[R4, #+40]
   1838            set_position_mm_kinematic(current_position);
   \   00000040   0x....             LDR.N    R0,??DataTable18_17
   \   00000042   0x.... 0x....      BL       _ZN7Planner25set_position_mm_kinematicERA4_Kf
   1839            reset_acceleration_rates();
   \   00000046   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004A   0x....             B.N      _ZN7Planner24reset_acceleration_ratesEv
   1840          }
   1841          
   1842          #if ENABLED(AUTOTEMP)
   1843          

   \                                 In section .text, align 2, keep-with-next
   1844            void Planner::autotemp_M104_M109() {
   \                     _ZN7Planner18autotemp_M104_M109Ev: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1845              autotemp_enabled = parser.seen('F');
   \   00000002   0x....             LDR.N    R4,??DataTable18_18
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x0940             LSRS     R0,R0,#+5
   \   00000008   0xF010 0x0101      ANDS     R1,R0,#0x1
   \   0000000C   0xD007             BEQ.N    ??autotemp_M104_M109_0
   \   0000000E   0x....             LDR.N    R0,??DataTable18_19
   \   00000010   0x7942             LDRB     R2,[R0, #+5]
   \   00000012   0x....             LDR.N    R0,??DataTable18_20
   \   00000014   0xB112             CBZ.N    R2,??autotemp_M104_M109_1
   \   00000016   0x....             LDR.N    R3,??DataTable18_21
   \   00000018   0x681B             LDR      R3,[R3, #+0]
   \   0000001A   0x18D2             ADDS     R2,R2,R3
   \                     ??autotemp_M104_M109_1: (+1)
   \   0000001C   0x6002             STR      R2,[R0, #+0]
   \                     ??autotemp_M104_M109_0: (+1)
   \   0000001E   0x....             LDR.N    R5,??DataTable18_8
   \   00000020   0x70E9             STRB     R1,[R5, #+3]
   1846              if (autotemp_enabled) autotemp_factor = parser.value_celsius_diff();
   \   00000022   0x0008             MOVS     R0,R1
   \   00000024   0xD002             BEQ.N    ??autotemp_M104_M109_2
   \   00000026   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   0000002A   0x6628             STR      R0,[R5, #+96]
   1847              if (parser.seen('S')) autotemp_min = parser.value_celsius();
   \                     ??autotemp_M104_M109_2: (+1)
   \   0000002C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000002E   0x0740             LSLS     R0,R0,#+29
   \   00000030   0xD50A             BPL.N    ??autotemp_M104_M109_3
   \   00000032   0x....             LDR.N    R0,??DataTable18_19
   \   00000034   0x7C81             LDRB     R1,[R0, #+18]
   \   00000036   0x....             LDR.N    R0,??DataTable18_20
   \   00000038   0xB111             CBZ.N    R1,??autotemp_M104_M109_4
   \   0000003A   0x....             LDR.N    R2,??DataTable18_21
   \   0000003C   0x6812             LDR      R2,[R2, #+0]
   \   0000003E   0x1889             ADDS     R1,R1,R2
   \                     ??autotemp_M104_M109_4: (+1)
   \   00000040   0x6001             STR      R1,[R0, #+0]
   \   00000042   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000046   0x65E8             STR      R0,[R5, #+92]
   1848              if (parser.seen('B')) autotemp_max = parser.value_celsius();
   \                     ??autotemp_M104_M109_3: (+1)
   \   00000048   0x7820             LDRB     R0,[R4, #+0]
   \   0000004A   0x0780             LSLS     R0,R0,#+30
   \   0000004C   0xD50A             BPL.N    ??autotemp_M104_M109_5
   \   0000004E   0x....             LDR.N    R0,??DataTable18_19
   \   00000050   0x7841             LDRB     R1,[R0, #+1]
   \   00000052   0x....             LDR.N    R0,??DataTable18_20
   \   00000054   0xB111             CBZ.N    R1,??autotemp_M104_M109_6
   \   00000056   0x....             LDR.N    R2,??DataTable18_21
   \   00000058   0x6812             LDR      R2,[R2, #+0]
   \   0000005A   0x1889             ADDS     R1,R1,R2
   \                     ??autotemp_M104_M109_6: (+1)
   \   0000005C   0x6001             STR      R1,[R0, #+0]
   \   0000005E   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000062   0x65A8             STR      R0,[R5, #+88]
   1849            }
   \                     ??autotemp_M104_M109_5: (+1)
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " cold extrusion preve...">`:
   \   00000000   0x20 0x63          DC8 " cold extrusion prevented\012"
   \              0x6F 0x6C    
   \              0x64 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " too long extrusion p...">`:
   \   00000000   0x20 0x74          DC8 " too long extrusion prevented\012"
   \              0x6F 0x6F    
   \              0x20 0x6C    
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Planner::subobject Planner()
   \                     _ZN7PlannerC2Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x....             B.N      ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable10
   \   00000008   0x1D20             ADDS     R0,R4,#+4
   \   0000000A   0x.... 0x....      BL       _ZN7Planner4initEv
   \   0000000E   0x2700             MOVS     R7,#+0
   \   00000010   0x.... 0x....      LDR.W    R9,??DataTable10_1  ;; 0x3ff80000
   \   00000014   0x.... 0x....      LDR.W    R8,??DataTable10_2  ;; 0x3ff00000
   \   00000018   0x2502             MOVS     R5,#+2
   \   0000001A   0x2600             MOVS     R6,#+0
   \   0000001C   0xE007             B.N      ??__sti__routine_0
   \                     ??__sti__routine_1: (+1)
   \   0000001E   0x4638             MOV      R0,R7
   \   00000020   0x4649             MOV      R1,R9
   \   00000022   0x463A             MOV      R2,R7
   \   00000024   0x464B             MOV      R3,R9
   \   00000026   0x.... 0x....      BL       __aeabi_dmul
   \   0000002A   0x4607             MOV      R7,R0
   \   0000002C   0x4689             MOV      R9,R1
   \                     ??__sti__routine_0: (+1)
   \   0000002E   0x07E8             LSLS     R0,R5,#+31
   \   00000030   0xD507             BPL.N    ??__sti__routine_2
   \   00000032   0x463A             MOV      R2,R7
   \   00000034   0x464B             MOV      R3,R9
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x4641             MOV      R1,R8
   \   0000003A   0x.... 0x....      BL       __aeabi_dmul
   \   0000003E   0x4606             MOV      R6,R0
   \   00000040   0x4688             MOV      R8,R1
   \                     ??__sti__routine_2: (+1)
   \   00000042   0x086D             LSRS     R5,R5,#+1
   \   00000044   0xD1EB             BNE.N    ??__sti__routine_1
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x54442d18
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x400921fb
   \   0000004E   0x4632             MOV      R2,R6
   \   00000050   0x4643             MOV      R3,R8
   \   00000052   0x.... 0x....      BL       __aeabi_dmul
   \   00000056   0x.... 0x....      BL       __aeabi_d2f
   \   0000005A   0x6020             STR      R0,[R4, #+0]
   \   0000005C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     _ZN7Planner23volumetric_area_nominalE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x3FF80000         DC32     0x3ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     _ZN7Planner16bed_level_matrixE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x3FA99999         DC32     0x3fa99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x47AE1480         DC32     0x47ae1480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x3F947AE1         DC32     0x3f947ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0xF5C28F5C         DC32     0xf5c28f5c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x3FEF5C28         DC32     0x3fef5c28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x........         DC32     _ZN7Planner15flow_percentageE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_headE+0x50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0x........         DC32     _ZN11GCodeParser18volumetric_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   0x47AE147B         DC32     0x47ae147b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   0x3F847AE1         DC32     0x3f847ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_21:
   \   00000000   0x........         DC32     _ZN7Planner15leveling_activeE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_22:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     _ZN11Temperature18allow_cold_extrudeE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     _ZN11Temperature16extrude_min_tempE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     `?<Constant " cold extrusion preve...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     `?<Constant " too long extrusion p...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     fanSpeeds

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     mksCfg+0x101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     _ZN7Planner23g_uc_extruder_last_moveE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x412E8480         DC32     0x412e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0xA0B5ED8D         DC32     0xa0b5ed8d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x4020C6F7         DC32     0x4020c6f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x........         DC32     _ZN7Planner23g_uc_extruder_last_moveE+0x2C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x358637BE         DC32     0x358637be

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x3F7D70A4         DC32     0x3f7d70a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x3D4CCCCD         DC32     0x3d4ccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \   00000000   0x........         DC32     marlin_debug_flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \   00000000   0x........         DC32     htim2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \   00000000   0x........         DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_14:
   \   00000000   0x........         DC32     active_extruder

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_15:
   \   00000000   0x........         DC32     delta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_16:
   \   00000000   0x........         DC32     _ZN7Planner26max_acceleration_mm_per_s2E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_17:
   \   00000000   0x........         DC32     current_position

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_18:
   \   00000000   0x........         DC32     _ZN11GCodeParser8codebitsE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_19:
   \   00000000   0x........         DC32     _ZN11GCodeParser5paramE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_20:
   \   00000000   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_21:
   \   00000000   0x........         DC32     _ZN11GCodeParser11command_ptrE
   1850          
   1851          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GCodeParser::value_float()
         0   -> __aeabi_d2f
        16   -> __iar_Stod
       0   Planner::Planner()
         8   -> Planner::init()
     120   Planner::_buffer_steps(signed int const (&)[4], float, uint8_t)
       120   -> HAL_GPIO_WritePin
       120   -> Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
       120   -> Planner::forward_pass()
       120   -> Planner::recalculate_trapezoids()
       120   -> Planner::reverse_pass()
       120   -> USARTClass::write(uint8_t)
       120   -> __aeabi_cfcmple
       120   -> __aeabi_cfrcmple
       120   -> __aeabi_d2f
       120   -> __aeabi_d2iz
       120   -> __aeabi_dadd
       120   -> __aeabi_ddiv
       120   -> __aeabi_dmul
       120   -> __aeabi_f2d
       120   -> __aeabi_f2iz
       120   -> __aeabi_f2uiz
       120   -> __aeabi_fadd
       120   -> __aeabi_fdiv
       120   -> __aeabi_fmul
       120   -> __aeabi_fsub
       120   -> __aeabi_i2f
       120   -> __aeabi_memcpy4
       120   -> __aeabi_ui2d
       120   -> __aeabi_ui2f
       120   -> ceilf
       120   -> idle()
       120   -> lround
       120   -> sqrtf
      48   Planner::_set_position_mm(float const &, float const &, float const &, float const &)
        48   -> Stepper::set_position(long const &, long const &, long const &, long const &)
        48   -> __aeabi_fmul
        48   -> __aeabi_memclr
        48   -> lroundf
      72   Planner::apply_leveling(float &, float &, float &)
        56   -> __aeabi_fadd
        56   -> __aeabi_fmul
        72   -> __aeabi_memcpy4
        56   -> apply_rotation_xyz(matrix_3x3, float &, float &, float &)
        56   -> bilinear_z_offset(float const *)
        56   -> mesh_bed_leveling::get_z(float const &, float const &, float const &)
        56   -> unified_bed_leveling::get_z_correction(float const &, float const &)
      16   Planner::autotemp_M104_M109()
        16   -> GCodeParser::value_float()
      80   Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
        80   -> HAL_TIM_Base_Start_IT
        80   -> HAL_TIM_Base_Stop_IT
        80   -> Planner::_buffer_steps(signed int const (&)[4], float, uint8_t)
        80   -> Stepper::wake_up()
        80   -> __aeabi_cfcmpeq
        80   -> __aeabi_cfcmple
        80   -> __aeabi_fmul
        80   -> __aeabi_i2f
        80   -> lroundf
      56   Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
        56   -> __aeabi_cfcmpeq
        56   -> __aeabi_f2iz
        56   -> __aeabi_f2uiz
        56   -> __aeabi_fadd
        56   -> __aeabi_fdiv
        56   -> __aeabi_fmul
        56   -> __aeabi_fsub
        56   -> __aeabi_i2f
        56   -> __aeabi_ui2f
        56   -> ceilf
        56   -> floorf
      56   Planner::calculate_volumetric_multipliers()
        56   -> __aeabi_cfcmpeq
        56   -> __aeabi_d2f
        56   -> __aeabi_ddiv
        56   -> __aeabi_dmul
        56   -> __aeabi_f2d
        56   -> __aeabi_i2d
       0   Planner::check_axes_activity()
         0   -> Planner::getHighESpeed()
      32   Planner::forward_pass()
         0   -> Planner::forward_pass_kernel(block_t const *, block_t *)
        32   -> Planner::forward_pass_kernel(block_t const *, block_t *)
      40   Planner::forward_pass_kernel(block_t const *, block_t *)
        40   -> __aeabi_cfcmpeq
        40   -> __aeabi_cfcmple
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> sqrtf
      40   Planner::getHighESpeed()
         0   -> Temperature::start_watching_heater(uint8_t)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_d2f
        40   -> __aeabi_dadd
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_f2iz
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      16   Planner::init()
        16   -> __aeabi_memset4
         0   -> matrix_3x3::set_to_identity()
       8   Planner::recalculate()
         8   -> Planner::forward_pass()
         0   -> Planner::recalculate_trapezoids()
         8   -> Planner::reverse_pass()
      40   Planner::recalculate_trapezoids()
        40   -> Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
       8   Planner::refresh_positioning()
         0   -> Planner::reset_acceleration_rates()
         8   -> Planner::set_position_mm_kinematic(float const (&)[4])
         8   -> __aeabi_fdiv
      32   Planner::reset_acceleration_rates()
        32   -> __aeabi_f2uiz
        32   -> __aeabi_fmul
        32   -> __aeabi_ui2f
      24   Planner::reverse_pass()
        24   -> Planner::reverse_pass_kernel(block_t *, block_t const *)
      40   Planner::reverse_pass_kernel(block_t *, block_t const *)
        40   -> __aeabi_cfcmpeq
        40   -> __aeabi_cfcmple
        40   -> __aeabi_cfrcmple
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> sqrtf
      24   Planner::set_position_mm(AxisEnum, float const &)
        24   -> Stepper::set_position(AxisEnum const &, long const &)
        24   -> __aeabi_f2iz
        24   -> __aeabi_fmul
        24   -> lroundf
      32   Planner::set_position_mm_kinematic(float const (&)[4])
        32   -> Planner::_set_position_mm(float const &, float const &, float const &, float const &)
        32   -> Planner::apply_leveling(float &, float &, float &)
        32   -> inverse_kinematics(float const *)
        32   -> inverse_kinematics_MORGAN_SCARA(float const *)
       8   Planner::subobject Planner()
         8   -> Planner::init()
       8   Planner::sync_from_steppers()
         8   -> Stepper::position(AxisEnum)
     104   Planner::unapply_leveling(float *)
        88   -> __aeabi_fmul
        88   -> __aeabi_fsub
       100   -> __aeabi_memcpy4
       104   -> __aeabi_memcpy4
        88   -> apply_rotation_xyz(matrix_3x3, float &, float &, float &)
        88   -> bilinear_z_offset(float const *)
        88   -> matrix_3x3::transpose(matrix_3x3)
        88   -> mesh_bed_leveling::get_z(float const &, float const &, float const &)
        88   -> unified_bed_leveling::get_z_correction(float const &, float const &)
      32   __sti__routine()
        32   -> Planner::init()
        32   -> __aeabi_d2f
        32   -> __aeabi_dmul
      32   mesh_bed_leveling::cell_index_x(float const &)
        32   -> __aeabi_cfcmple
        32   -> __aeabi_d2iz
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32   -> __aeabi_ui2f
      32   mesh_bed_leveling::cell_index_y(float const &)
        32   -> __aeabi_cfcmple
        32   -> __aeabi_d2iz
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32   -> __aeabi_ui2f
      48   mesh_bed_leveling::get_z(float const &, float const &, float const &)
         0   -> __aeabi_fadd
        48   -> __aeabi_fadd
        48   -> __aeabi_fdiv
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> mesh_bed_leveling::cell_index_x(float const &)
        48   -> mesh_bed_leveling::cell_index_y(float const &)
      32   unified_bed_leveling::get_cell_index_x(float const &)
        32   -> __aeabi_cfcmple
        32   -> __aeabi_d2iz
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32   -> __aeabi_ui2f
      32   unified_bed_leveling::get_cell_index_y(float const &)
        32   -> __aeabi_cfcmple
        32   -> __aeabi_d2iz
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32   -> __aeabi_ui2f
      56   unified_bed_leveling::get_z_correction(float const &, float const &)
        56   -> __aeabi_fadd
        56   -> __aeabi_fdiv
        56   -> __aeabi_fmul
        56   -> __aeabi_fsub
        56   -> __iar_FDtest
        56   -> unified_bed_leveling::get_cell_index_x(float const &)
        56   -> unified_bed_leveling::get_cell_index_y(float const &)
        56   -> unified_bed_leveling::mesh_index_to_xpos(uint8_t)
        56   -> unified_bed_leveling::mesh_index_to_ypos(uint8_t)
      40   unified_bed_leveling::mesh_index_to_xpos(uint8_t)
        40   -> __aeabi_cfcmple
         0   -> __aeabi_fadd
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   unified_bed_leveling::mesh_index_to_ypos(uint8_t)
        40   -> __aeabi_cfcmple
         0   -> __aeabi_fadd
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      28  ?<Constant " cold extrusion preve...">
      32  ?<Constant " too long extrusion p...">
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_15
       4  ??DataTable18_16
       4  ??DataTable18_17
       4  ??DataTable18_18
       4  ??DataTable18_19
       4  ??DataTable18_2
       4  ??DataTable18_20
       4  ??DataTable18_21
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
      10  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
      76  GCodeParser::value_float()
       2  Planner::Planner()
    3514  Planner::_buffer_steps(signed int const (&)[4], float, uint8_t)
     138  Planner::_set_position_mm(float const &, float const &, float const &, float const &)
     172  Planner::apply_leveling(float &, float &, float &)
     102  Planner::autotemp_M104_M109()
      36  Planner::bed_level_matrix
    1344  Planner::block_buffer
     128  Planner::block_buffer_head
          Planner::block_buffer_tail
          Planner::last_extruder
          Planner::autotemp_enabled
          Planner::axis_steps_per_mm
          Planner::steps_to_mm
          Planner::max_acceleration_steps_per_s2
          Planner::position
          Planner::e_factor
          Planner::autotemp_max
          Planner::autotemp_min
          Planner::autotemp_factor
          Planner::cutoff_long
          Planner::previous_speed
          Planner::previous_nominal_speed
          oldt
     370  Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
     590  Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
     234  Planner::calculate_volumetric_multipliers()
      30  Planner::check_axes_activity()
      20  Planner::flow_percentage
          Planner::volumetric_multiplier
          Planner::filament_size
      58  Planner::forward_pass()
     218  Planner::forward_pass_kernel(block_t const *, block_t *)
      68  Planner::g_uc_extruder_last_move
          Planner::max_feedrate_mm_s
          Planner::min_segment_time_us
          Planner::min_feedrate_mm_s
          Planner::acceleration
          Planner::retract_acceleration
          Planner::travel_acceleration
          Planner::max_jerk
          Planner::min_travel_feedrate_mm_s
          previous_safe_speed
     250  Planner::getHighESpeed()
      54  Planner::init()
       4  Planner::inverse_z_fade_height
       4  Planner::last_fade_z
       1  Planner::leveling_active
      20  Planner::max_acceleration_mm_per_s2
      16  Planner::recalculate()
     176  Planner::recalculate_trapezoids()
      76  Planner::refresh_positioning()
      90  Planner::reset_acceleration_rates()
      84  Planner::reverse_pass()
     228  Planner::reverse_pass_kernel(block_t *, block_t const *)
      92  Planner::set_position_mm(AxisEnum, float const &)
     120  Planner::set_position_mm_kinematic(float const (&)[4])
       4  Planner::subobject Planner()
      38  Planner::sync_from_steppers()
     168  Planner::unapply_leveling(float *)
       8  Planner::volumetric_area_nominal
          planner
       4  Planner::z_fade_height
      96  __sti__routine()
     280  mesh_bed_leveling::cell_index_x(float const &)
     276  mesh_bed_leveling::cell_index_y(float const &)
     272  mesh_bed_leveling::get_z(float const &, float const &, float const &)
     280  unified_bed_leveling::get_cell_index_x(float const &)
     276  unified_bed_leveling::get_cell_index_y(float const &)
     352  unified_bed_leveling::get_z_correction(float const &, float const &)
     276  unified_bed_leveling::mesh_index_to_xpos(uint8_t)
     272  unified_bed_leveling::mesh_index_to_ypos(uint8_t)
       5  -- Other

 
 1 489 bytes in section .bss
   148 bytes in section .data
     4 bytes in section .init_array
    61 bytes in section .rodata
 9 542 bytes in section .text
 
 7 186 bytes of CODE  memory (+ 2 360 bytes shared)
    60 bytes of CONST memory (+     1 byte  shared)
 1 637 bytes of DATA  memory

Errors: none
Warnings: 53
