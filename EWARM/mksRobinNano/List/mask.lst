###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        13/Apr/2020  09:25:03
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\User\ui\QRENCODE\mask.c
#    Command line =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\User\ui\QRENCODE\mask.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        -lA
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/Multi_language\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/QRENCODE\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\..\Middlewares\GUI\
#        -Oh --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\mask.lst
#    Object file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\mask.o
#
###############################################################################

D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\User\ui\QRENCODE\mask.c
      1          /*
      2           * qrencode - QR Code encoder
      3           *
      4           * Masking.
      5           * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>
      6           *
      7           * This library is free software; you can redistribute it and/or
      8           * modify it under the terms of the GNU Lesser General Public
      9           * License as published by the Free Software Foundation; either
     10           * version 2.1 of the License, or any later version.
     11           *
     12           * This library is distributed in the hope that it will be useful,
     13           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     14           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     15           * Lesser General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU Lesser General Public
     18           * License along with this library; if not, write to the Free Software
     19           * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
     20           */
     21          
     22          #if HAVE_CONFIG_H
     23          # include "config.h"
     24          #endif
     25          #include <stdlib.h>
     26          #include <string.h>
     27          #include <limits.h>
     28          #include <errno.h>
     29          
     30          #include "qrencode.h"
     31          #include "qrspec.h"
     32          #include "mask.h"
     33          

   \                                 In section .text, align 2, keep-with-next
     34          static int Mask_writeFormatInformation(int width, unsigned char *frame, int mask, QRecLevel level)
     35          {
   \                     Mask_writeFormatInformation: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4610             MOV      R0,R2
   \   00000008   0x4619             MOV      R1,R3
     36          	unsigned int format;
     37          	unsigned char v;
     38          	int i;
     39          	int blacks = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
     40          
     41          	format = QRspec_getFormatInfo(mask, level);
   \   0000000C   0x.... 0x....      BL       QRspec_getFormatInfo
     42          
     43          	for(i=0; i<8; i++) {
   \   00000010   0xEB04 0x01C4      ADD      R1,R4,R4, LSL #+3
   \   00000014   0x1949             ADDS     R1,R1,R5
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x1E4B             SUBS     R3,R1,#+1
     44          		if(format & 1) {
   \                     ??Mask_writeFormatInformation_0: (+1)
   \   0000001A   0x07C1             LSLS     R1,R0,#+31
   \   0000001C   0xBF46             ITTE     MI 
     45          			blacks += 2;
   \   0000001E   0x1CB6             ADDMI    R6,R6,#+2
     46          			v = 0x85;
   \   00000020   0x2185             MOVMI    R1,#+133
     47          		} else {
     48          			v = 0x84;
   \   00000022   0x2184             MOVPL    R1,#+132
     49          		}
     50          		frame[width * 8 + width - 1 - i] = v;
     51          		if(i < 6) {
   \   00000024   0x1C57             ADDS     R7,R2,#+1
   \   00000026   0x7019             STRB     R1,[R3, #+0]
   \   00000028   0x2A06             CMP      R2,#+6
   \   0000002A   0xBFB4             ITE      LT 
     52          			frame[width * i + 8] = v;
   \   0000002C   0xFB02 0x5204      MLALT    R2,R2,R4,R5
     53          		} else {
     54          			frame[width * (i + 1) + 8] = v;
   \   00000030   0xFB07 0x5204      MLAGE    R2,R7,R4,R5
   \   00000034   0x7211             STRB     R1,[R2, #+8]
     55          		}
     56          		format= format >> 1;
   \   00000036   0x0840             LSRS     R0,R0,#+1
     57          	}
   \   00000038   0x463A             MOV      R2,R7
   \   0000003A   0x1E5B             SUBS     R3,R3,#+1
   \   0000003C   0x2A08             CMP      R2,#+8
   \   0000003E   0xDBEC             BLT.N    ??Mask_writeFormatInformation_0
     58          	for(i=0; i<7; i++) {
   \   00000040   0xEB05 0x03C4      ADD      R3,R5,R4, LSL #+3
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0xF203 0x0706      ADDW     R7,R3,#+6
     59          		if(format & 1) {
   \                     ??Mask_writeFormatInformation_1: (+1)
   \   0000004A   0x07C1             LSLS     R1,R0,#+31
   \   0000004C   0xBF46             ITTE     MI 
     60          			blacks += 2;
   \   0000004E   0x1CB6             ADDMI    R6,R6,#+2
     61          			v = 0x85;
   \   00000050   0x2185             MOVMI    R1,#+133
     62          		} else {
     63          			v = 0x84;
   \   00000052   0x2184             MOVPL    R1,#+132
     64          		}
     65          		frame[width * (width - 7 + i) + 8] = v;
   \   00000054   0xEB02 0x0C04      ADD      R12,R2,R4
   \   00000058   0xF1AC 0x0C07      SUB      R12,R12,#+7
   \   0000005C   0xFB0C 0x5C04      MLA      R12,R12,R4,R5
     66          		if(i == 0) {
   \   00000060   0x2A00             CMP      R2,#+0
   \   00000062   0xF88C 0x1008      STRB     R1,[R12, #+8]
   \   00000066   0xBF0C             ITE      EQ 
     67          			frame[width * 8 + 7] = v;
   \   00000068   0x71D9             STRBEQ   R1,[R3, #+7]
     68          		} else {
     69          			frame[width * 8 + 6 - i] = v;
   \   0000006A   0x7039             STRBNE   R1,[R7, #+0]
     70          		}
     71          		format= format >> 1;
   \   0000006C   0x0840             LSRS     R0,R0,#+1
     72          	}
   \   0000006E   0x1C52             ADDS     R2,R2,#+1
   \   00000070   0x1E7F             SUBS     R7,R7,#+1
   \   00000072   0x2A07             CMP      R2,#+7
   \   00000074   0xDBE9             BLT.N    ??Mask_writeFormatInformation_1
     73          
     74          	return blacks;
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     75          }
     76          
     77          /**
     78           * Demerit coefficients.
     79           * See Section 8.8.2, pp.45, JIS X0510:2004.
     80           */
     81          #define N1 (3)
     82          #define N2 (3)
     83          #define N3 (40)
     84          #define N4 (10)
     85          
     86          #define MASKMAKER(__exp__) \
     87          	int x, y;\
     88          	int b = 0;\
     89          \
     90          	for(y=0; y<width; y++) {\
     91          		for(x=0; x<width; x++) {\
     92          			if(*s & 0x80) {\
     93          				*d = *s;\
     94          			} else {\
     95          				*d = *s ^ ((__exp__) == 0);\
     96          			}\
     97          			b += (int)(*d & 1);\
     98          			s++; d++;\
     99          		}\
    100          	}\
    101          	return b;
    102          

   \                                 In section .text, align 2, keep-with-next
    103          static int Mask_mask0(int width, const unsigned char *s, unsigned char *d)
    104          {
   \                     Mask_mask0: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    105          	MASKMAKER((x+y)&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xDB18             BLT.N    ??Mask_mask0_0
   \                     ??Mask_mask0_1: (+1)
   \   0000000A   0x4625             MOV      R5,R4
   \   0000000C   0x4606             MOV      R6,R0
   \                     ??Mask_mask0_2: (+1)
   \   0000000E   0x780F             LDRB     R7,[R1, #+0]
   \   00000010   0xEA5F 0x6C07      LSLS     R12,R7,#+24
   \   00000014   0xD405             BMI.N    ??Mask_mask0_3
   \   00000016   0xF005 0x0C01      AND      R12,R5,#0x1
   \   0000001A   0xF08C 0x0C01      EOR      R12,R12,#0x1
   \   0000001E   0xEA8C 0x0707      EOR      R7,R12,R7
   \                     ??Mask_mask0_3: (+1)
   \   00000022   0x7017             STRB     R7,[R2, #+0]
   \   00000024   0x1C49             ADDS     R1,R1,#+1
   \   00000026   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   0000002A   0xF007 0x0701      AND      R7,R7,#0x1
   \   0000002E   0x18FB             ADDS     R3,R7,R3
   \   00000030   0x1C6D             ADDS     R5,R5,#+1
   \   00000032   0x1E76             SUBS     R6,R6,#+1
   \   00000034   0xD1EB             BNE.N    ??Mask_mask0_2
   \   00000036   0x1C64             ADDS     R4,R4,#+1
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xDBE6             BLT.N    ??Mask_mask0_1
   \                     ??Mask_mask0_0: (+1)
   \   0000003C   0x....             B.N      ?Subroutine0
    106          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xBCF0             POP      {R4-R7}
   \   00000002   0x4618             MOV      R0,R3
   \   00000004   0x4770             BX       LR               ;; return
    107          

   \                                 In section .text, align 2, keep-with-next
    108          static int Mask_mask1(int width, const unsigned char *s, unsigned char *d)
    109          {
   \                     Mask_mask1: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    110          	MASKMAKER(y&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xDB15             BLT.N    ??Mask_mask1_0
   \                     ??Mask_mask1_1: (+1)
   \   0000000A   0xF004 0x0601      AND      R6,R4,#0x1
   \   0000000E   0x4605             MOV      R5,R0
   \   00000010   0xF086 0x0601      EOR      R6,R6,#0x1
   \                     ??Mask_mask1_2: (+1)
   \   00000014   0x780F             LDRB     R7,[R1, #+0]
   \   00000016   0xEA5F 0x6C07      LSLS     R12,R7,#+24
   \   0000001A   0xBF58             IT       PL 
   \   0000001C   0x4077             EORPL    R7,R6,R7
   \   0000001E   0x7017             STRB     R7,[R2, #+0]
   \   00000020   0x1C49             ADDS     R1,R1,#+1
   \   00000022   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   00000026   0xF007 0x0701      AND      R7,R7,#0x1
   \   0000002A   0x18FB             ADDS     R3,R7,R3
   \   0000002C   0x1E6D             SUBS     R5,R5,#+1
   \   0000002E   0xD1F1             BNE.N    ??Mask_mask1_2
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xDBE9             BLT.N    ??Mask_mask1_1
   \                     ??Mask_mask1_0: (+1)
   \   00000036                      REQUIRE ?Subroutine0
   \   00000036                      ;; // Fall through to label ?Subroutine0
    111          }
    112          

   \                                 In section .text, align 2, keep-with-next
    113          static int Mask_mask2(int width, const unsigned char *s, unsigned char *d)
    114          {
   \                     Mask_mask2: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    115          	MASKMAKER(x%3)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xDB1C             BLT.N    ??Mask_mask2_0
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xE000             B.N      ??Mask_mask2_1
   \                     ??Mask_mask2_2: (+1)
   \   0000000E   0x2500             MOVS     R5,#+0
   \                     ??Mask_mask2_1: (+1)
   \   00000010   0x780E             LDRB     R6,[R1, #+0]
   \   00000012   0x0637             LSLS     R7,R6,#+24
   \   00000014   0xD409             BMI.N    ??Mask_mask2_3
   \   00000016   0x2703             MOVS     R7,#+3
   \   00000018   0xFB95 0xF7F7      SDIV     R7,R5,R7
   \   0000001C   0xEB07 0x0747      ADD      R7,R7,R7, LSL #+1
   \   00000020   0x1BEF             SUBS     R7,R5,R7
   \   00000022   0x1E7F             SUBS     R7,R7,#+1
   \   00000024   0x41BF             SBCS     R7,R7,R7
   \   00000026   0xEA86 0x76D7      EOR      R6,R6,R7, LSR #+31
   \                     ??Mask_mask2_3: (+1)
   \   0000002A   0x7016             STRB     R6,[R2, #+0]
   \   0000002C   0x1C49             ADDS     R1,R1,#+1
   \   0000002E   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   00000032   0xF006 0x0601      AND      R6,R6,#0x1
   \   00000036   0x18F3             ADDS     R3,R6,R3
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \   0000003A   0x4285             CMP      R5,R0
   \   0000003C   0xDBE8             BLT.N    ??Mask_mask2_1
   \   0000003E   0x1E64             SUBS     R4,R4,#+1
   \   00000040   0xD1E5             BNE.N    ??Mask_mask2_2
   \                     ??Mask_mask2_0: (+1)
   \   00000042   0x....             B.N      ?Subroutine0
    116          }
    117          

   \                                 In section .text, align 2, keep-with-next
    118          static int Mask_mask3(int width, const unsigned char *s, unsigned char *d)
    119          {
   \                     Mask_mask3: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    120          	MASKMAKER((x+y)%3)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xDB23             BLT.N    ??Mask_mask3_0
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xE000             B.N      ??Mask_mask3_1
   \                     ??Mask_mask3_2: (+1)
   \   0000000E   0x2500             MOVS     R5,#+0
   \                     ??Mask_mask3_1: (+1)
   \   00000010   0x4626             MOV      R6,R4
   \                     ??Mask_mask3_3: (+1)
   \   00000012   0x780F             LDRB     R7,[R1, #+0]
   \   00000014   0xEA5F 0x6C07      LSLS     R12,R7,#+24
   \   00000018   0xD40D             BMI.N    ??Mask_mask3_4
   \   0000001A   0xF04F 0x0C03      MOV      R12,#+3
   \   0000001E   0xFB96 0xFCFC      SDIV     R12,R6,R12
   \   00000022   0xEB0C 0x0C4C      ADD      R12,R12,R12, LSL #+1
   \   00000026   0xEBA6 0x0C0C      SUB      R12,R6,R12
   \   0000002A   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   0000002E   0xEB6C 0x0C0C      SBC      R12,R12,R12
   \   00000032   0xEA87 0x77DC      EOR      R7,R7,R12, LSR #+31
   \                     ??Mask_mask3_4: (+1)
   \   00000036   0x7017             STRB     R7,[R2, #+0]
   \   00000038   0x1C49             ADDS     R1,R1,#+1
   \   0000003A   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   0000003E   0xF007 0x0701      AND      R7,R7,#0x1
   \   00000042   0x18FB             ADDS     R3,R7,R3
   \   00000044   0x1C6D             ADDS     R5,R5,#+1
   \   00000046   0x1C76             ADDS     R6,R6,#+1
   \   00000048   0x4285             CMP      R5,R0
   \   0000004A   0xDBE2             BLT.N    ??Mask_mask3_3
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
   \   0000004E   0x4284             CMP      R4,R0
   \   00000050   0xDBDD             BLT.N    ??Mask_mask3_2
   \                     ??Mask_mask3_0: (+1)
   \   00000052   0x....             B.N      ?Subroutine0
    121          }
    122          

   \                                 In section .text, align 2, keep-with-next
    123          static int Mask_mask4(int width, const unsigned char *s, unsigned char *d)
    124          {
   \                     Mask_mask4: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    125          	MASKMAKER(((y/2)+(x/3))&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xDB1F             BLT.N    ??Mask_mask4_0
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xE000             B.N      ??Mask_mask4_1
   \                     ??Mask_mask4_2: (+1)
   \   0000000E   0x2500             MOVS     R5,#+0
   \                     ??Mask_mask4_1: (+1)
   \   00000010   0x780E             LDRB     R6,[R1, #+0]
   \   00000012   0x0637             LSLS     R7,R6,#+24
   \   00000014   0xD40C             BMI.N    ??Mask_mask4_3
   \   00000016   0xF04F 0x0C03      MOV      R12,#+3
   \   0000001A   0xEB04 0x77D4      ADD      R7,R4,R4, LSR #+31
   \   0000001E   0xFB95 0xFCFC      SDIV     R12,R5,R12
   \   00000022   0xEB0C 0x0767      ADD      R7,R12,R7, ASR #+1
   \   00000026   0xF007 0x0701      AND      R7,R7,#0x1
   \   0000002A   0xF087 0x0701      EOR      R7,R7,#0x1
   \   0000002E   0x407E             EORS     R6,R7,R6
   \                     ??Mask_mask4_3: (+1)
   \   00000030   0x7016             STRB     R6,[R2, #+0]
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \   00000034   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   00000038   0xF006 0x0601      AND      R6,R6,#0x1
   \   0000003C   0x18F3             ADDS     R3,R6,R3
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xDBE5             BLT.N    ??Mask_mask4_1
   \   00000044   0x1C64             ADDS     R4,R4,#+1
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xDBE1             BLT.N    ??Mask_mask4_2
   \                     ??Mask_mask4_0: (+1)
   \   0000004A   0x....             B.N      ?Subroutine0
    126          }
    127          

   \                                 In section .text, align 2, keep-with-next
    128          static int Mask_mask5(int width, const unsigned char *s, unsigned char *d)
    129          {
   \                     Mask_mask5: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    130          	MASKMAKER(((x*y)&1)+(x*y)%3)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xDB25             BLT.N    ??Mask_mask5_0
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xE000             B.N      ??Mask_mask5_1
   \                     ??Mask_mask5_2: (+1)
   \   0000000E   0x2500             MOVS     R5,#+0
   \                     ??Mask_mask5_1: (+1)
   \   00000010   0x4606             MOV      R6,R0
   \                     ??Mask_mask5_3: (+1)
   \   00000012   0x780F             LDRB     R7,[R1, #+0]
   \   00000014   0xEA5F 0x6C07      LSLS     R12,R7,#+24
   \   00000018   0xD410             BMI.N    ??Mask_mask5_4
   \   0000001A   0xF04F 0x0E03      MOV      LR,#+3
   \   0000001E   0xF005 0x0C01      AND      R12,R5,#0x1
   \   00000022   0xFB95 0xFEFE      SDIV     LR,R5,LR
   \   00000026   0x44AC             ADD      R12,R5,R12
   \   00000028   0xEB0E 0x0E4E      ADD      LR,LR,LR, LSL #+1
   \   0000002C   0xEBAC 0x0C0E      SUB      R12,R12,LR
   \   00000030   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   00000034   0xEB6C 0x0C0C      SBC      R12,R12,R12
   \   00000038   0xEA87 0x77DC      EOR      R7,R7,R12, LSR #+31
   \                     ??Mask_mask5_4: (+1)
   \   0000003C   0x7017             STRB     R7,[R2, #+0]
   \   0000003E   0x1C49             ADDS     R1,R1,#+1
   \   00000040   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   00000044   0xF007 0x0701      AND      R7,R7,#0x1
   \   00000048   0x18FB             ADDS     R3,R7,R3
   \   0000004A   0x1965             ADDS     R5,R4,R5
   \   0000004C   0x1E76             SUBS     R6,R6,#+1
   \   0000004E   0xD1E0             BNE.N    ??Mask_mask5_3
   \   00000050   0x1C64             ADDS     R4,R4,#+1
   \   00000052   0x4284             CMP      R4,R0
   \   00000054   0xDBDB             BLT.N    ??Mask_mask5_2
   \                     ??Mask_mask5_0: (+1)
   \   00000056   0x4618             MOV      R0,R3
   \   00000058   0xBDF0             POP      {R4-R7,PC}       ;; return
    131          }
    132          

   \                                 In section .text, align 2, keep-with-next
    133          static int Mask_mask6(int width, const unsigned char *s, unsigned char *d)
    134          {
   \                     Mask_mask6: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    135          	MASKMAKER((((x*y)&1)+(x*y)%3)&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xDB1E             BLT.N    ??Mask_mask6_0
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xE000             B.N      ??Mask_mask6_1
   \                     ??Mask_mask6_2: (+1)
   \   0000000E   0x2500             MOVS     R5,#+0
   \                     ??Mask_mask6_1: (+1)
   \   00000010   0x4606             MOV      R6,R0
   \                     ??Mask_mask6_3: (+1)
   \   00000012   0x780F             LDRB     R7,[R1, #+0]
   \   00000014   0xEA5F 0x6C07      LSLS     R12,R7,#+24
   \   00000018   0xD409             BMI.N    ??Mask_mask6_4
   \   0000001A   0xF06F 0x0C02      MVN      R12,#+2
   \   0000001E   0xFB95 0xFCFC      SDIV     R12,R5,R12
   \   00000022   0xF00C 0x0C01      AND      R12,R12,#0x1
   \   00000026   0xF08C 0x0C01      EOR      R12,R12,#0x1
   \   0000002A   0xEA8C 0x0707      EOR      R7,R12,R7
   \                     ??Mask_mask6_4: (+1)
   \   0000002E   0x7017             STRB     R7,[R2, #+0]
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \   00000032   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   00000036   0xF007 0x0701      AND      R7,R7,#0x1
   \   0000003A   0x18FB             ADDS     R3,R7,R3
   \   0000003C   0x1965             ADDS     R5,R4,R5
   \   0000003E   0x1E76             SUBS     R6,R6,#+1
   \   00000040   0xD1E7             BNE.N    ??Mask_mask6_3
   \   00000042   0x1C64             ADDS     R4,R4,#+1
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xDBE2             BLT.N    ??Mask_mask6_2
   \                     ??Mask_mask6_0: (+1)
   \   00000048   0x....             B.N      ?Subroutine0
    136          }
    137          

   \                                 In section .text, align 2, keep-with-next
    138          static int Mask_mask7(int width, const unsigned char *s, unsigned char *d)
    139          {
   \                     Mask_mask7: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    140          	MASKMAKER((((x*y)%3)+((x+y)&1))&1)
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xDB26             BLT.N    ??Mask_mask7_0
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0xE000             B.N      ??Mask_mask7_1
   \                     ??Mask_mask7_2: (+1)
   \   00000010   0x2500             MOVS     R5,#+0
   \                     ??Mask_mask7_1: (+1)
   \   00000012   0x4626             MOV      R6,R4
   \   00000014   0x4607             MOV      R7,R0
   \                     ??Mask_mask7_3: (+1)
   \   00000016   0xF891 0xC000      LDRB     R12,[R1, #+0]
   \   0000001A   0xEA5F 0x6E0C      LSLS     LR,R12,#+24
   \   0000001E   0xD40D             BMI.N    ??Mask_mask7_4
   \   00000020   0xF04F 0x0803      MOV      R8,#+3
   \   00000024   0xEB05 0x0E06      ADD      LR,R5,R6
   \   00000028   0xFB95 0xF8F8      SDIV     R8,R5,R8
   \   0000002C   0xEBAE 0x0E08      SUB      LR,LR,R8
   \   00000030   0xF00E 0x0E01      AND      LR,LR,#0x1
   \   00000034   0xF08E 0x0E01      EOR      LR,LR,#0x1
   \   00000038   0xEA8E 0x0C0C      EOR      R12,LR,R12
   \                     ??Mask_mask7_4: (+1)
   \   0000003C   0xF882 0xC000      STRB     R12,[R2, #+0]
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   \   00000042   0xF812 0xCB01      LDRB     R12,[R2], #+1
   \   00000046   0xF00C 0x0C01      AND      R12,R12,#0x1
   \   0000004A   0x1965             ADDS     R5,R4,R5
   \   0000004C   0x1C76             ADDS     R6,R6,#+1
   \   0000004E   0x4463             ADD      R3,R12,R3
   \   00000050   0x1E7F             SUBS     R7,R7,#+1
   \   00000052   0xD1E0             BNE.N    ??Mask_mask7_3
   \   00000054   0x1C64             ADDS     R4,R4,#+1
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xDBDA             BLT.N    ??Mask_mask7_2
   \                     ??Mask_mask7_0: (+1)
   \   0000005A   0x4618             MOV      R0,R3
   \   0000005C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    141          }
    142          
    143          #define maskNum (8)
    144          typedef int MaskMaker(int, const unsigned char *, unsigned char *);

   \                                 In section .data, align 4
    145          static MaskMaker *maskMakers[maskNum] = {
   \                     maskMakers:
   \   00000000   0x........         DC32 Mask_mask0, Mask_mask1, Mask_mask2, Mask_mask3, Mask_mask4
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000014   0x........         DC32 Mask_mask5, Mask_mask6, Mask_mask7
   \              0x........   
   \              0x........   
    146          	Mask_mask0, Mask_mask1, Mask_mask2, Mask_mask3,
    147          	Mask_mask4, Mask_mask5, Mask_mask6, Mask_mask7
    148          };
    149          
    150          #ifdef WITH_TESTS
    151          unsigned char *Mask_makeMaskedFrame(int width, unsigned char *frame, int mask)
    152          {
    153          	unsigned char *masked;
    154          
    155          	masked = (unsigned char *)malloc(width * width);
    156          	if(masked == NULL) return NULL;
    157          
    158          	maskMakers[mask](width, frame, masked);
    159          
    160          	return masked;
    161          }
    162          #endif
    163          

   \                                 In section .text, align 2, keep-with-next
    164          unsigned char *Mask_makeMask(int width, unsigned char *frame, int mask, QRecLevel level)
    165          {
   \                     Mask_makeMask: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4616             MOV      R6,R2
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x461F             MOV      R7,R3
    166          	unsigned char *masked;
    167          
    168          	if(mask < 0 || mask >= maskNum) {
   \   0000000C   0x2E08             CMP      R6,#+8
   \   0000000E   0xD307             BCC.N    ??Mask_makeMask_0
    169          		errno = EINVAL;
   \   00000010   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000014   0xF04F 0x31FF      MOV      R1,#-1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    170          		return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE8BD 0x81F0      POP      {R4-R8,PC}
    171          	}
    172          
    173          	masked = (unsigned char *)malloc(width * width);
   \                     ??Mask_makeMask_0: (+1)
   \   00000020   0xFB04 0xF004      MUL      R0,R4,R4
   \   00000024   0x.... 0x....      BL       malloc
   \   00000028   0xEA5F 0x0800      MOVS     R8,R0
    174          	if(masked == NULL) return NULL;
   \   0000002C   0xD00D             BEQ.N    ??Mask_makeMask_1
    175          
    176          	maskMakers[mask](width, frame, masked);
   \   0000002E   0x....             LDR.N    R3,??DataTable1
   \   00000030   0xF853 0x3026      LDR      R3,[R3, R6, LSL #+2]
   \   00000034   0x4642             MOV      R2,R8
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x4798             BLX      R3
    177          	Mask_writeFormatInformation(width, masked, mask, level);
   \   0000003C   0x463B             MOV      R3,R7
   \   0000003E   0x4632             MOV      R2,R6
   \   00000040   0x4641             MOV      R1,R8
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       Mask_writeFormatInformation
    178          
    179          	return masked;
   \   00000048   0x4640             MOV      R0,R8
   \                     ??Mask_makeMask_1: (+1)
   \   0000004A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    180          }
    181          
    182          
    183          //static int n1;
    184          //static int n2;
    185          //static int n3;
    186          //static int n4;
    187          

   \                                 In section .text, align 2, keep-with-next
    188          static int Mask_calcN1N3(int length, int *runLength)
    189          {
   \                     Mask_calcN1N3: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x460A             MOV      R2,R1
    190          	int i;
    191          	int demerit = 0;
   \   00000004   0x2100             MOVS     R1,#+0
    192          	int fact;
    193          
    194          	for(i=0; i<length; i++) {
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xDB30             BLT.N    ??Mask_calcN1N3_0
   \   0000000C   0x1E84             SUBS     R4,R0,#+2
    195          		if(runLength[i] >= 5) {
   \                     ??Mask_calcN1N3_1: (+1)
   \   0000000E   0x6815             LDR      R5,[R2, #+0]
   \   00000010   0x2D05             CMP      R5,#+5
   \   00000012   0xBFA4             ITT      GE 
    196          			demerit += N1 + (runLength[i] - 5);
   \   00000014   0x1EAE             SUBGE    R6,R5,#+2
   \   00000016   0x1871             ADDGE    R1,R6,R1
    197          			//n1 += N1 + (runLength[i] - 5);
    198          		}
    199          		if((i & 1)) {
   \   00000018   0x07DE             LSLS     R6,R3,#+31
   \   0000001A   0xD524             BPL.N    ??Mask_calcN1N3_2
    200          			if(i >= 3 && i < length-2 && (runLength[i] % 3) == 0) {
   \   0000001C   0x2B03             CMP      R3,#+3
   \   0000001E   0xDB22             BLT.N    ??Mask_calcN1N3_2
   \   00000020   0x42A3             CMP      R3,R4
   \   00000022   0xDA20             BGE.N    ??Mask_calcN1N3_2
   \   00000024   0x2603             MOVS     R6,#+3
   \   00000026   0xFB95 0xF6F6      SDIV     R6,R5,R6
   \   0000002A   0xEB06 0x0746      ADD      R7,R6,R6, LSL #+1
   \   0000002E   0x1BED             SUBS     R5,R5,R7
   \   00000030   0xBF04             ITT      EQ 
    201          				fact = runLength[i] / 3;
    202          				if(runLength[i-2] == fact &&
    203          				   runLength[i-1] == fact &&
    204          				   runLength[i+1] == fact &&
    205          				   runLength[i+2] == fact) {
   \   00000032   0xF852 0x5C08      LDREQ    R5,[R2, #-8]
   \   00000036   0x42B5             CMPEQ    R5,R6
   \   00000038   0xD115             BNE.N    ??Mask_calcN1N3_2
   \   0000003A   0xF852 0x5C04      LDR      R5,[R2, #-4]
   \   0000003E   0x42B5             CMP      R5,R6
   \   00000040   0xBF01             ITTTT    EQ 
   \   00000042   0x6855             LDREQ    R5,[R2, #+4]
   \   00000044   0x42B5             CMPEQ    R5,R6
   \   00000046   0x6895             LDREQ    R5,[R2, #+8]
   \   00000048   0x42B5             CMPEQ    R5,R6
   \   0000004A   0xD10C             BNE.N    ??Mask_calcN1N3_2
    206          					if(i == 3 || runLength[i-3] >= 4 * fact) {
   \   0000004C   0x2B03             CMP      R3,#+3
   \   0000004E   0xD009             BEQ.N    ??Mask_calcN1N3_3
   \   00000050   0x00B5             LSLS     R5,R6,#+2
   \   00000052   0xF852 0x6C0C      LDR      R6,[R2, #-12]
   \   00000056   0x42AE             CMP      R6,R5
   \   00000058   0xBFBF             ITTTT    LT 
    207          						demerit += N3;
    208          						//n3 += N3;
    209          					} else if(i+4 >= length || runLength[i+3] >= 4 * fact) {
   \   0000005A   0x1D1E             ADDLT    R6,R3,#+4
   \   0000005C   0x4286             CMPLT    R6,R0
   \   0000005E   0x68D6             LDRLT    R6,[R2, #+12]
   \   00000060   0x42AE             CMPLT    R6,R5
   \   00000062   0xDB00             BLT.N    ??Mask_calcN1N3_2
    210          						demerit += N3;
   \                     ??Mask_calcN1N3_3: (+1)
   \   00000064   0x3128             ADDS     R1,R1,#+40
    211          						//n3 += N3;
    212          					}
    213          				}
    214          			}
    215          		}
    216          	}
   \                     ??Mask_calcN1N3_2: (+1)
   \   00000066   0x1C5B             ADDS     R3,R3,#+1
   \   00000068   0x1D12             ADDS     R2,R2,#+4
   \   0000006A   0x4283             CMP      R3,R0
   \   0000006C   0xDBCF             BLT.N    ??Mask_calcN1N3_1
    217          
    218          	return demerit;
   \                     ??Mask_calcN1N3_0: (+1)
   \   0000006E   0xBCF0             POP      {R4-R7}
   \   00000070   0x4608             MOV      R0,R1
   \   00000072   0x4770             BX       LR               ;; return
    219          }
    220          
    221          static int Mask_calcN2(int width, unsigned char *frame)
    222          {
    223          	int x, y;
    224          	unsigned char *p;
    225          	unsigned char b22, w22;
    226          	int demerit = 0;
    227          
    228          	p = frame + width + 1;
    229          	for(y=1; y<width; y++) {
    230          		for(x=1; x<width; x++) {
    231          			b22 = p[0] & p[-1] & p[-width] & p [-width-1];
    232          			w22 = p[0] | p[-1] | p[-width] | p [-width-1];
    233          			if((b22 | (w22 ^ 1))&1) {
    234          				demerit += N2;
    235          			}
    236          			p++;
    237          		}
    238          		p++;
    239          	}
    240          
    241          	return demerit;
    242          }
    243          
    244          static int Mask_calcRunLength(int width, unsigned char *frame, int dir, int *runLength)
    245          {
    246          	int head;
    247          	int i;
    248          	unsigned char *p;
    249          	int pitch;
    250          
    251          	pitch = (dir==0)?1:width;
    252          	if(frame[0] & 1) {
    253          		runLength[0] = -1;
    254          		head = 1;
    255          	} else {
    256          		head = 0;
    257          	}
    258          	runLength[head] = 1;
    259          	p = frame + pitch;
    260          
    261          	for(i=1; i<width; i++) {
    262          		if((p[0] ^ p[-pitch]) & 1) {
    263          			head++;
    264          			runLength[head] = 1;
    265          		} else {
    266          			runLength[head]++;
    267          		}
    268          		p += pitch;
    269          	}
    270          
    271          	return head + 1;
    272          }
    273          

   \                                 In section .text, align 2, keep-with-next
    274          static int Mask_evaluateSymbol(int width, unsigned char *frame)
    275          {
   \                     Mask_evaluateSymbol: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460F             MOV      R7,R1
    276          	int x, y;
    277          	int demerit = 0;
    278          	int runLength[QRSPEC_WIDTH_MAX + 1];
    279          	int length;
    280          
    281          	demerit += Mask_calcN2(width, frame);
   \   00000008   0x19E9             ADDS     R1,R5,R7
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \   0000000E   0xF5AD 0x7D33      SUB      SP,SP,#+716
   \   00000012   0x2D02             CMP      R5,#+2
   \   00000014   0xDB29             BLT.N    ??Mask_evaluateSymbol_0
   \   00000016   0x1E6A             SUBS     R2,R5,#+1
   \   00000018   0x4613             MOV      R3,R2
   \   0000001A   0xF1C5 0x0A00      RSB      R10,R5,#+0
   \                     ??Mask_evaluateSymbol_1: (+1)
   \   0000001E   0xEB0A 0x0401      ADD      R4,R10,R1
   \   00000022   0x4690             MOV      R8,R2
   \                     ??Mask_evaluateSymbol_2: (+1)
   \   00000024   0xF811 0xCC01      LDRB     R12,[R1, #-1]
   \   00000028   0x780E             LDRB     R6,[R1, #+0]
   \   0000002A   0xF894 0xE000      LDRB     LR,[R4, #+0]
   \   0000002E   0xF814 0x9C01      LDRB     R9,[R4, #-1]
   \   00000032   0xEA0C 0x0B06      AND      R11,R12,R6
   \   00000036   0xEA4C 0x0606      ORR      R6,R12,R6
   \   0000003A   0xEA4E 0x0606      ORR      R6,LR,R6
   \   0000003E   0xEA0E 0x0B0B      AND      R11,LR,R11
   \   00000042   0xEA49 0x0606      ORR      R6,R9,R6
   \   00000046   0xEA09 0x0B0B      AND      R11,R9,R11
   \   0000004A   0xF086 0x0601      EOR      R6,R6,#0x1
   \   0000004E   0xEA46 0x060B      ORR      R6,R6,R11
   \   00000052   0x07F6             LSLS     R6,R6,#+31
   \   00000054   0xBF48             IT       MI 
   \   00000056   0x1CC0             ADDMI    R0,R0,#+3
   \   00000058   0x1C49             ADDS     R1,R1,#+1
   \   0000005A   0x1C64             ADDS     R4,R4,#+1
   \   0000005C   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000060   0xD1E0             BNE.N    ??Mask_evaluateSymbol_2
   \   00000062   0x1C49             ADDS     R1,R1,#+1
   \   00000064   0x1E5B             SUBS     R3,R3,#+1
   \   00000066   0xD1DA             BNE.N    ??Mask_evaluateSymbol_1
   \   00000068   0xE001             B.N      ??Mask_evaluateSymbol_3
    282          
    283          	for(y=0; y<width; y++) {
   \                     ??Mask_evaluateSymbol_0: (+1)
   \   0000006A   0x2D01             CMP      R5,#+1
   \   0000006C   0xDB5A             BLT.N    ??Mask_evaluateSymbol_4
   \                     ??Mask_evaluateSymbol_3: (+1)
   \   0000006E   0x463E             MOV      R6,R7
   \   00000070   0x46AA             MOV      R10,R5
   \   00000072   0xF04F 0x39FF      MOV      R9,#-1
   \   00000076   0xF10D 0x0800      ADD      R8,SP,#+0
    284          		length = Mask_calcRunLength(width, frame + y * width, 0, runLength);
   \                     ??Mask_evaluateSymbol_5: (+1)
   \   0000007A   0x7831             LDRB     R1,[R6, #+0]
   \   0000007C   0x07C9             LSLS     R1,R1,#+31
   \   0000007E   0xBF46             ITTE     MI 
   \   00000080   0xF8CD 0x9000      STRMI    R9,[SP, #+0]
   \   00000084   0x2201             MOVMI    R2,#+1
   \   00000086   0x2200             MOVPL    R2,#+0
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0xF848 0x1022      STR      R1,[R8, R2, LSL #+2]
   \   0000008E   0x1C71             ADDS     R1,R6,#+1
   \   00000090   0x2D02             CMP      R5,#+2
   \   00000092   0xDB11             BLT.N    ??Mask_evaluateSymbol_6
   \   00000094   0x1E6B             SUBS     R3,R5,#+1
   \                     ??Mask_evaluateSymbol_7: (+1)
   \   00000096   0x780C             LDRB     R4,[R1, #+0]
   \   00000098   0xF811 0xCC01      LDRB     R12,[R1, #-1]
   \   0000009C   0xEA8C 0x0404      EOR      R4,R12,R4
   \   000000A0   0x07E4             LSLS     R4,R4,#+31
   \   000000A2   0xBF47             ITTEE    MI 
   \   000000A4   0x1C52             ADDMI    R2,R2,#+1
   \   000000A6   0x2401             MOVMI    R4,#+1
   \   000000A8   0xF858 0x4022      LDRPL    R4,[R8, R2, LSL #+2]
   \   000000AC   0x1C64             ADDPL    R4,R4,#+1
   \   000000AE   0xF848 0x4022      STR      R4,[R8, R2, LSL #+2]
   \   000000B2   0x1C49             ADDS     R1,R1,#+1
   \   000000B4   0x1E5B             SUBS     R3,R3,#+1
   \   000000B6   0xD1EE             BNE.N    ??Mask_evaluateSymbol_7
    285          		demerit += Mask_calcN1N3(length, runLength);
   \                     ??Mask_evaluateSymbol_6: (+1)
   \   000000B8   0x4604             MOV      R4,R0
   \   000000BA   0xA900             ADD      R1,SP,#+0
   \   000000BC   0x1C50             ADDS     R0,R2,#+1
   \   000000BE   0x.... 0x....      BL       Mask_calcN1N3
   \   000000C2   0x1900             ADDS     R0,R0,R4
    286          	}
   \   000000C4   0x19AE             ADDS     R6,R5,R6
   \   000000C6   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   000000CA   0xD1D6             BNE.N    ??Mask_evaluateSymbol_5
   \   000000CC   0x2600             MOVS     R6,#+0
   \   000000CE   0xF1C5 0x0A00      RSB      R10,R5,#+0
    287          
    288          	for(x=0; x<width; x++) {
    289          		length = Mask_calcRunLength(width, frame + x, 1, runLength);
   \                     ??Mask_evaluateSymbol_8: (+1)
   \   000000D2   0x7839             LDRB     R1,[R7, #+0]
   \   000000D4   0x07C9             LSLS     R1,R1,#+31
   \   000000D6   0xBF46             ITTE     MI 
   \   000000D8   0xF8CD 0x9000      STRMI    R9,[SP, #+0]
   \   000000DC   0x2201             MOVMI    R2,#+1
   \   000000DE   0x2200             MOVPL    R2,#+0
   \   000000E0   0x2101             MOVS     R1,#+1
   \   000000E2   0xF848 0x1022      STR      R1,[R8, R2, LSL #+2]
   \   000000E6   0x19E9             ADDS     R1,R5,R7
   \   000000E8   0x2D02             CMP      R5,#+2
   \   000000EA   0xDB11             BLT.N    ??Mask_evaluateSymbol_9
   \   000000EC   0x1E6B             SUBS     R3,R5,#+1
   \                     ??Mask_evaluateSymbol_10: (+1)
   \   000000EE   0x780C             LDRB     R4,[R1, #+0]
   \   000000F0   0xF81A 0xC001      LDRB     R12,[R10, R1]
   \   000000F4   0xEA8C 0x0404      EOR      R4,R12,R4
   \   000000F8   0x07E4             LSLS     R4,R4,#+31
   \   000000FA   0xBF47             ITTEE    MI 
   \   000000FC   0x1C52             ADDMI    R2,R2,#+1
   \   000000FE   0x2401             MOVMI    R4,#+1
   \   00000100   0xF858 0x4022      LDRPL    R4,[R8, R2, LSL #+2]
   \   00000104   0x1C64             ADDPL    R4,R4,#+1
   \   00000106   0xF848 0x4022      STR      R4,[R8, R2, LSL #+2]
   \   0000010A   0x1869             ADDS     R1,R5,R1
   \   0000010C   0x1E5B             SUBS     R3,R3,#+1
   \   0000010E   0xD1EE             BNE.N    ??Mask_evaluateSymbol_10
    290          		demerit += Mask_calcN1N3(length, runLength);
   \                     ??Mask_evaluateSymbol_9: (+1)
   \   00000110   0x4604             MOV      R4,R0
   \   00000112   0xA900             ADD      R1,SP,#+0
   \   00000114   0x1C50             ADDS     R0,R2,#+1
   \   00000116   0x.... 0x....      BL       Mask_calcN1N3
   \   0000011A   0x1900             ADDS     R0,R0,R4
    291          	}
   \   0000011C   0x1C76             ADDS     R6,R6,#+1
   \   0000011E   0x1C7F             ADDS     R7,R7,#+1
   \   00000120   0x42AE             CMP      R6,R5
   \   00000122   0xDBD6             BLT.N    ??Mask_evaluateSymbol_8
    292          
    293          	return demerit;
   \                     ??Mask_evaluateSymbol_4: (+1)
   \   00000124   0xF50D 0x7D33      ADD      SP,SP,#+716
   \   00000128   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    294          }
    295          

   \                                 In section .text, align 2, keep-with-next
    296          unsigned char *Mask_mask(int width, unsigned char *frame, QRecLevel level)
    297          {
   \                     Mask_mask: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
    298          	int i;
    299          	unsigned char *mask, *bestMask;
    300          	int minDemerit = INT_MAX;
    301          	int blacks;
    302          	int bratio;
    303          	int demerit;
    304          	int w2 = width * width;
   \   00000006   0xFB08 0xFA08      MUL      R10,R8,R8
   \   0000000A   0xF06F 0x4900      MVN      R9,#-2147483648
    305          
    306          	mask = (unsigned char *)malloc(w2);
   \   0000000E   0x4650             MOV      R0,R10
   \   00000010   0x.... 0x....      BL       malloc
   \   00000014   0xEA5F 0x0B00      MOVS     R11,R0
    307          	if(mask == NULL) return NULL;
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2000             MOVEQ    R0,#+0
   \   0000001C   0xD03E             BEQ.N    ??Mask_mask_0
    308          	bestMask = NULL;
   \   0000001E   0x2400             MOVS     R4,#+0
    309          
    310          	for(i=0; i<maskNum; i++) {
   \   00000020   0x2500             MOVS     R5,#+0
   \   00000022   0x....             LDR.N    R6,??DataTable1
   \   00000024   0x27C8             MOVS     R7,#+200
    311          //		n1 = n2 = n3 = n4 = 0;
    312          		demerit = 0;
    313          		blacks = maskMakers[i](width, frame, mask);
   \                     ??Mask_mask_1: (+1)
   \   00000026   0x9901             LDR      R1,[SP, #+4]
   \   00000028   0x6833             LDR      R3,[R6, #+0]
   \   0000002A   0x465A             MOV      R2,R11
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0x4798             BLX      R3
    314          		blacks += Mask_writeFormatInformation(width, mask, i, level);
    315          		bratio = (200 * blacks + w2) / w2 / 2; /* (int)(100*blacks/w2+0.5) */
    316          		demerit = (abs(bratio - 50) / 5) * N4;
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0x462A             MOV      R2,R5
   \   00000034   0xF99D 0x3008      LDRSB    R3,[SP, #+8]
   \   00000038   0x4659             MOV      R1,R11
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x.... 0x....      BL       Mask_writeFormatInformation
   \   00000040   0x9900             LDR      R1,[SP, #+0]
   \   00000042   0x1840             ADDS     R0,R0,R1
   \   00000044   0xFB07 0xA000      MLA      R0,R7,R0,R10
   \   00000048   0xFB90 0xF0FA      SDIV     R0,R0,R10
   \   0000004C   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000050   0x1040             ASRS     R0,R0,#+1
   \   00000052   0x3832             SUBS     R0,R0,#+50
   \   00000054   0xBF48             IT       MI 
   \   00000056   0x4240             RSBMI    R0,R0,#+0
    317          //		n4 = demerit;
    318          		demerit += Mask_evaluateSymbol(width, mask);
   \   00000058   0x2105             MOVS     R1,#+5
   \   0000005A   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   0000005E   0xEB01 0x0081      ADD      R0,R1,R1, LSL #+2
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x4659             MOV      R1,R11
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0x.... 0x....      BL       Mask_evaluateSymbol
   \   0000006C   0x9900             LDR      R1,[SP, #+0]
   \   0000006E   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
    319          //		printf("(%d,%d,%d,%d)=%d\n", n1, n2, n3 ,n4, demerit);
    320          		if(demerit < minDemerit) {
   \   00000072   0x4548             CMP      R0,R9
   \   00000074   0xDA0A             BGE.N    ??Mask_mask_2
    321          			minDemerit = demerit;
   \   00000076   0x4681             MOV      R9,R0
    322          			free(bestMask);
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       free
    323          			bestMask = mask;
   \   0000007E   0x465C             MOV      R4,R11
    324          			mask = (unsigned char *)malloc(w2);
   \   00000080   0x4650             MOV      R0,R10
   \   00000082   0x.... 0x....      BL       malloc
   \   00000086   0xEA5F 0x0B00      MOVS     R11,R0
    325          			if(mask == NULL) break;
   \   0000008A   0xD003             BEQ.N    ??Mask_mask_3
    326          		}
    327          	}
   \                     ??Mask_mask_2: (+1)
   \   0000008C   0x1C6D             ADDS     R5,R5,#+1
   \   0000008E   0x1D36             ADDS     R6,R6,#+4
   \   00000090   0x2D08             CMP      R5,#+8
   \   00000092   0xDBC8             BLT.N    ??Mask_mask_1
    328          	free(mask);
   \                     ??Mask_mask_3: (+1)
   \   00000094   0x4658             MOV      R0,R11
   \   00000096   0x.... 0x....      BL       free
    329          	return bestMask;
   \   0000009A   0x4620             MOV      R0,R4
   \                     ??Mask_mask_0: (+1)
   \   0000009C   0xB003             ADD      SP,SP,#+12
   \   0000009E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    330          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     maskMakers

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Mask_calcN1N3
     752   Mask_evaluateSymbol
       752   -> Mask_calcN1N3
      24   Mask_makeMask
        24   -- Indirect call
        24   -> Mask_writeFormatInformation
        24   -> __aeabi_errno_addr
        24   -> malloc
      48   Mask_mask
        48   -- Indirect call
        48   -> Mask_evaluateSymbol
        48   -> Mask_writeFormatInformation
        48   -> free
        48   -> malloc
      16   Mask_mask0
      16   Mask_mask1
      16   Mask_mask2
      16   Mask_mask3
      16   Mask_mask4
      20   Mask_mask5
      16   Mask_mask6
      24   Mask_mask7
      24   Mask_writeFormatInformation
        24   -> QRspec_getFormatInfo


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       6  ?Subroutine0
     116  Mask_calcN1N3
     300  Mask_evaluateSymbol
      78  Mask_makeMask
     162  Mask_mask
      62  Mask_mask0
      54  Mask_mask1
      68  Mask_mask2
      84  Mask_mask3
      76  Mask_mask4
      90  Mask_mask5
      74  Mask_mask6
      96  Mask_mask7
     122  Mask_writeFormatInformation
      32  maskMakers

 
    32 bytes in section .data
 1 392 bytes in section .text
 
 1 392 bytes of CODE memory
    32 bytes of DATA memory

Errors: none
Warnings: none
