###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        13/Apr/2020  09:24:49
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\gcode.cpp
#    Command line =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\gcode.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        -lA
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/Multi_language\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/QRENCODE\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\..\Middlewares\GUI\
#        -Oh --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\gcode.lst
#    Object file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\gcode.o
#
###############################################################################

D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\gcode.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * gcode.cpp - Parser for a GCode line, providing a parameter interface.
     25           */
     26          
     27          #include "gcode.h"

  #define UNUSED(x) ((void)(x))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Inc\mks_cfg.h",626  Warning[Pe083]: 
          type qualifier specified more than once

    FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
                                                                      ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\gcode.h",207  Warning[Pa093]: 
          implicit conversion from floating point to integer
     28          
     29          #include "Marlin.h"

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

    }
    ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
     30          #include "language.h"
     31          
     32          // Must be declared for allocation and to satisfy the linker
     33          // Zero values need no initialization.
     34          

   \                                 In section .bss, align 1
     35          bool GCodeParser::volumetric_enabled;
   \                     _ZN11GCodeParser18volumetric_enabledE:
   \   00000000                      DS8 1
     36          
     37          #if ENABLED(INCH_MODE_SUPPORT)
     38            float GCodeParser::linear_unit_factor, GCodeParser::volumetric_unit_factor;
     39          #endif
     40          
     41          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
     42            TempUnit GCodeParser::input_temp_units;
     43          #endif
     44          

   \                                 In section .bss, align 4
     45          char *GCodeParser::command_ptr,
     46               *GCodeParser::string_arg,
     47               *GCodeParser::value_ptr;
     48          char GCodeParser::command_letter;
   \                     _ZN11GCodeParser14command_letterE:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
     49          int GCodeParser::codenum;
     50          #if USE_GCODE_SUBCODES
     51            uint8_t GCodeParser::subcode;
     52          #endif
     53          
     54          #if ENABLED(FASTER_GCODE_PARSER)
     55            // Optimized Parameters
     56            byte GCodeParser::codebits[4];   // found bits
   \                     _ZN11GCodeParser8codebitsE:
   \   00000004                      DS8 4
     57            uint8_t GCodeParser::param[26];  // parameter offsets from command_ptr
   \                     _ZN11GCodeParser5paramE:
   \   00000008                      DS8 28
   \                     _ZN11GCodeParser11command_ptrE:
   \   00000024                      DS8 4
   \                     _ZN11GCodeParser10string_argE:
   \   00000028                      DS8 4
   \                     _ZN11GCodeParser7codenumE:
   \   0000002C                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN11GCodeParser9value_ptrE:
   \   00000000                      DS8 4
     58          #else
     59            char *GCodeParser::command_args; // start of parameters
     60          #endif
     61          
     62          // Create a global instance of the GCode parser singleton

   \                                 In section .bss, align 4
     63          GCodeParser parser;
   \                     parser:
   \   00000000                      DS8 4
     64          
     65          /**
     66           * Clear all code-seen (and value pointers)
     67           *
     68           * Since each param is set/cleared on seen codes,
     69           * this may be optimized by commenting out ZERO(param)
     70           */

   \                                 In section .text, align 2, keep-with-next
     71          void GCodeParser::reset() {
     72            string_arg = NULL;                    // No whole line argument
   \                     _ZN11GCodeParser5resetEv: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6281             STR      R1,[R0, #+40]
     73            command_letter = '?';                 // No command letter
   \   00000006   0x213F             MOVS     R1,#+63
   \   00000008   0x7001             STRB     R1,[R0, #+0]
     74            codenum = 0;                          // No command code
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x62C1             STR      R1,[R0, #+44]
     75            #if USE_GCODE_SUBCODES
     76              subcode = 0;                        // No command sub-code
     77            #endif
     78            #if ENABLED(FASTER_GCODE_PARSER)
     79              ZERO(codebits);                     // No codes yet
   \   0000000E   0xF840 0x1F04      STR      R1,[R0, #+4]!
     80              //ZERO(param);                      // No parameters (should be safe to comment out this line)
     81            #endif
     82          }
   \   00000012   0x4770             BX       LR               ;; return
     83          
     84          // Populate all fields by parsing a single line of GCode
     85          // 58 bytes of SRAM are used to speed up seen/value

   \                                 In section .text, align 2, keep-with-next
     86          void GCodeParser::parse(char *p) {
   \                     _ZN11GCodeParser5parseEPc: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
     87          
     88            reset(); // No codes to report
   \   00000004   0x....             LDR.N    R4,??DataTable3
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x62A0             STR      R0,[R4, #+40]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x203F             MOVS     R0,#+63
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x62E0             STR      R0,[R4, #+44]
   \   00000014   0x1D20             ADDS     R0,R4,#+4
   \   00000016   0x6001             STR      R1,[R0, #+0]
   \   00000018   0xE000             B.N      ??parse_0
     89          
     90            // Skip spaces
     91            while (*p == ' ') ++p;
   \                     ??parse_1: (+1)
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??parse_0: (+1)
   \   0000001C   0x5668             LDRSB    R0,[R5, R1]
   \   0000001E   0x2820             CMP      R0,#+32
   \   00000020   0xD0FB             BEQ.N    ??parse_1
     92          
     93            // Skip N[-0-9] if included in the command line
     94            if (*p == 'N' && NUMERIC_SIGNED(p[1])) {
   \   00000022   0x284E             CMP      R0,#+78
   \   00000024   0xD117             BNE.N    ??parse_2
   \   00000026   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   0000002A   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   0000002E   0x290A             CMP      R1,#+10
   \   00000030   0xD303             BCC.N    ??parse_3
   \   00000032   0x282D             CMP      R0,#+45
   \   00000034   0xBF18             IT       NE 
   \   00000036   0x282B             CMPNE    R0,#+43
   \   00000038   0xD10D             BNE.N    ??parse_2
     95              #if ENABLED(FASTER_GCODE_PARSER)
     96                //set('N', p + 1);     // (optional) Set the 'N' parameter value
     97              #endif
     98              p += 2;                  // skip N[-0-9]
   \                     ??parse_3: (+1)
   \   0000003A   0x1CAD             ADDS     R5,R5,#+2
   \   0000003C   0xE000             B.N      ??parse_4
     99              while (NUMERIC(*p)) ++p; // skip [0-9]*
   \                     ??parse_5: (+1)
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??parse_4: (+1)
   \   00000040   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000044   0x3830             SUBS     R0,R0,#+48
   \   00000046   0x280A             CMP      R0,#+10
   \   00000048   0xD3F9             BCC.N    ??parse_5
    100              while (*p == ' ')   ++p; // skip [ ]*
   \                     ??parse_6: (+1)
   \   0000004A   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   0000004E   0x2820             CMP      R0,#+32
   \   00000050   0xBF08             IT       EQ 
   \   00000052   0x1C6D             ADDEQ    R5,R5,#+1
   \   00000054   0xD0F9             BEQ.N    ??parse_6
    101            }
    102          
    103            // *p now points to the current command, which should be G, M, or T
    104            command_ptr = p;
   \                     ??parse_2: (+1)
   \   00000056   0x6265             STR      R5,[R4, #+36]
    105          
    106            // Get the command letter, which must be G, M, or T
    107            const char letter = *p++;
    108          
    109            // Nullify asterisk and trailing whitespace
    110            char *starpos = strchr(p, '*');
   \   00000058   0x212A             MOVS     R1,#+42
   \   0000005A   0xF915 0x6B01      LDRSB    R6,[R5], #+1
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0x.... 0x....      BL       __iar_Strchr
    111            if (starpos) {
   \   00000064   0xB128             CBZ.N    R0,??parse_7
    112              --starpos;                          // *
    113              while (*starpos == ' ') --starpos;  // spaces...
   \                     ??parse_8: (+1)
   \   00000066   0xF910 0x1D01      LDRSB    R1,[R0, #-1]!
   \   0000006A   0x2920             CMP      R1,#+32
   \   0000006C   0xD0FB             BEQ.N    ??parse_8
    114              starpos[1] = '\0';
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x7041             STRB     R1,[R0, #+1]
    115            }
    116          
    117            // Bail if the letter is not G, M, or T
    118            switch (letter) { case 'G': case 'M': case 'T': break; default: return; }
   \                     ??parse_7: (+1)
   \   00000072   0x2E47             CMP      R6,#+71
   \   00000074   0xBF1C             ITT      NE 
   \   00000076   0x2E4D             CMPNE    R6,#+77
   \   00000078   0x2E54             CMPNE    R6,#+84
   \   0000007A   0xD001             BEQ.N    ??parse_9
   \   0000007C   0xBDF1             POP      {R0,R4-R7,PC}
    119          
    120            // Skip spaces to get the numeric part
    121            while (*p == ' ') p++;
   \                     ??parse_10: (+1)
   \   0000007E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??parse_9: (+1)
   \   00000080   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000084   0x2820             CMP      R0,#+32
   \   00000086   0xD0FA             BEQ.N    ??parse_10
    122          
    123            // Bail if there's no command code number
    124            if (!NUMERIC(*p)) return;
   \   00000088   0x3830             SUBS     R0,R0,#+48
   \   0000008A   0x280A             CMP      R0,#+10
   \   0000008C   0xF080 0x809C      BCS.W    ??parse_11
    125          
    126            // Save the command letter at this point
    127            // A '?' signifies an unknown command
    128            command_letter = letter;
    129          
    130            // Get the code number - integer digits only
    131            codenum = 0;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x7026             STRB     R6,[R4, #+0]
   \   00000094   0x62E0             STR      R0,[R4, #+44]
    132            do {
    133              codenum *= 10, codenum += *p++ - '0';
   \                     ??parse_12: (+1)
   \   00000096   0x6AE0             LDR      R0,[R4, #+44]
   \   00000098   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   0000009C   0x0048             LSLS     R0,R1,#+1
   \   0000009E   0x62E0             STR      R0,[R4, #+44]
   \   000000A0   0xF995 0x1000      LDRSB    R1,[R5, #+0]
   \   000000A4   0x3930             SUBS     R1,R1,#+48
   \   000000A6   0x1808             ADDS     R0,R1,R0
   \   000000A8   0x62E0             STR      R0,[R4, #+44]
    134            } while (NUMERIC(*p));
   \   000000AA   0xF915 0x0F01      LDRSB    R0,[R5, #+1]!
   \   000000AE   0x3830             SUBS     R0,R0,#+48
   \   000000B0   0x280A             CMP      R0,#+10
   \   000000B2   0xD3F0             BCC.N    ??parse_12
    135          
    136            // Allow for decimal point in command
    137            #if USE_GCODE_SUBCODES
    138              if (*p == '.') {
    139                p++;
    140                while (NUMERIC(*p))
    141                  subcode *= 10, subcode += *p++ - '0';
    142              }
    143            #endif
    144          
    145            // Skip all spaces to get to the first argument, or nul
    146            while (*p == ' ') p++;
   \                     ??parse_13: (+1)
   \   000000B4   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   000000B8   0x2820             CMP      R0,#+32
   \   000000BA   0xBF08             IT       EQ 
   \   000000BC   0x1C6D             ADDEQ    R5,R5,#+1
   \   000000BE   0xD0F9             BEQ.N    ??parse_13
    147          
    148            // The command parameters (if any) start here, for sure!
    149          
    150            #if DISABLED(FASTER_GCODE_PARSER)
    151              command_args = p; // Scan for parameters in seen()
    152            #endif
    153          
    154            // Only use string_arg for these M codes
    155            if (letter == 'M') switch (codenum) { case 23: case 28: case 30: case 117: case 928: string_arg = p; return; default: break; }
   \   000000C0   0x2E4D             CMP      R6,#+77
   \   000000C2   0xD10C             BNE.N    ??parse_14
   \   000000C4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C6   0x2817             CMP      R0,#+23
   \   000000C8   0xBF18             IT       NE 
   \   000000CA   0x281C             CMPNE    R0,#+28
   \   000000CC   0xD005             BEQ.N    ??parse_15
   \   000000CE   0x281E             CMP      R0,#+30
   \   000000D0   0xBF1C             ITT      NE 
   \   000000D2   0x2875             CMPNE    R0,#+117
   \   000000D4   0xF5B0 0x7F68      CMPNE    R0,#+928
   \   000000D8   0xD101             BNE.N    ??parse_14
   \                     ??parse_15: (+1)
   \   000000DA   0x62A5             STR      R5,[R4, #+40]
   \   000000DC   0xBDF1             POP      {R0,R4-R7,PC}
    156          
    157            #if ENABLED(DEBUG_GCODE_PARSER)
    158              const bool debug = codenum == 800;
    159            #endif
    160          
    161            /**
    162             * Find all parameters, set flags and pointers for fast parsing
    163             *
    164             * Most codes ignore 'string_arg', but those that want a string will get the right pointer.
    165             * The following loop assigns the first "parameter" having no numeric value to 'string_arg'.
    166             * This allows M0/M1 with expire time to work: "M0 S5 You Win!"
    167             * For 'M118' you must use 'E1' and 'A1' rather than just 'E' or 'A'
    168             */
    169            string_arg = NULL;
   \                     ??parse_14: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x62A0             STR      R0,[R4, #+40]
    170            while (const char code = *p++) {                    // Get the next parameter. A NUL ends the loop
   \                     ??parse_16: (+1)
   \   000000E2   0xF915 0x0B01      LDRSB    R0,[R5], #+1
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD06E             BEQ.N    ??parse_11
    171          
    172              // Special handling for M32 [P] !/path/to/file.g#
    173              // The path must be the last parameter
    174              if (code == '!' && letter == 'M' && codenum == 32) {
   \   000000EA   0x2821             CMP      R0,#+33
   \   000000EC   0xBF02             ITTT     EQ 
   \   000000EE   0x2E4D             CMPEQ    R6,#+77
   \   000000F0   0x6AE1             LDREQ    R1,[R4, #+44]
   \   000000F2   0x2920             CMPEQ    R1,#+32
   \   000000F4   0xD109             BNE.N    ??parse_17
    175                string_arg = p;                           // Name starts after '!'
   \   000000F6   0x62A5             STR      R5,[R4, #+40]
    176                char * const lb = strchr(p, '#');         // Already seen '#' as SD char (to pause buffering)
   \   000000F8   0x2123             MOVS     R1,#+35
   \   000000FA   0x4628             MOV      R0,R5
   \   000000FC   0x.... 0x....      BL       __iar_Strchr
    177                if (lb) *lb = '\0';                       // Safe to mark the end of the filename
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD061             BEQ.N    ??parse_11
   \   00000104   0x2100             MOVS     R1,#+0
   \   00000106   0x7001             STRB     R1,[R0, #+0]
    178                return;
   \   00000108   0xBDF1             POP      {R0,R4-R7,PC}
    179              }
    180          
    181              // Arguments MUST be uppercase for fast GCode parsing
    182              #if ENABLED(FASTER_GCODE_PARSER)
    183                #define PARAM_TEST WITHIN(code, 'A', 'Z')
    184              #else
    185                #define PARAM_TEST true
    186              #endif
    187          
    188              if (PARAM_TEST) {
   \                     ??parse_17: (+1)
   \   0000010A   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   0000010E   0x291A             CMP      R1,#+26
   \   00000110   0xD30A             BCC.N    ??parse_18
    189          
    190                while (*p == ' ') p++;                    // Skip spaces between parameters & values
    191          
    192                const bool has_num = NUMERIC(p[0])                            // [0-9]
    193                                  || (p[0] == '.' && NUMERIC(p[1]))           // .[0-9]
    194                                  || (
    195                                        (p[0] == '-' || p[0] == '+') && (     // [-+]
    196                                          NUMERIC(p[1])                       //     [0-9]
    197                                          || (p[1] == '.' && NUMERIC(p[2]))   //     .[0-9]
    198                                        )
    199                                      );
    200          
    201                #if ENABLED(DEBUG_GCODE_PARSER)
    202                  if (debug) {
    203                    SERIAL_ECHOPAIR("Got letter ", code);
    204                    SERIAL_ECHOPAIR(" at index ", (int)(p - command_ptr - 1));
    205                    if (has_num) SERIAL_ECHOPGM(" (has_num)");
    206                  }
    207                #endif
    208          
    209                if (!has_num && !string_arg) {            // No value? First time, keep as string_arg
    210                  string_arg = p - 1;
    211                  #if ENABLED(DEBUG_GCODE_PARSER)
    212                    if (debug) SERIAL_ECHOPAIR(" string_arg: ", hex_address((void*)string_arg)); // DEBUG
    213                  #endif
    214                }
    215          
    216                #if ENABLED(DEBUG_GCODE_PARSER)
    217                  if (debug) SERIAL_EOL();
    218                #endif
    219          
    220                #if ENABLED(FASTER_GCODE_PARSER)
    221                {
    222                  set(code, has_num ? p : NULL            // Set parameter exists and pointer (NULL for no number)
    223                    #if ENABLED(DEBUG_GCODE_PARSER)
    224                      , debug
    225                    #endif
    226                  );
    227                }
    228                #endif
    229              }
    230              else if (!string_arg) {                     // Not A-Z? First time, keep as the string_arg
   \   00000112   0x6AA0             LDR      R0,[R4, #+40]
   \   00000114   0xB908             CBNZ.N   R0,??parse_19
    231                string_arg = p - 1;
   \   00000116   0x1E68             SUBS     R0,R5,#+1
   \   00000118   0x62A0             STR      R0,[R4, #+40]
    232                #if ENABLED(DEBUG_GCODE_PARSER)
    233                  if (debug) SERIAL_ECHOPAIR(" string_arg: ", hex_address((void*)string_arg)); // DEBUG
    234                #endif
    235              }
    236          
    237              if (!WITHIN(*p, 'A', 'Z')) {                // Another parameter right away?
   \                     ??parse_19: (+1)
   \   0000011A   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   0000011E   0x3841             SUBS     R0,R0,#+65
   \   00000120   0x281A             CMP      R0,#+26
   \   00000122   0xD3DE             BCC.N    ??parse_16
   \   00000124   0xE03D             B.N      ??parse_20
   \                     ??parse_21: (+1)
   \   00000126   0x1C6D             ADDS     R5,R5,#+1
   \                     ??parse_18: (+1)
   \   00000128   0xF995 0x1000      LDRSB    R1,[R5, #+0]
   \   0000012C   0x2920             CMP      R1,#+32
   \   0000012E   0xD0FA             BEQ.N    ??parse_21
   \   00000130   0xF1A1 0x0230      SUB      R2,R1,#+48
   \   00000134   0x2A0A             CMP      R2,#+10
   \   00000136   0xD32E             BCC.N    ??parse_22
   \   00000138   0x292E             CMP      R1,#+46
   \   0000013A   0xD11B             BNE.N    ??parse_23
   \   0000013C   0xF995 0x1001      LDRSB    R1,[R5, #+1]
   \   00000140   0x3930             SUBS     R1,R1,#+48
   \   00000142   0x290A             CMP      R1,#+10
   \   00000144   0xD327             BCC.N    ??parse_22
   \                     ??parse_24: (+1)
   \   00000146   0x6AA1             LDR      R1,[R4, #+40]
   \   00000148   0xB909             CBNZ.N   R1,??parse_25
   \   0000014A   0x1E69             SUBS     R1,R5,#+1
   \   0000014C   0x62A1             STR      R1,[R4, #+40]
   \                     ??parse_25: (+1)
   \   0000014E   0x2100             MOVS     R1,#+0
   \                     ??parse_26: (+1)
   \   00000150   0x3841             SUBS     R0,R0,#+65
   \   00000152   0xB2C0             UXTB     R0,R0
   \   00000154   0x281A             CMP      R0,#+26
   \   00000156   0xD2E0             BCS.N    ??parse_19
   \   00000158   0xEB04 0x02E0      ADD      R2,R4,R0, ASR #+3
   \   0000015C   0x2701             MOVS     R7,#+1
   \   0000015E   0x7913             LDRB     R3,[R2, #+4]
   \   00000160   0xF000 0x0C07      AND      R12,R0,#0x7
   \   00000164   0xFA07 0xF70C      LSL      R7,R7,R12
   \   00000168   0x433B             ORRS     R3,R7,R3
   \   0000016A   0x7113             STRB     R3,[R2, #+4]
   \   0000016C   0xB1A9             CBZ.N    R1,??parse_27
   \   0000016E   0x6A62             LDR      R2,[R4, #+36]
   \   00000170   0x1A89             SUBS     R1,R1,R2
   \   00000172   0xE012             B.N      ??parse_27
   \                     ??parse_23: (+1)
   \   00000174   0x292D             CMP      R1,#+45
   \   00000176   0xBF18             IT       NE 
   \   00000178   0x292B             CMPNE    R1,#+43
   \   0000017A   0xD1E4             BNE.N    ??parse_24
   \   0000017C   0xF995 0x1001      LDRSB    R1,[R5, #+1]
   \   00000180   0xF1A1 0x0230      SUB      R2,R1,#+48
   \   00000184   0x2A0A             CMP      R2,#+10
   \   00000186   0xD306             BCC.N    ??parse_22
   \   00000188   0x292E             CMP      R1,#+46
   \   0000018A   0xD1DC             BNE.N    ??parse_24
   \   0000018C   0xF995 0x1002      LDRSB    R1,[R5, #+2]
   \   00000190   0x3930             SUBS     R1,R1,#+48
   \   00000192   0x290A             CMP      R1,#+10
   \   00000194   0xD2D7             BCS.N    ??parse_24
   \                     ??parse_22: (+1)
   \   00000196   0x4629             MOV      R1,R5
   \   00000198   0xE7DA             B.N      ??parse_26
   \                     ??parse_27: (+1)
   \   0000019A   0x1900             ADDS     R0,R0,R4
   \   0000019C   0x7201             STRB     R1,[R0, #+8]
   \   0000019E   0xE7BC             B.N      ??parse_19
    238                while (*p && DECIMAL_SIGNED(*p)) p++;     // Skip over the value section of a parameter
   \                     ??parse_28: (+1)
   \   000001A0   0x1C6D             ADDS     R5,R5,#+1
   \                     ??parse_20: (+1)
   \   000001A2   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   000001A6   0xB140             CBZ.N    R0,??parse_29
   \   000001A8   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   000001AC   0x290A             CMP      R1,#+10
   \   000001AE   0xD3F7             BCC.N    ??parse_28
   \   000001B0   0x282E             CMP      R0,#+46
   \   000001B2   0xBF1C             ITT      NE 
   \   000001B4   0x282D             CMPNE    R0,#+45
   \   000001B6   0x282B             CMPNE    R0,#+43
   \   000001B8   0xD0F2             BEQ.N    ??parse_28
    239                while (*p == ' ') p++;                    // Skip over all spaces
   \                     ??parse_29: (+1)
   \   000001BA   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   000001BE   0x2820             CMP      R0,#+32
   \   000001C0   0xBF08             IT       EQ 
   \   000001C2   0x1C6D             ADDEQ    R5,R5,#+1
   \   000001C4   0xD0F9             BEQ.N    ??parse_29
   \   000001C6   0xE78C             B.N      ??parse_16
    240              }
    241            }
    242          }
   \                     ??parse_11: (+1)
   \   000001C8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    243          
    244          #if ENABLED(CNC_COORDINATE_SYSTEMS)
    245          
    246            // Parse the next parameter as a new command
    247            bool GCodeParser::chain() {
    248              #if ENABLED(FASTER_GCODE_PARSER)
    249                char *next_command = command_ptr;
    250                if (next_command) {
    251                  while (*next_command && *next_command != ' ') ++next_command;
    252                  while (*next_command == ' ') ++next_command;
    253                  if (!*next_command) next_command = NULL;
    254                }
    255              #else
    256                const char *next_command = command_args;
    257              #endif
    258              if (next_command) parse(next_command);
    259              return !!next_command;
    260            }
    261          
    262          #endif // CNC_COORDINATE_SYSTEMS
    263          

   \                                 In section .text, align 2, keep-with-next
    264          void GCodeParser::unknown_command_error() {
   \                     _ZN11GCodeParser21unknown_command_errorEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    265            SERIAL_ECHO_START();
   \   00000002   0x....             LDR.N    R4,??DataTable3_1
   \   00000004   0x....             LDR.N    R5,??DataTable3_2
   \   00000006   0xE003             B.N      ??unknown_command_error_0
   \                     ??unknown_command_error_1: (+1)
   \   00000008   0xB2C9             UXTB     R1,R1
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??unknown_command_error_0: (+1)
   \   00000010   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000014   0x0008             MOVS     R0,R1
   \   00000016   0xD1F7             BNE.N    ??unknown_command_error_1
    266            SERIAL_ECHOPAIR(MSG_UNKNOWN_COMMAND, command_ptr);
   \   00000018   0x....             LDR.N    R0,??DataTable3
   \   0000001A   0x6A41             LDR      R1,[R0, #+36]
   \   0000001C   0x.... 0x....      ADR.W    R0,`?<Constant "Unknown command: \\"">`
   \   00000020   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
    267            SERIAL_CHAR('"');
   \   00000024   0x2122             MOVS     R1,#+34
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    268            SERIAL_EOL();
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000032   0x210A             MOVS     R1,#+10
   \   00000034   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    269          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     _ZN11GCodeParser14command_letterE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Unknown command: \\"">`:
   \   00000000   0x55 0x6E          DC8 "Unknown command: \""
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x3A    
   \              0x20 0x22    
   \              0x00         
   \   00000013   0x00               DC8 0
    270          
    271          #if ENABLED(DEBUG_GCODE_PARSER)
    272          
    273            void GCodeParser::debug() {
    274              SERIAL_ECHOPAIR("Command: ", command_ptr);
    275              SERIAL_ECHOPAIR(" (", command_letter);
    276              SERIAL_ECHO(codenum);
    277              SERIAL_ECHOLNPGM(")");
    278              #if ENABLED(FASTER_GCODE_PARSER)
    279                SERIAL_ECHO(" args: \"");
    280                for (char c = 'A'; c <= 'Z'; ++c)
    281                  if (seen(c)) { SERIAL_CHAR(c); SERIAL_CHAR(' '); }
    282              #else
    283                SERIAL_ECHOPAIR(" args: \"", command_args);
    284              #endif
    285              SERIAL_ECHOPGM("\"");
    286              if (string_arg) {
    287                SERIAL_ECHOPGM(" string: \"");
    288                SERIAL_ECHO(string_arg);
    289                SERIAL_CHAR('"');
    290              }
    291              SERIAL_ECHOPGM("\n\n");
    292              for (char c = 'A'; c <= 'Z'; ++c) {
    293                if (seen(c)) {
    294                  SERIAL_ECHOPAIR("Code '", c); SERIAL_ECHOPGM("':");
    295                  if (has_value()) {
    296                    SERIAL_ECHOPAIR("\n    float: ", value_float());
    297                    SERIAL_ECHOPAIR("\n     long: ", value_long());
    298                    SERIAL_ECHOPAIR("\n    ulong: ", value_ulong());
    299                    SERIAL_ECHOPAIR("\n   millis: ", value_millis());
    300                    SERIAL_ECHOPAIR("\n   sec-ms: ", value_millis_from_seconds());
    301                    SERIAL_ECHOPAIR("\n      int: ", value_int());
    302                    SERIAL_ECHOPAIR("\n   ushort: ", value_ushort());
    303                    SERIAL_ECHOPAIR("\n     byte: ", (int)value_byte());
    304                    SERIAL_ECHOPAIR("\n     bool: ", (int)value_bool());
    305                    SERIAL_ECHOPAIR("\n   linear: ", value_linear_units());
    306                    SERIAL_ECHOPAIR("\n  celsius: ", value_celsius());
    307                  }
    308                  else
    309                    SERIAL_ECHOPGM(" (no value)");
    310                  SERIAL_ECHOPGM("\n\n");
    311                }
    312              }
    313            }
    314          
    315          #endif // DEBUG_GCODE_PARSER

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   GCodeParser::parse(char *)
        24   -> __iar_Strchr
       0   GCodeParser::reset()
      16   GCodeParser::unknown_command_error()
         0   -> USARTClass::write(uint8_t)
        16   -> USARTClass::write(uint8_t)
        16   -> serial_echopair_P(char const *, char const *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "Unknown command: \"">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
      48  GCodeParser::command_letter
          GCodeParser::codebits
          GCodeParser::param
          GCodeParser::command_ptr
          GCodeParser::string_arg
          GCodeParser::codenum
     458  GCodeParser::parse(char *)
      20  GCodeParser::reset()
      56  GCodeParser::unknown_command_error()
       4  GCodeParser::value_ptr
       1  GCodeParser::volumetric_enabled
       4  parser
       1  -- Other

 
  57 bytes in section .bss
   1 byte  in section .rodata
 566 bytes in section .text
 
 566 bytes of CODE  memory
   0 bytes of CONST memory (+ 1 byte shared)
  57 bytes of DATA  memory

Errors: none
Warnings: 8
